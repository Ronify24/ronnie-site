<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>LUMIFY</title>

    <!-- Favicon -->
    <link rel="icon" href="/lum_web.png" type="image/png" sizes="32x32">
    <link rel="apple-touch-icon" href="/lum_web.png" sizes="180x180">

    <link rel="stylesheet"
          href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <link rel="stylesheet"
          href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap">

    <style>
        /* ======== RESET & GLOBAL ======== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #0b0e11;
            color: #eee;
            font-family: "Segoe UI", Tahoma, sans-serif;
        }

        #appContainer {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        a {
            text-decoration: none;
            color: inherit;
        }

        /* ======== TOP NAV BAR ======== */
        #topNavBar {
            width: 100%;
            background: linear-gradient(to right,#15191e,#1c1f24);
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 6px 20px;
            z-index: 12000;
        }

        .navLeft, .navRight {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .topLogo {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: default;
        }

        .topLogoIcon {
            width: 36px;
            height: 36px;
            background: url("/lum_logo.png") no-repeat center center;
            background-size: cover;
            border-radius: 50%;
            cursor: pointer;
        }

        .topLogoText {
            font-weight: 600;
            font-size: 20px;
            color: #eee;
        }

        .navItem {
            color: #bbb;
            font-size: 16px;
            cursor: pointer;
            padding: 6px 10px;
            border-radius: 4px;
            transition: background 0.3s, color 0.3s;
            position: relative;
            display: flex;
            align-items: center;
            gap: 6px;
        }

            .navItem:hover {
                background: rgba(61,224,181,0.15);
                color: #fff;
            }

        .dropdownMenu, .rightSubMenu {
            visibility: hidden;
            opacity: 0;
            pointer-events: none;
            transition: none !important;
            position: absolute;
            background: #1a1f24;
            box-shadow: 0 2px 5px rgba(0,0,0,0.4);
            z-index: 9999;
            border: 1px solid #333;
            border-radius: 4px;
        }

            .navItem:hover > .dropdownMenu,
            .dropdownMenu:hover,
            .dropdownItem:hover > .rightSubMenu,
            .rightSubMenu:hover {
                visibility: visible !important;
                opacity: 1 !important;
                pointer-events: auto;
            }

        .dropdownMenu {
            top: 32px;
            padding-top: 7px;
            left: 0;
            min-width: 140px;
            flex-direction: column;
            padding-bottom: 8px
        }

        .rightSubMenu {
            top: 0;
            left: 100%;
            margin-left: -6px;
            padding-left: 6px;
            min-width: 140px;
            z-index: 10050;
            flex-direction: column;
        }

        .dropdownItem {
            padding: 8px 12px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 16px;
            color: #bbb;
            border-bottom: 1px solid #2b2f35;
            cursor: pointer;
            position: relative;
        }

            .dropdownItem:hover {
                background: #333;
                color: #fff;
            }

        .clickModeCursor {
            cursor: pointer !important;
        }

        .standaloneBtn {
            color: #bbb;
            background: #1c1f24;
            font-size: 14px;
            border-radius: 4px;
            padding: 6px 10px;
            border: 1px solid #333;
            cursor: pointer;
            transition: background 0.3s, color 0.3s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

            .standaloneBtn:hover {
                background: rgba(61,224,181,0.15);
                color: #fff;
            }

        .bottomBtn {
            height: 36px;
            width: 48px;
            border: 1px solid #444;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background 0.3s;
        }

            .bottomBtn:hover {
                background: #3b4148;
                color: #fff;
            }

        #imageAdjustmentsBar {
            display: none;
            position: fixed;
            left: 0;
            right: 0;
            top: var(--image-adjustments-top, 62px);
            width: 100%;
            background: linear-gradient(90deg, rgba(27,34,39,0.96) 0%, rgba(17,23,26,0.94) 100%);
            backdrop-filter: blur(10px) saturate(1.05);
            border-bottom: 1px solid rgba(38,46,53,0.65);
            box-shadow: 0 16px 32px rgba(0,0,0,0.36);
            padding: 14px 26px;
            align-items: center;
            justify-content: center;
            gap: 18px;
            z-index: 11998;
            font-family: 'Inter', system-ui, sans-serif;
            pointer-events: none;
            box-sizing: border-box;
        }

            #imageAdjustmentsBar.open {
                display: flex;
                pointer-events: auto;
            }

            #imageAdjustmentsBar.has-adjustments {
                box-shadow: 0 20px 44px rgba(31,255,212,0.08);
            }

        #imageAdjustmentsBarContent {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 24px;
            width: 100%;
            max-width: 980px;
            flex-wrap: wrap;
        }

        #imageAdjustmentsRestore {
            display: flex;
            visibility: hidden;
            opacity: 0;
            pointer-events: none;
            color: #9fb8c5;
            cursor: pointer;
            font-size: 18px;
            transition: color 0.2s, opacity 0.2s;
            margin-right: 6px;
            align-items: center;
        }

            #imageAdjustmentsRestore:hover {
                color: #ffffff;
            }

        #imageAdjustmentsBar.has-adjustments #imageAdjustmentsRestore {
            visibility: visible;
            opacity: 1;
            pointer-events: auto;
        }

        #imageAdjustmentsBeforeAfter {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 16px;
            border-radius: 999px;
            border: 1px solid rgba(62,77,88,0.65);
            background: rgba(17,23,27,0.82);
            color: #a5c0ce;
            cursor: pointer;
            text-transform: uppercase;
            font-size: 11px;
            font-weight: 600;
            letter-spacing: 0.08em;
            transition: color 0.2s, background 0.2s, border-color 0.2s, box-shadow 0.2s, opacity 0.2s;
        }

            #imageAdjustmentsBeforeAfter i {
                font-size: 14px;
            }

            #imageAdjustmentsBeforeAfter:hover {
                color: #ffffff;
                border-color: #3ef4d0;
                box-shadow: 0 0 12px rgba(62,244,208,0.18);
            }

            #imageAdjustmentsBeforeAfter.active {
                color: #3ef4d0;
                border-color: #3ef4d0;
                box-shadow: 0 0 14px rgba(62,244,208,0.28);
            }

            #imageAdjustmentsBeforeAfter.disabled {
                opacity: 0.38;
                cursor: default;
                pointer-events: none;
                box-shadow: none;
            }

            #imageAdjustmentsBeforeAfter:focus-visible {
                outline: 2px solid #3ef4d0;
                outline-offset: 3px;
            }

        .imageAdjustmentsToggleLabel {
            white-space: nowrap;
        }

        #imageAdjustmentsToggle {
            margin-left: -3px;
        }

            #imageAdjustmentsToggle.active {
                background: rgba(61,224,181,0.15);
                color: #fff;
            }

            #imageAdjustmentsToggle.has-adjustments {
                color: #3ef4d0;
            }

                #imageAdjustmentsToggle.has-adjustments::after {
                    content: "";
                    position: absolute;
                    bottom: 4px;
                    right: 6px;
                    width: 6px;
                    height: 6px;
                    border-radius: 50%;
                    background: #38ffe3;
                    box-shadow: 0 0 6px #38ffe3aa;
                }

        .imageAdjustmentControl {
            display: flex;
            align-items: center;
            justify-content: flex-start;
            gap: 10px;
            flex: 1 1 220px;
            min-width: 210px;
        }

        .imageAdjustmentLabel {
            font-size: 12px;
            font-weight: 600;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: #c2d1d8;
            font-family: 'Inter', system-ui, sans-serif;
            white-space: nowrap;
        }

        .imageAdjustmentControl .stealthSlider {
            flex: 0 1 170px;
            max-width: 170px;
            min-width: 120px;
        }

        .imageAdjustmentValue {
            font-size: 12px;
            font-weight: 600;
            color: #98ffe3;
            background: rgba(21,26,30,0.9);
            padding: 2px 8px;
            border-radius: 6px;
            min-width: 38px;
            text-align: right;
            font-family: 'Inter', system-ui, sans-serif;
        }

        /* ------- sleek progress bar v2 -------- */
        #processBarWrapper {
            position: absolute;
            bottom: 50px; /* clears caption row */
            left: 14px;
            width: 240px;
            height: 8px; /* slimmer line */
            background: rgba(255,255,255,0.15);
            border-radius: 3px;
            overflow: hidden;
            display: none; /* toggled by JS */
            z-index: 10020; /* under menus, over canvas */
        }

        #processBar {
            width: 0%;
            height: 100%;
            background: rgb(43,224,165); /* sea-foam */
            transition: width .15s linear;
            /*            transition: width .25s cubic-bezier(.4,0,.2,1);*/
        }

            #processBar::after { /* subtle sheen */
                content: "";
                position: absolute;
                inset: 0;
                background: linear-gradient(120deg, rgba(255,255,255,0.35) 0%, rgba(255,255,255,0.00) 60%);
                mix-blend-mode: overlay;
                pointer-events: none;
            }

        #gpuBtn {
            background: #18e4aecc;
            color: #0b0e11;
            font-weight: 600;
        }

            #gpuBtn.cpuMode {
                background: #444;
                color: #ccc;
            }

        /* ======== MAIN AREA ======== */
        #mainArea {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            padding: 20px;
            position: relative;
        }

        #mainHeader {
            display: none;
            font-size: 22px;
            color: #bbb;
            margin-bottom: 12px;
            font-weight: 600;
            text-align: center;
        }

        #actionText {
            margin-left: 20px;
            color: #ddd;
            font-size: 22px;
            font-weight: 600;
        }

        #zoomControls {
            display: none;
            text-align: center;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        #resetZoomBtn {
            cursor: pointer;
            font-size: 16px;
            background: #444;
            color: #ccc;
            border: 1px solid #666;
            border-radius: 4px;
            padding: 6px 10px;
            display: inline-block;
            margin-left: 10px;
        }

        #canvasContainer {
            display: none;
            flex-direction: column;
            align-items: center;
            position: relative;
            margin: 0 auto;
        }

        .belowCaptionMode {
            position: absolute;
            transform: none; /* no centering transform here */
            width: 600px; /* or whatever you prefer for your prompt workflow */
        }

        #canvasSpinnerOverlay {
            position: absolute; /* position over the canvas container */
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.4); /* a translucent dark overlay */
            display: none; /* hidden by default */
            justify-content: center; /* center the spinner horizontally */
            align-items: center; /* center the spinner vertically */
            z-index: 10000; /* ensure it's above the canvas */
            pointer-events: none; /* let user clicks pass through if desired */
        }

        .spinner {
            width: 60px;
            height: 60px;
            border: 8px solid rgba(43,224,165,0.2); /* “seafoam” color but mostly transparent */
            border-left-color: rgb(43,224,165); /* make one side fully opaque */
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        #canvasWrapper {
            position: relative;
            transform-origin: top center;
            margin-bottom: 0;
            transform: scale(1);
            background: rgba(12,12,14,.65);
            backdrop-filter: blur(3px) saturate(120%);
            box-shadow: inset 0 0 0 1px rgba(180,180,200,.15), /* thin outline    */
            inset 0 8px 24px rgba(0,0,0,.35), /* top vignette    */
            0 8px 16px rgba(0,0,0,.45); /* drop shadow     */
            border-radius: 1px;
            overflow: visible;
            transition: transform .20s linear;
        }

        #canvasViewport {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        #canvasResizer,
        #canvasResizerLeft {
            position: absolute;
            bottom: 6px;
            width: 20px;
            height: 20px;
            opacity: .8;
        }

        #canvasResizer {
            right: 5px;
            cursor: se-resize;
        }

        #canvasResizerLeft {
            left: 5px;
            cursor: sw-resize;
        }

            #canvasResizer svg,
            #canvasResizerLeft svg {
                width: 100%;
                height: 100%;
                stroke: #eee;
                stroke-width: 2;
                fill: none;
            }

            #canvasResizerLeft svg {
                transform: scaleX(-1);
            }

        #canvasRestore,
        #canvasRestoreLeft {
            position: absolute; /* anchored to wrapper’s bottom corners */
            bottom: 12px; /* just above the resize‑grip */
            width: 12px;
            height: 12px;
            border: 2px solid rgba(116,116,128,.8);
            border-radius: 50%;
            background: transparent;
            cursor: pointer;
            transition: background .15s;
        }

        #canvasRestore {
            right: 12px;
        }

        #canvasRestoreLeft {
            left: 12px;
        }

            #canvasRestore:hover,
            #canvasRestoreLeft:hover {
                background: rgba(43,224,165,.9);
            }

        #canvas, #overlayCanvas {
            display: block;
        }

        #overlayCanvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 1006;
        }

        .darkInput {
            background-color: #1f1f1f; /* Or any dark shade */
            color: #fff; /* White text */
            border: 1px solid #444; /* A subtle border */
            border-radius: 4px; /* Slight rounding if you like */
            padding: 6px;
            font-size: 14px;
            outline: none; /* remove the default focus outline if you prefer */
        }

            /* optional: style on focus */
            .darkInput:focus {
                border-color: #777; /* highlight a bit more on focus */
            }

        #homePromptContainer {
            display: none;
            flex-direction: column;
            align-items: stretch;
            justify-content: center;
            padding: 20px;
        }

        #bgHoverArea {
            position: absolute;
            top: -250px;
            left: 0;
            right: 0;
            height: 250px;
            cursor: pointer;
        }

        /* Inner wrapper so we can style the box easily */
        #homePromptInner {
            display: flex;
            flex-direction: column;
            align-items: stretch;
            background: linear-gradient(135deg, #23272a, #1c1f24);
            padding: 24px 30px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
            max-width: 640px; /* limit the width if you like */
            width: 100%; /* fill if you want a big wide input */
            text-align: center;
        }

        #homePromptInner {
            cursor: grab;
        }

            #homePromptInner.dragging {
                cursor: grabbing;
            }

        .noDrag {
            cursor: auto;
        }
            /* plain arrow over empty areas        */
            .noDrag * {
                cursor: inherit;
            }
        /* let each child use its own setting */
        }

        #homePromptInner h1 {
            margin-bottom: 16px;
            font-size: 24px;
            color: #fff;
            cursor: grab; /* open hand on hover */
            user-select: none; /* stop accidental text highlight */
        }

            #homePromptInner h1:active {
                cursor: grabbing; /* closed hand while dragging */
            }

        #homePromptInner h1 {
            margin-bottom: 16px;
        }

        #homePromptCaption.hidden {
            display: none;
        }

        #promptBoxRow {
            display: flex;
            align-items: center;
            gap: 11px;
        }

        /* Prompt input styling */
        #homePromptInput {
            flex: 1 1 auto;
            background: #0f1317;
            color: #eee;
            border: 2px solid #333;
            border-radius: 4px;
            padding: 15px;
            font-family: 'Inter', system-ui, sans-serif;
            letter-spacing: 0.02em; /* optional: tighter tracking */
            font-size: 15px; /* adjust to taste */
            line-height: 1.4em;
            min-width: 300px; /* never collapse below 320 px       */
            max-width: 100%;
        }

            #homePromptInput::placeholder {
                color: #777;
            }

        @media (min-width: 900px) { /* only on desktop */
            #homePromptInput {
                max-width: 720px;
            }
        }

        #homePromptInner {
            backdrop-filter: blur(10px);
            background: rgba(20,25,30,0.6);
            /* plus a border or small stroke if you want a glassy border */
            border: 1px solid rgba(255,255,255,0.15);
            min-width: 650px;
            min-height: 200px;
        }

        /* Generate button styling */
        #homeGenerateBtn {
            background: #2c8567; /* your “seafoam” accent */
            color: #050608;
            border: none;
            border-radius: 4px;
            padding: 12px 16px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.3s ease;
            display: flex;
            align-items: center;
            gap: 6px;
            flex: 0 0 auto;
        }

            #homeGenerateBtn:hover {
                background: #22e0a1;
            }

        #homePromptCaption {
            margin-top: 13px;
            font-size: 13px;
            color: #bbb;
        }

        #homePromptModelSelect {
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            /* Layout */
            background: #1f1f1f /* dark fill   */
            url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' width='10' height='6' viewBox='0 0 10 6' fill='none' stroke='%23ccc' stroke-width='1.5' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='1 1 5 5 9 1'/%3e%3c/svg%3e") no-repeat 8px center; /* chevron left, 8 px padding   */
            color: #eee;
            border: 1px solid #333;
            border-radius: 4px;
            font-size: 13px;
            height: 28px;
            padding-left: 26px;
            font-size: 14px;
            padding-right: 14px;
            flex: 0 0 auto;
        }

            #homePromptModelSelect:hover {
                cursor: pointer;
            }

        .homeCenterMode {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: auto; /* or 400px, if you prefer a fixed width */
            max-width: 640px; /* limit if you like */
            margin: 0; /* ensure no extra top margin */
        }

        .promptHudMode {
            position: absolute;
            top: auto; /* clear any legacy top */
            left: auto; /* clear any legacy left */
            transform: none; /* neutralise any leftover translate */
            width: auto; /* keeps the same fluid width as before */
        }

        #bgFilename {
            margin-top: 5px;
            text-align: center;
            color: #bbb;
            font-size: 14px;
            font-weight: 500;
            display: none;
        }

        #beforeAfterLabel {
            margin-left: 8px;
            font-weight: bold;
            display: none;
        }

        #bgFilename .historyFocusIcon {
            position: static;
            margin-left: 8px;
            display: none;
            color: #e5b85c; /* match thumb focus color */
        }

            #bgFilename .historyFocusIcon.locked {
                background: #e5b85c;
                color: #0b0e11;
                border-radius: 50%;
                padding: 2px;
                box-shadow: 0 0 6px 2px rgba(229,184,92,0.6);
            }

        #beforeAfterLabel.before {
            color: #ffdf5d;
        }

        #beforeAfterLabel.after {
            color: #23e1b6;
        }

        #homeImageContainer {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #homeImage {
            max-width: 80%;
            height: auto;
            display: block;
            margin: 0 auto;
        }

        /* Lighting HUD – Rendering style selector */
        .styleIconRow {
            flex-wrap: nowrap;
            gap: .25em;
        }

        .styleIconButton {
            position: relative;
            width: 47px;
            height: 47px;
            padding: 0;
            font-size: 1.2em;
        }

            /* Active state (= Material/ToD parity) */
            .styleIconButton.active {
                background: #22282d;
                color: #f3faed;
                box-shadow: 0 0 0 2.1px #18f0b964;
                border-color: #23e1b6;
            }

            /* Optional subtle accents per style (keeps the look minimal) */
            .styleIconButton[data-style="painterly"].active {
                color: #e98c8c;
                border-color: #e98c8c;
            }

            .styleIconButton[data-style="animation"].active {
                color: #3db4eb;
                border-color: #3db4eb;
            }

            .styleIconButton[data-style="hyperreal"].active {
                color: #ffdf5d;
                border-color: #ffdf5d;
            }

        #lightingStyleDisplay {
            display: block;
            max-width: 100%;
            box-sizing: border-box;
            padding: 4px 8px;
            margin-top: 4px;
            color: #cfe;
            text-align: center;
            font-size: 13px;
            font-weight: 600;
            white-space: normal;
            overflow-wrap: break-word;
        }

        .buttonHudRow {
            display: flex;
            background: rgba(24, 26, 28, 0.2);
            box-shadow: 0 3px 12px 0 #10181a1a;
            align-items: center;
            justify-content: center; /* or center, as desired */
            gap: 1.13em;
            flex-wrap: wrap; /* prevent horizontal overflow */
            width: 100%;
            max-width: 1000px;
            margin: 0 auto;
            margin-bottom: 5px; /* space above caption bar */
            margin-left: auto;
            margin-right: auto;
            padding: 8px 10px;
            padding-top: 11px;
        }

        /* Stylize HUD drop zone */
        #stylizeImageDrop {
            width: 80px;
            height: 80px;
            border: 2px dashed #555;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #999;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }

            #stylizeImageDrop i {
                font-size: 28px;
            }

            #stylizeImageDrop.dragover {
                border-color: #17f0c2;
                color: #17f0c2;
            }

            #stylizeImageDrop.loaded {
                width: 150px;
                height: 150px;
                border-style: solid;
            }

                #stylizeImageDrop.loaded img {
                    width: 100%;
                    height: 100%;
                    object-fit: cover;
                }

            #stylizeImageDrop .imageRemoveBtn {
                position: absolute;
                top: 4px;
                right: 4px;
                background: rgba(0,0,0,0.6);
                border: none;
                color: #fff;
                cursor: pointer;
                padding: 2px 4px;
                border-radius: 3px;
                display: none;
            }

            #stylizeImageDrop.loaded:hover .imageRemoveBtn {
                display: block;
            }

        .todIconRow {
            flex-wrap: nowrap;
            gap: 0.25em;
        }

        .stylizeIconRow {
            flex-wrap: nowrap;
            gap: 0.25em;
        }

        .buttonHudIcon {
            background: #181c1d;
            border: 1.5px solid #222c2f;
            border-radius: 0.6em;
            color: #6dd9be;
            font-size: 1.05em;
            padding: 0.62em 0.62em;
            margin: 0 0.08em;
            min-width: 40px;
            min-height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            opacity: 0.87;
            transition: background 0.14s, color 0.13s, box-shadow 0.13s, border-color 0.13s;
            box-shadow: 0 0 0 0.5px #16ffbf1a;
        }

        /* Time of Day HUD icon buttons */
        .todIconButton {
            position: relative;
            width: 47px;
            height: 47px;
            padding: 0;
            font-size: 1.2em;
        }

            .todIconButton .todIconValue {
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                font-size: 0.75em;
                pointer-events: none;
            }

            .todIconButton.active {
                background: #22282d;
                color: #f3faed;
                box-shadow: 0 0 0 2.1px #18f0b964;
                border-color: #23e1b6;
            }

        .stylizeIconButton {
            position: relative;
            width: 47px;
            height: 47px;
            padding: 0;
            font-size: 1.2em;
        }

            .stylizeIconButton.active {
                background: #22282d;
                color: #f3faed;
                box-shadow: 0 0 0 2.1px #18f0b964;
                border-color: #23e1b6;
            }

        .buttonHudIcon:hover {
            background: #22282d;
            color: #f3faed;
            box-shadow: 0 0 0 2.1px #18f0b964;
            border-color: #23e1b6;
        }

        .todIconButton[data-tod="golden_am"]:hover,
        .todIconButton[data-tod="golden_am"].active {
            color: #ffb375;
            border-color: #ffb375;
            box-shadow: 0 0 0 2.1px #ffb37564;
        }

        .todIconButton[data-tod="midday"]:hover,
        .todIconButton[data-tod="midday"].active {
            color: #3db4eb;
            border-color: #3db4eb;
            box-shadow: 0 0 0 2.1px #3db4eb64;
        }

        .todIconButton[data-tod="overcast"]:hover,
        .todIconButton[data-tod="overcast"].active {
            color: #9dacbd;
            border-color: #9dacbd;
            box-shadow: 0 0 0 2.1px #9dacbd64;
        }

        .todIconButton[data-tod="sunset"]:hover,
        .todIconButton[data-tod="sunset"].active {
            color: #ed8791;
            border-color: #ed8791;
            box-shadow: 0 0 0 2.1px #ed879164;
        }

        .todIconButton[data-tod="blue_hour"]:hover,
        .todIconButton[data-tod="blue_hour"].active {
            color: #3768b8;
            border-color: #3768b8;
            box-shadow: 0 0 0 2.1px #3768b864;
        }

        .todIconButton[data-tod="night"]:hover,
        .todIconButton[data-tod="night"].active {
            color: #b3a1dd;
            border-color: #b3a1dd;
            box-shadow: 0 0 0 2.1px #b3a1dd64;
        }


        .buttonHudIcon.fresh {
            color: #ffdf5d;
            border-color: #ffdf5d;
            box-shadow: 0 0 0 2.1px rgba(255,223,93,0.4);
        }

        .buttonHudIcon.flash {
            animation: btnFlash 0.23s cubic-bezier(.31,1.1,.64,1.0);
        }

        @keyframes btnFlash {
            0% {
                box-shadow: 0 0 0 0 #18f0b9, 0 0 0 0 #2be0a5;
            }

            80% {
                box-shadow: 0 0 0 9px #2be0a561, 0 0 0 13px #18f0b931;
            }

            100% {
                box-shadow: 0 0 0 0 #18f0b900, 0 0 0 0 #2be0a500;
            }
        }

        /* ── Time of Day: centered sliders that match Material Quality ── */
        /*#workflowTimeOfDayHUD .matSliderRow {
            display: grid;
            grid-template-columns: 1fr;
            row-gap: 6px;
            justify-items: center;
            text-align: center;
        }

            #workflowTimeOfDayHUD .matSliderRow input[type="range"] {
                width: min(420px, 92%);
                margin: 0 auto;
            }

        #workflowTimeOfDayHUD .matSliderHint {
            width: min(420px, 92%);
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr auto 1fr;*/ /* left label — value — right label */
        /*align-items: center;
            color: #9bd;
        }

            #workflowTimeOfDayHUD .matSliderHint span:first-child {
                justify-self: start;
            }

            #workflowTimeOfDayHUD .matSliderHint span:last-child {
                justify-self: end;
            }

        #workflowTimeOfDayHUD .matSliderReadout {
            width: min(420px, 92%);
            margin: 0 auto;
            display: flex;
            justify-content: center;
            color: #9bd;
            font-variant-numeric: tabular-nums;
        }*/

        /* Time of Day: remove the spacer above the tint pane */
        #workflowTimeOfDayHUD .hudScrollArea > .hudSection:first-child > .hudSectionBody {
            padding-top: 0; /* removes the ~10px cushion */
            border-top: 0; /* removes the 1px rule */
        }

        /* The tint pane itself also has .hudSectionBody; drop its internal top rule too */
        #workflowTimeOfDayHUD #todTintPane {
            border-top: 0;
        }

        /* Advanced Prompt: vertical resize only (prevents layout break) */
        #todPromptInput {
            resize: vertical !important;
            max-width: 100%;
            overflow: auto;
        }

        /* Hide old multi-select (we keep it for compatibility / data source) */
        #todSweetenerSelect {
            display: none;
        }

        /* Extras dropdown (compact + Material-HUD vibe) */
        #todExtrasControl {
            position: relative;
            display: inline-block;
        }

        #todExtrasToggle {
            background: #152126;
            color: #cfe;
            border: 1.5px solid #23343a;
            border-radius: 999px;
            font-weight: 600;
            padding: 8px 34px 8px 14px;
            min-width: 220px;
            cursor: pointer;
            box-shadow: inset 0 0 0 1px rgba(255,255,255,.06);
        }

            #todExtrasToggle::after {
                content: "▾";
                position: absolute;
                right: 12px;
                top: 50%;
                transform: translateY(-50%);
                color: #7fbfcf;
                pointer-events: none;
            }

        #todExtrasMenu {
            position: absolute;
            top: calc(100% + 6px);
            left: 0;
            min-width: 240px;
            background: #151d21f8;
            border: 1.5px solid #23343a;
            border-radius: 10px;
            padding: 8px 10px;
            box-shadow: 0 .25px 18px 0 #22ffbf14;
            display: none;
            z-index: 8001;
        }

        #todExtrasControl.open #todExtrasMenu {
            display: block;
        }

        #todExtrasMenu .optRow {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 6px;
            border-radius: 6px;
            cursor: pointer;
        }

            #todExtrasMenu .optRow:hover {
                background: #192a30;
            }

        /* Selected extras chips */
        #todExtrasSummary {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            justify-content: center;
        }

        /* Stylize: match Time of Day dropdown + chips */
        #stylizePromptInput {
            resize: vertical !important;
            max-width: 100%;
            overflow: auto;
        }

        #stylizeDescriptorSelect {
            display: none;
        }

        #stylizeExtrasControl {
            position: relative;
            display: inline-block;
        }

        #stylizeExtrasToggle {
            background: #152126;
            color: #cfe;
            border: 1.5px solid #23343a;
            border-radius: 999px;
            font-weight: 600;
            padding: 8px 34px 8px 14px;
            min-width: 220px;
            cursor: pointer;
            box-shadow: inset 0 0 0 1px rgba(255,255,255,.06);
        }

            #stylizeExtrasToggle::after {
                content: "▾";
                position: absolute;
                right: 12px;
                top: 50%;
                transform: translateY(-50%);
                color: #7fbfcf;
                pointer-events: none;
            }

        #stylizeExtrasMenu {
            position: absolute;
            top: calc(100% + 6px);
            left: 0;
            min-width: 240px;
            background: #151d21f8;
            border: 1.5px solid #23343a;
            border-radius: 10px;
            padding: 8px 10px;
            box-shadow: 0 .25px 18px 0 #22ffbf14;
            display: none;
            z-index: 8001;
        }

        #stylizeExtrasControl.open #stylizeExtrasMenu {
            display: block;
        }

        #stylizeExtrasMenu .optRow {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 6px;
            border-radius: 6px;
            cursor: pointer;
        }

            #stylizeExtrasMenu .optRow:hover {
                background: #192a30;
            }

        #stylizeExtrasSummary {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            justify-content: center;
        }

        .todChip {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            background: #181c1d;
            color: #cfe;
            border: 1px solid #23343a;
            border-radius: 999px;
            padding: 3px 10px;
            font-size: 12px;
        }

            .todChip .x {
                background: transparent;
                color: #cfe;
                border: 0;
                cursor: pointer;
                font-size: 12px;
                opacity: .85;
            }


        /* Seed lock button uses the same style as Material’s .iconBtn */

        /* Frosted “glass” pane that can be tinted */
        #workflowTimeOfDayHUD .todTint {
            --tod-bg: linear-gradient( to bottom right, rgba(26,36,41,.92), rgba(24,28,33,.86) );
            --tod-tint: transparent; /* set by JS per daypart */
            position: relative;
            background: var(--tod-bg);
            border-radius: 12px;
            overflow: hidden;
            backdrop-filter: blur(6px) saturate(115%);
        }

            /* Soft colored bloom that matches the selected daypart */
            #workflowTimeOfDayHUD .todTint::before {
                content: "";
                position: absolute;
                inset: -20px; /* bleed slightly outside for feather */
                background: radial-gradient(120% 120% at 20% 0%, var(--tod-tint) 0%, rgba(0,0,0,0) 55%);
                filter: blur(25px);
                opacity: .90; /* overall subtlety */
                pointer-events: none;
            }

        /* Keep your existing body padding/border; just ensure it’s after the pane styles */
        #workflowTimeOfDayHUD .hudSectionBody {
            border-top: 1px solid #555;
            padding: 10px 12px;
        }

        /* Contain and wrap the Time of Day phrase text */
        #workflowTimeOfDayHUD #todDaypartLabel,
        #workflowTimeOfDayHUD #todDaypartDisplay {
            display: block;
            max-width: 100%;
            box-sizing: border-box;
            padding: 4px 8px;
            margin-top: 4px;
            color: #cfe;
            word-wrap: break-word; /* wrap long words */
            overflow-wrap: break-word; /* modern alias */
            white-space: normal; /* allow line breaks */
        }

        #workflowTimeOfDayHUD #todDaypartDisplay {
            font-size: 13px;
            line-height: 1.3;
        }




        .hudCancelBtn {
            background: none;
            border: none;
            border-radius: 0.7em;
            color: #d66a6a;
            font-size: 1.23em;
            margin: 0 0.2em;
            padding: 0.34em 0.62em;
            cursor: pointer;
            transition: background 0.15s, color 0.12s, box-shadow 0.13s;
            box-shadow: 0 0 0 1.7px #d6212141;
        }

            .hudCancelBtn:hover {
                background: #fbe7e7;
                color: #a50c0c;
                box-shadow: 0 0 0 2.1px #d62121a1;
            }

        .captionBarContainer {
            position: static;
            margin: 18px auto 0 auto;
            margin-left: auto;
            margin-right: auto;
            width: auto; /* Only as wide as needed, up to max-width */
            min-width: 415px;
            max-width: 900px; /* Or your preferred width */
            background: #161d21ee; /* less opacity for a subtle glow */
            border-radius: 18px;
            box-shadow: 0 2px 24px 0 #22ffbf0B, 0 0 0 2px #21f2c915;
            padding: 0.7em 1.1em 0.7em 1.1em;
            display: flex;
            flex-direction: column; /* Stacks content vertically */
            align-items: stretch;
            z-index: 3900;
            pointer-events: auto;
            transition: max-width 0.3s cubic-bezier(.51,.14,.37,1.34);
        }

            .captionBarContainer.visible {
                opacity: 1;
            }


        .captionBarRow {
            display: flex;
            align-items: flex-start;
            gap: 1.0em;
        }

        .captionIcon {
            color: #31e9b1bb;
            font-size: 1.15em;
            padding-top: 0.04em;
            opacity: 0.87;
        }

        .captionText {
            font-size: 1.09em;
            font-weight: 500;
            color: #daf6eb;
            min-width: 90px;
            max-width: 98%;
            min-height: 1.3em;
            line-height: 1.46;
            word-break: break-word;
            white-space: pre-wrap; /* Allow multi-line */
            max-height: 12em; /* Grows vertically, not horizontally */
            overflow-y: auto;
            padding: 0.14em 0.3em;
            background: none;
            border: none;
            outline: none;
            border-radius: 10px;
            transition: max-height 0.22s;
        }

            .captionText:empty::before {
                content: "Your AI-generated caption will appear here…";
                color: #5ae7cf84;
                font-style: italic;
            }

        .captionCopyBtn {
            background: #1b262b;
            border: none;
            border-radius: 0.6em;
            color: #85ffe1;
            font-size: 1.09em;
            padding: 0.38em 0.67em;
            margin-left: 0.38em;
            opacity: 0.83;
            cursor: pointer;
            transition: background 0.14s, color 0.13s;
            box-shadow: 0 0 0 1.7px #22ffbf41;
        }

            .captionCopyBtn:active,
            .captionCopyBtn.copied {
                background: #28ebc1;
                color: #171d21;
                opacity: 1;
                box-shadow: 0 0 0 2.3px #18f0b9b7;
            }


        /*        #deleteFgBtn {
            cursor: pointer;
            font-size: 18px;
            background: #2b2f35;
            border-radius: 4px;
            padding: 6px 8px;
            transition: background 0.3s;
            border: 1px solid #444;
            display: flex;
            align-items: center;
            justify-content: center;
        }

            #deleteFgBtn:hover {
                background: rgba(61,224,181,0.25);
                color: #eee;
            }*/

        /*        #resetViewBtn {
            cursor: pointer;
            font-size: 18px;
            background: #2b2f35;
            border-radius: 4px;
            padding: 6px 8px;
            transition: background 0.3s;
            border: 1px solid #444;
            display: flex;
            align-items: center;
            justify-content: center;
        }*/
        /*
            #resetViewBtn:hover {
                background: rgba(61,224,181,0.15);
                color: #fff;
            }*/

        /*        #copyCaptionBtn, #downloadCanvasBtn, #toggleOverlayBtn {
            cursor: pointer;
            font-size: 18px;
            background: #2b2f35;
            border-radius: 4px;
            padding: 6px 8px;
            transition: background 0.3s;
            border: 1px solid #444;
        }

            #downloadCanvasBtn:hover {
                background: rgba(61,224,181,0.25);
                color: #eee;
            }*/

        /*        #captionBox {
            flex: 1;
            text-align: center;
            color: #eee;
            font-size: 14px;
            background: #161a1f;
            border: 1px solid #2b2f35;
            padding: 8px 12px;
            border-radius: 4px;
            min-height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-style: italic;
            max-height: 60px;
            overflow-y: auto;
        }*/

        .gray30Active {
            background: rgba(200,200,200,0.15) !important;
            color: #fff !important;
            font-weight: 600 !important;
        }

        .seafoam30Active {
            background: rgba(43,224,165,0.3) !important;
            color: #eee !important;
            font-weight: 600 !important;
        }

        .overlayOn {
            background: #fff !important;
            color: #000 !important;
            font-weight: 600 !important;
        }

        .enhanceOn {
            background: rgba(43,224,165,0.4) !important;
            color: #fff !important;
            font-weight: 700 !important;
        }

        /* SAMPLES / GALLERY Overlays */
        #samplesOverlay, #galleryOverlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.3);
            backdrop-filter: blur(8px);
            z-index: 13000;
            justify-content: center;
            align-items: center;
        }

        #focusOverlay {
            display: none;
            position: fixed;
            top: var(--menu-bar-h,48px);
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            backdrop-filter: blur(6px);
            z-index: 11008;
            pointer-events: none;
        }

        /* SAMPLES Overlays */
        #samplesBox {
            position: relative;
            width: 768px;
            height: 768px;
            top: -100px;
            background: rgba(255,255,255,0.05);
            box-shadow: 0 0 12px rgba(0,0,0,0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        #samplesImage {
            display: block;
            max-width: 768px;
            max-height: 768px;
            margin: 0 auto;
            border-radius: 12px;
        }

        .samplesArrow {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            color: #eee;
            font-size: 28px;
            background: rgba(0,0,0,0.3);
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.3s;
        }

            .samplesArrow:hover {
                background: rgba(0,0,0,0.6);
            }

        #samplesArrowLeft {
            left: 10px;
        }

        #samplesArrowRight {
            right: 10px;
        }

        .sampleImgTile {
            position: relative;
            display: inline-block;
            margin: 0.7em 0.8em 0.7em 0.2em;
            overflow: visible;
            vertical-align: top;
        }

        .sampleImg {
            display: block;
            border-radius: 12px;
            box-shadow: 0 2px 12px 0 #22ffbf16;
            width: 164px; /* or your actual sample width */
            height: 164px; /* keep aspect if needed */
            object-fit: cover;
        }


        #useSampleBtn {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 12;
            display: none;
            /* Keep your seafoam/modern styling from above here */
        }

            #samplesBox:hover #useSampleBtn,
            #useSampleBtn:focus {
                display: block;
            }


        #closeSamplesBtn {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 24px;
            color: #fff;
            background: rgba(0,0,0,0.3);
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.3s;
            z-index: 999;
        }

            #closeSamplesBtn:hover {
                background: rgba(0,0,0,0.6);
            }

        /* GALLERY Overlays */
        #galleryOverlay {
            flex-direction: column;
            justify-content: flex-start;
            align-items: flex-start;
            padding-top: 80px;
            padding-left: 20px;
            padding-right: 20px;
            overflow-y: auto;
            -ms-overflow-style: none;
            scrollbar-width: none;
        }

            #galleryOverlay::-webkit-scrollbar {
                display: none;
            }

        #galleryControls {
            position: fixed;
            top: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 8px;
            z-index: 100000;
        }

        #galleryControlsTop {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #galleryCollectionsToggle {
            padding: 6px 12px;
            border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.2);
            background: rgba(0,0,0,0.35);
            color: #fff;
            font-size: 15px;
            letter-spacing: 0.6px;
            cursor: pointer;
            transition: background 0.2s, color 0.2s, border 0.2s;
        }

            #galleryCollectionsToggle:hover {
                background: rgba(61,224,181,0.2);
                border-color: rgba(61,224,181,0.6);
            }

            #galleryCollectionsToggle.active {
                background: rgba(61,224,181,0.35);
                border-color: rgba(61,224,181,0.9);
                color: #0b0e11;
                font-weight: 600;
            }

        #gallerySizeSlider {
            width: 150px;
            opacity: 0.3;
            transition: opacity 0.2s;
        }

            #gallerySizeSlider:hover {
                opacity: 0.8;
            }

        #closeGalleryBtn {
            font-size: 24px;
            color: #fff;
            background: rgba(0,0,0,0.3);
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.3s;
        }

            #closeGalleryBtn:hover {
                background: rgba(0,0,0,0.6);
            }

        .galleryAddBtn {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 34px;
            height: 34px;
            border-radius: 50%;
            border: 1px solid rgba(255,255,255,0.25);
            background: rgba(0,0,0,0.55);
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
            transition: background 0.2s, color 0.2s, border 0.2s, transform 0.2s, opacity 0.2s;
            z-index: 2;
        }

            .galleryItem:hover .galleryAddBtn,
            .galleryAddBtn:focus,
            .galleryAddBtn:focus-visible {
                opacity: 1;
                visibility: visible;
                pointer-events: auto;
            }

            .galleryAddBtn:hover {
                background: rgba(61,224,181,0.55);
                border-color: rgba(61,224,181,0.9);
                transform: scale(1.05);
            }

            .galleryAddBtn.active {
                background: rgba(61,224,181,0.85);
                border-color: rgba(61,224,181,1);
                color: #0b0e11;
                font-weight: 700;
                opacity: 1;
                visibility: visible;
                pointer-events: auto;
            }

            .galleryAddBtn i {
                pointer-events: none;
            }

        #galleryHeader {
            font-size: 24px;
            font-weight: 600;
            margin-bottom: 20px;
            color: #fff;
            text-align: center;
            width: 100%;
        }

        #galleryGrid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(260px,1fr));
            gap: 12px;
            width: 100%;
            box-sizing: border-box;
        }

        .galleryItem {
            position: relative;
            background: #222;
            border-radius: 8px;
            overflow: hidden;
            cursor: pointer;
            transition: transform 0.2s;
            aspect-ratio: 16 / 9;
        }

            .galleryItem:hover {
                transform: scale(1.02);
            }

        .galleryImg {
            width: 100%;
            height: 100%;
            display: block;
            border-radius: 8px;
            object-fit: cover;
        }

        .galleryEmptyMessage {
            grid-column: 1 / -1;
            text-align: center;
            padding: 40px 20px;
            color: #9aa0a6;
            background: rgba(0,0,0,0.35);
            border: 1px dashed rgba(255,255,255,0.15);
            border-radius: 8px;
            font-size: 16px;
            letter-spacing: 0.4px;
        }

        /* SETTINGS OVERLAY */
        #settingsOverlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            backdrop-filter: blur(6px);
            z-index: 9999;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        #settingsBox {
            position: relative;
            width: 480px;
            max-height: 90vh;
            background: rgba(30,30,30,0.95);
            box-shadow: 0 0 12px rgba(0,0,0,0.5);
            border-radius: 8px;
            padding: 24px;
            color: #eee;
            display: flex;
            flex-direction: column;
            gap: 14px;
        }

        #assetsOverlay {
            display: none; /* JS flips to block */
            position: fixed;
            top: 0;
            left: 0;
            width: 325px; /* same width as Flip Book */
            height: 100vh;
            background: rgba(0,0,0,.3);
            backdrop-filter: blur(12px);
            z-index: 9999;
            padding-top: 60px; /* room for header / X */
            box-shadow: 3px 0 10px rgba(0,0,0,.5);
            overflow: hidden;
        }
        /* close “×” */
        #closeAssetsBtn {
            position: absolute;
            top: 16px;
            right: 16px;
            font-size: 20px;
            color: #fff;
            background: rgba(0,0,0,.3);
            border-radius: 4px;
            padding: 6px 8px;
            cursor: pointer;
            transition: background .3s;
        }

            #closeAssetsBtn:hover {
                background: rgba(0,0,0,.6);
            }
        /* panel header */
        #assetsHeader {
            text-align: center;
            color: #fff;
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 10px;
        }
        /* scroll container */
        #assetsScrollArea {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: calc(100% - 60px);
            overflow: hidden;
            scrollbar-width: none;
        }
        /* vertical list of thumbs */
        #assetsImagesWrapper {
            flex: 1;
            width: 100%;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            scrollbar-width: none;
        }

            #assetsImagesWrapper::-webkit-scrollbar {
                width: 0;
                background: transparent;
            }

        #recentOverlay {
            display: none;
            position: fixed;
            top: var(--menu-bar-h);
            left: 0;
            width: 325px;
            height: calc(100vh - var(--menu-bar-h));
            background: rgba(0,0,0,.3);
            backdrop-filter: blur(12px);
            z-index: 9999;
            padding-top: 60px;
            box-shadow: 3px 0 10px rgba(0,0,0,.5);
            overflow: hidden;
        }

        #closeRecentBtn {
            position: absolute;
            top: 16px;
            right: 16px;
            font-size: 20px;
            color: #fff;
            background: rgba(0,0,0,.3);
            border-radius: 4px;
            padding: 6px 8px;
            cursor: pointer;
            transition: background .3s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

            #closeRecentBtn:hover {
                background: rgba(0,0,0,.6);
            }

        #recentHeader {
            text-align: center;
            color: #fff;
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 10px;
        }

        #recentScrollArea {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: calc(100% - 60px);
            overflow: hidden;
            scrollbar-width: none;
        }

        #recentImagesWrapper {
            flex: 1;
            width: 100%;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            scrollbar-width: none;
        }

            #recentImagesWrapper::-webkit-scrollbar {
                width: 0;
                background: transparent;
            }

        #closeSettingsBtn {
            position: absolute;
            top: 12px;
            right: 12px;
            font-size: 18px;
            color: #aaa;
            background: transparent;
            cursor: pointer;
            transition: color 0.2s;
        }

            #closeSettingsBtn:hover {
                color: #fff;
            }

        #settingsBox h2 {
            margin-bottom: 6px;
            font-size: 20px;
            text-align: center;
            color: #fff;
        }

        .settingsSection {
            background: rgba(255,255,255,0.04);
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 8px;
            position: relative;
            border: 1px solid #333;
        }

            .settingsSection h3 {
                margin-bottom: 8px;
                font-size: 16px;
                font-weight: 600;
                color: rgb(30,170,145);
            }

        #settingsBox label {
            font-size: 14px;
            margin-bottom: 4px;
            display: block;
            color: #ccc;
        }

        #settingsBox select,
        #settingsBox input[type="text"] {
            margin-bottom: 10px;
            background: #1f1f1f;
            border: 1px solid #333;
            color: #eee;
            padding: 6px 8px;
            border-radius: 4px;
            width: 100%;
            outline: none;
            box-sizing: border-box;
        }

        .sectionFocusBtn {
            position: absolute;
            top: 6px;
            left: 50%;
            transform: translateX(-50%);
            right: auto;
            width: 12px;
            height: 12px;
            border: 2px solid rgba(116,116,128,0.8); /* seafoam glow */
            border-radius: 50%;
            background: transparent; /* default un-focused state => transparent fill */
            cursor: pointer;
            transition: background 0.3s;
            z-index: 10;
        }

            /* “active” or “focused” state => fill background, stronger glow */
            .sectionFocusBtn.active {
                /* highlight fill => remove glows and shadows, just fill the inside */
                background: #24f2b1;
            }

        #flipBookOverlay {
            display: none; /* shown by JS */
            position: fixed;
            top: 0;
            left: 0;
            width: 325px; /* panel - tweak as desired */
            height: 100vh; /* full vertical height */
            background: rgba(0,0,0,0.3); /* translucent black for blur effect */
            backdrop-filter: blur(12px); /* frosted glass */
            z-index: 9999;
            padding-top: 60px; /* top margin for close button/header */
            box-shadow: 3px 0 10px rgba(0,0,0,0.5);
            overflow: hidden;
        }

        :root {
            --menu-bar-h: 48px; /* keep in sync with #topNavBar’s real height  */
        }

        #flipBookOverlay,
        #assetsOverlay {
            top: var(--menu-bar-h); /* was 0              */
            height: calc(100vh - var(--menu-bar-h)); /* keep full height   */
        }

        /* Close button at top */
        #closeFlipBookBtn {
            position: absolute;
            top: 16px;
            right: 16px;
            font-size: 20px;
            color: #fff;
            cursor: pointer;
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
            padding: 6px 8px;
            transition: background 0.3s;
        }

            #closeFlipBookBtn:hover {
                background: rgba(0,0,0,0.6);
            }

        .assetsItem {
            width: 90%;
            margin-bottom: 12px;
            position: relative;
            display: flex;
            justify-content: center;
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(14px);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.2s;
        }

            .assetsItem:hover {
                background: rgba(255,255,255,0.2);
            }

        .assetsImg {
            max-width: 100%;
            height: auto;
            pointer-events: none;
        }

        .assetsModelThumb {
            width: 100%;
            height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            color: #fff;
            background: rgba(0,0,0,0.3);
            pointer-events: none;
            padding: 0 6px;
            text-align: center;
            white-space: nowrap;
            gap: 6px;
        }

        .assetsModelName {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .assetsModelThumb {
            width: 100%;
            height: 100px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            color: #fff;
            background: rgba(0,0,0,0.3);
            pointer-events: none;
        }

        .assetsScrollControls {
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: flex-start;
            gap: 30px; /* Controls space between arrow and import icon */
            margin-bottom: 6px;
            margin-top: 6px;
        }

        .assetsImportBtn {
            font-size: 1.6em;
            color: #eee;
            transition: color 0.14s;
            cursor: pointer;
            user-select: none;
            pointer-events: auto;
            padding: 3px 4px;
            border-radius: 7px;
        }

            .assetsImportBtn:hover {
                color: #31e9b1;
                background: rgba(49,233,177,0.07);
            }
        /* Up/down arrow styling */
        .assetsArrow {
            width: 36px;
            height: 36px;
            background: rgba(0,0,0,0.2);
            color: #fff;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            margin: 6px 0;
            transition: background 0.3s;
        }

            .assetsArrow:hover {
                background: rgba(0,0,0,0.5);
            }

        /* Optional header */
        #flipBookHeader {
            text-align: center;
            color: #fff;
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 10px;
        }

        /* Container with up/down arrows plus the list of images */
        #flipBookScrollArea {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: calc(100% - 60px); /* subtract space for top margin */
            overflow: hidden; /* keep the wrapper from overflowing */
            scrollbar-width: none;
        }

        .flipBookScrollControls {
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: flex-start;
            gap: 30px; /* Controls space between arrow and import icon */
            margin-bottom: 6px;
            margin-top: 6px;
        }

        .flipBookImportBtn {
            font-size: 1.6em;
            color: #eee;
            transition: color 0.14s;
            cursor: pointer;
            user-select: none;
            pointer-events: auto;
            padding: 3px 4px;
            border-radius: 7px;
        }

            .flipBookImportBtn:hover {
                color: #31e9b1;
                background: rgba(49,233,177,0.07);
            }
        /* Up/down arrow styling */
        .flipBookArrow,
        .assetsArrow {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.3em;
            color: #eee;
            width: 40px;
            height: 48px;
            cursor: pointer;
            background: none;
            border-radius: 7px;
            transition: color 0.15s, background 0.14s;
            user-select: none;
            border: none;
            font-weight: 900;
        }

            .flipBookArrow:hover,
            .assetsArrow:hover {
                color: #31e9b1;
                background: rgba(49,233,177,0.07);
            }

        /* The wrapper that holds all images. We’ll shift it up/down or scroll. */
        #flipBookImagesWrapper {
            flex: 1;
            width: 100%;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            scrollbar-width: none;
        }

            #flipBookImagesWrapper::-webkit-scrollbar {
                width: 0px;
                background: transparent; /* hide scrollbar in Chrome/Edge/Safari */
            }

        /* Each item (image container) with transparent PNG on a frosted background */
        .flipBookItem {
            width: 90%; /* or set a fixed width, e.g., 200px */
            margin-bottom: 12px;
            position: relative;
            display: flex;
            justify-content: center;
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(14px);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.2s;
        }

            .flipBookItem:hover {
                background: rgba(255,255,255,0.2);
            }

        /* Actual PNG inside .flipBookItem */
        .flipBookImg {
            max-width: 100%;
            height: auto;
            pointer-events: none;
        }

        #settingsBox input[type="range"] {
            width: 100%;
            cursor: pointer;
            margin: 6px 0;
            -webkit-appearance: none;
            background: #666;
            height: 4px;
            border-radius: 2px;
            outline: none;
        }

            #settingsBox input[type="range"]::-webkit-slider-thumb {
                -webkit-appearance: none;
                width: 14px;
                height: 14px;
                background: rgb(43,224,165);
                border-radius: 50%;
                border: 2px solid #999;
            }

            #settingsBox input[type="range"]::-moz-range-thumb {
                width: 14px;
                height: 14px;
                background: rgb(43,224,165);
                border-radius: 50%;
                border: 2px solid #999;
            }

        .sliderRow {
            display: flex;
            align-items: center;
            gap: 8px;
        }

            .sliderRow label {
                width: 60px;
            }

            .sliderRow input[type="range"] {
                flex: 1;
                margin-right: 6px;
            }

            .sliderRow .sliderValue {
                min-width: 32px;
                text-align: center;
            }

        .sliderValue {
            width: 42px;
            text-align: center;
            background: #222;
            color: #ccc;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 4px 6px;
            font-size: 13px;
        }

        .settingsScrollable {
            max-height: 60vh;
            overflow-y: auto;
            padding-right: 6px;
            scrollbar-width: none;
        }

            .settingsScrollable::-webkit-scrollbar {
                width: 0px;
                background: transparent;
            }

        #scrollArrowsRow {
            position: absolute;
            bottom: 64px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            z-index: 10;
        }

        #scrollUpBtn, #scrollDownBtn {
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            padding: 4px 8px;
            cursor: pointer;
            transition: background 0.2s;
        }

            #scrollUpBtn:hover, #scrollDownBtn:hover {
                background: rgba(255,255,255,0.2);
            }

            #scrollUpBtn i, #scrollDownBtn i {
                font-size: 18px;
                color: #ccc;
            }

        .settingsActions {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
        }

            .settingsActions button {
                background: rgb(84,168,158);
                border: none;
                color: #0b0e11;
                font-weight: 600;
                border-radius: 4px;
                padding: 8px 12px;
                cursor: pointer;
                transition: background 0.3s;
                min-width: 80px;
                text-align: center;
            }

                .settingsActions button:hover {
                    background: #5ad1c3;
                }

        #restoreDefaultsBtn {
            position: absolute;
            top: 12px;
            left: 12px;
            cursor: pointer;
        }

        /* ENHANCE PREVIEW OVERLAY */
        #enhancePreviewOverlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            backdrop-filter: blur(6px);
            z-index: 9999;
            justify-content: center;
            align-items: center;
        }

        #enhancePreviewBox {
            position: relative;
            width: 90vw;
            height: 90vh;
            max-width: 1920px;
            max-height: 1080px;
            background: rgba(255,255,255,0.05);
            border-radius: 6px;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #enhancePreviewImg {
            width: 100%;
            height: 100%;
            object-fit: contain;
            display: block;
        }

        #closeEnhancePreviewBtn {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 20px;
            color: #fff;
            background: rgba(0,0,0,0.3);
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.3s;
        }

            #closeEnhancePreviewBtn:hover {
                background: rgba(0,0,0,0.6);
            }

        #fullscreenEnhancePreviewBtn {
            position: absolute;
            top: 10px;
            right: 50px;
            font-size: 20px;
            color: #fff;
            background: rgba(0,0,0,0.3);
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.3s;
        }

            #fullscreenEnhancePreviewBtn:hover {
                background: rgba(0,0,0,0.6);
            }

        #downloadEnhancePreviewBtn {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
        }

        .hudScrollArea {
            /* limit height so it scrolls, not the entire box */
            max-height: 700px; /* let it shrink to content */
            overflow-y: auto;
            overflow-x: hidden; /* prevent horizontal scroll */
            margin: 0; /* make sure there’s no big margin that forces extra space */
            padding: 0; /* likewise, remove any large bottom padding */
            scrollbar-width: none; /* Firefox: hide scrollbar */
        }

            .hudScrollArea::-webkit-scrollbar {
                width: 0px;
                background: transparent;
            }

        .hudSection {
            border-radius: 6px;
            background: rgba(26,36,41,0.92); /* darker, deep “dashboard” look */
            border: 1.5px solid #23343a;
            border-radius: 13px;
            margin-bottom: 11px;
            box-shadow: 0 2px 18px 0 #19ffc222, 0 0 0 2px #21f2c915;
            position: relative;
        }

            .hudSection:not(:last-child) {
                margin-bottom: 3px;
            }

        .hudSectionBody {
            /* Put the separator line here so it is hidden when the body is hidden */
            border-top: 1px solid #555;
            padding: 10px 12px;
            display: block;
        }

        .hudInnerSeparator {
            width: 100%;
            border-top: 1px solid #555;
            margin: 8px 0;
        }

        .hudSectionBody.collapsed {
            display: none !important;
        }

        .kontextToggleSection .hudSectionBody {
            display: flex;
            justify-content: center;
            padding: 14px 12px 16px;
        }

        .kontextToggleRow {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 18px;
            width: 100%;
            max-width: 320px;
        }

        .kontextToggle {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
        }

        .kontextToggleLabel {
            font-size: 10px;
            font-weight: 600;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            color: #9fb8c9;
            text-align: center;
        }

        .kontextToggleBtn {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid #5fd5c6;
            background: transparent;
            box-shadow: none;
            cursor: pointer;
            position: relative;
            transition: border-color .18s ease, box-shadow .18s ease, background .18s ease, transform .18s ease;
        }

            .kontextToggleBtn::after {
                content: "";
                position: absolute;
                inset: 10px;
                border-radius: 50%;
                background: rgba(95, 213, 198, 0.25);
                opacity: 0;
                transition: opacity .18s ease, background .18s ease;
            }

            .kontextToggleBtn:hover {
                border-color: #89f3e5;
                box-shadow: 0 0 7px 1px rgba(47, 226, 189, 0.35);
            }

            .kontextToggleBtn.is-on {
                border-color: #2ae1ba;
                background: radial-gradient(circle at 50% 50%, rgba(42, 225, 186, 0.65) 0%, rgba(20, 130, 118, 0.85) 85%);
                box-shadow: 0 0 12px 3px rgba(35, 225, 182, 0.38), 0 0 3px rgba(35, 225, 182, 0.65);
            }

                .kontextToggleBtn.is-on::after {
                    opacity: 1;
                    background: rgba(5, 17, 21, 0.55);
                }

            .kontextToggleBtn:focus-visible {
                outline: none;
                box-shadow: 0 0 0 2px rgba(42, 225, 186, 0.45), 0 0 0 4px rgba(9, 40, 39, 0.55);
            }

        .hudSectionHeader {
            color: #fff;
            font-size: 16px;
            font-weight: 700;
            letter-spacing: .04em;
            padding: 7px 0 7px 28px;
            background: transparent;
            border-left: 4px solid transparent;
            border-radius: 7px 7px 0 0;
            box-shadow: none;
            transition: color 0.2s, box-shadow 0.21s, border-color 0.18s, background 0.18s;
            position: relative;
            z-index: 2;
        }

        .sectionResetBtn {
            position: absolute;
            top: 6px;
            left: 6px;
            color: #bbb;
            cursor: pointer;
            display: none;
            z-index: 3;
        }

            .sectionResetBtn:hover {
                color: #fff;
            }

        .hudSectionHeader.active {
            color: #e2eefd; /* Brighter white */
            border-left: 4px solid #22bfa7b0; /* Seafoam/teal edge for 3D, blue for Image, etc. */
            background: linear-gradient(90deg,#232d34 50%,#223b37 100%);
            box-shadow: 0 1px 6px 0 #22ffe210;
            font-weight: 800;
        }

            .hudSectionHeader.active::after {
                content: "";
                display: block;
                height: 2.5px;
                width: calc(100% - 4px);
                margin: 5px 0 0 2px;
                background: linear-gradient(90deg, #22ffe280 40%, #c9f8ff18 100%);
                border-radius: 2px;
                box-shadow: 0 1px 6px #22ffe210;
            }

            .hudSectionHeader.active .sectionFocusBtn {
                border-color: #44d4fa;
                opacity: .8;
            }

        /* Collapsed state => hidden body, so you see only the header */
        .hudSectionBody.collapsed {
            display: none;
            border-bottom: none;
        }

        /* Compact Material-style section headers */
        .materialHUD-compact .hudSectionHeader {
            font-size: 14px;
            font-weight: 600;
            padding: 6px 8px 6px 28px;
            border-left: none;
            background: none;
            box-shadow: none;
            margin-bottom: 4px;
        }

            .materialHUD-compact .hudSectionHeader.active {
                border-left: none;
                background: none;
                box-shadow: none;
            }

                .materialHUD-compact .hudSectionHeader.active::after {
                    display: none;
                }

        .hudTitleBar {
            /* keep your existing styles */
            font-size: 16px;
            font-weight: 600;
            color: #fff;
            padding: 8px;
            border-bottom: 1px solid #444;
            position: relative;
        }

        .hudCloseBtn {
            position: absolute;
            right: 12px;
            top: 0;
            font-size: 16px;
            color: #aaa;
            background: transparent;
            cursor: pointer;
            transition: color 0.2s;
        }

            .hudCloseBtn:hover {
                color: #fff;
            }

        #workflowImageHUD .hudScrollArea {
            max-height: 500px; /* or 400px, or 90vh, etc. */
            overflow-y: auto; /* still scroll if it truly gets too tall for the user’s screen */
            margin: 0;
            padding: 0;
            scrollbar-width: none;
        }

            #workflowImageHUD .hudScrollArea::-webkit-scrollbar {
                width: 0px;
                background: transparent;
            }

        /* WORKFLOW HUDS => “Image,” “3D,” “Video” */
        .workflowHUDBox {
            position: absolute;
            width: 360px;
            background: #1b1e23;
            /* keep your other styling */
            border: 1px solid #333;
            border-radius: 8px;
            /* We'll let the inner .hudScrollArea do the vertical scroll */
            display: flex;
            flex-direction: column;
            z-index: 1000;
            /* so that if the child is very tall, the corners remain rounded: */
            overflow: hidden; /* hides anything beyond border radius */
        }

        .workflowHUDBox,
        .promptHudMode {
            transition: left .2s cubic-bezier(), top .2s cubic-bezier(), /* 150 ms is fast but visible */
        }

            .workflowHUDBox select,
            .hudSectionBody select,
            .settingsSection select,
            #samModelSelectHud,
            #i2iModelSelect,
            #videoStyleSelectHud,
            #d2iModelSelect {
                background: #171b1e;
                color: #eee;
                border: 1.5px solid #34464d;
                border-radius: 6px;
                font-size: 14px;
                padding: 8px 36px 8px 13px;
                appearance: none;
                -webkit-appearance: none;
                -moz-appearance: none;
                outline: none;
                width: 100%;
                box-shadow: 0 1.5px 10px 0 #22ffe219;
                transition: border-color 0.17s, background 0.18s;
                position: relative;
                cursor: pointer;
                margin-bottom: 6px;
                /* Add the chevron (SVG background) */
                background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' width='13' height='7' viewBox='0 0 13 7' fill='none' stroke='%2323e1b6' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='2 2 6.5 5 11 2'/%3e%3c/svg%3e");
                background-repeat: no-repeat;
                background-position: right 11px center;
                background-size: 17px 10px;
            }

                .hudSectionBody select:focus,
                .settingsSection select:focus,
                .workflowHUDBox textarea:focus {
                    border-color: #2be0a5;
                    background: #181d20; /* <-- A dark background on focus */
                    color: #eee;
                    box-shadow: 0 0 0 2px #2be0a555;
                }

            .workflowHUDBox option,
            .hudSectionBody option,
            .settingsSection option {
                color: #eee !important; /* <-- Off-white text inside dropdown */
                background: #171b1e; /* Or a shade darker if you prefer */
            }

            input[type="text"],
            textarea,
            .workflowHUDBox input[type="text"],
            .workflowHUDBox input[type="number"],
            .workflowHUDBox textarea,
            .hudSectionBody input[type="text"],
            .hudSectionBody input[type="number"],
            .hudSectionBody textarea,
            #i2iPromptInput, #i2iNegativePromptInput,
            #d2iPromptInput, #d2iNegativePromptInput {
                background: #181d20 !important;
                color: #e0fff7;
                border: 1.5px solid #34464d;
                border-radius: 5px;
                font-size: 14px;
                padding: 9px 13px;
                outline: none;
                width: 100%;
                box-shadow: 0 0 0 1px #2be0a533;
                transition: border-color 0.14s, background 0.12s, box-shadow 0.15s;
                margin-bottom: 7px;
            }

                input[type="text"]:focus,
                textarea:focus,
                .workflowHUDBox input[type="text"]:focus,
                .workflowHUDBox textarea:focus {
                    background: #1a232b !important; /* <- darker, not white */
                    color: #eee;
                    border-color: #22ffd3;
                    box-shadow: 0 0 0 2.5px #22ffd345;
                }

                input[type="text"]::placeholder,
                textarea::placeholder {
                    color: #96bbb7;
                    opacity: 1;
                }

                .workflowHUDBox input[type="number"]:focus,
                .workflowHUDBox select:focus {
                    border-color: #a6ded0;
                    box-shadow: 0 0 0 2px #19ffd249;
                    color: #eee;
                    background: #192128;
                }

        .hudSectionBody label, .settingsSection label {
            color: #eee;
            font-size: 13px;
            font-weight: 400;
            margin-bottom: 2px;
            letter-spacing: .01em;
        }

        .workflowHUDBox input[type="text"]::placeholder,
        .workflowHUDBox textarea::placeholder {
            color: #889ba0;
            opacity: 1;
        }

        /* MUTED DARK PROMPT FIELD FIX */
        #i2iPromptInput, #i2iNegativePromptInput,
        #d2iPromptInput, #d2iNegativePromptInput,
        #homePromptInput, .workflowHUDBox input[type="text"], .workflowHUDBox textarea,
        .hudSectionBody input[type="text"], .hudSectionBody textarea,
        input[type="text"].darkInput, textarea.darkInput {
            background: #181d20 !important;
            color: #eee !important;
            border: 1.5px solid #34464d;
            border-radius: 6px;
            box-shadow: 0 0 0 1px #22ffd345;
            transition: border-color 0.15s, background 0.15s;
        }

            /* On focus, still muted, never white */
            #i2iPromptInput:focus, #i2iNegativePromptInput:focus,
            #d2iPromptInput:focus, #d2iNegativePromptInput:focus,
            #homePromptInput:focus, .workflowHUDBox input[type="text"]:focus, .workflowHUDBox textarea:focus,
            .hudSectionBody input[type="text"]:focus, .hudSectionBody textarea:focus,
            input[type="text"].darkInput:focus, textarea.darkInput:focus {
                background: #161b22 !important;
                color: #eee !important;
                border-color: #a6ded0;
                box-shadow: 0 0 0 2px #19ffd229;
            }

            /* Placeholder always muted */
            #i2iPromptInput::placeholder, #i2iNegativePromptInput::placeholder,
            #d2iPromptInput::placeholder, #d2iNegativePromptInput::placeholder,
            #homePromptInput::placeholder,
            .workflowHUDBox input[type="text"]::placeholder, .workflowHUDBox textarea::placeholder,
            .hudSectionBody input[type="text"]::placeholder, .hudSectionBody textarea::placeholder,
            input[type="text"].darkInput::placeholder, textarea.darkInput::placeholder {
                color: #91a6ae !important;
                opacity: 1;
            }

        #workflowMaterialHUD textarea {
            resize: vertical;
        }




        .workflowHUDBox input[type="range"] {
            -webkit-appearance: none;
            background: #666;
            height: 4px;
            border-radius: 2px;
            outline: none;
            cursor: pointer;
        }

            .workflowHUDBox input[type="range"]::-webkit-slider-thumb {
                -webkit-appearance: none;
                width: 14px;
                height: 14px;
                background: rgb(43,224,165);
                border-radius: 50%;
                border: 2px solid #999;
            }

        .notched-slider {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 6px 0 0 0;
            height: 26px;
            position: relative;
            padding: 0 10px;
        }

            .notched-slider .notch {
                width: 15px;
                height: 15px;
                background: #20262b;
                border: 2px solid #aee5db;
                border-radius: 50%;
                cursor: pointer;
                transition: background 0.17s, border 0.17s;
                position: relative;
            }

                .notched-slider .notch.selected,
                .notched-slider .notch:hover {
                    background: #24f2b1;
                    border-color: #3ae99c;
                }

                .notched-slider .notch:after {
                    content: attr(data-tip);
                    position: absolute;
                    top: 22px;
                    left: 50%;
                    transform: translateX(-50%);
                    font-size: 11px;
                    color: #aaffef;
                    background: #1d2327;
                    padding: 1px 8px;
                    border-radius: 5px;
                    opacity: 0;
                    pointer-events: none;
                    white-space: nowrap;
                    transition: opacity .15s;
                    z-index: 10;
                }

                .notched-slider .notch:hover:after {
                    opacity: 1;
                }

        .stealthSliderWrapper {
            display: flex;
            align-items: center;
            gap: 7px;
            margin-bottom: 8px;
            width: 100%;
        }

        .stealthSliderLabel {
            font-size: 13px;
            color: #b9c6ca;
            min-width: 68px;
            font-weight: 500;
        }

        .stealthSliderValue {
            font-size: 13px;
            color: #98ffe3;
            background: #1b2227;
            border-radius: 6px;
            padding: 2px 8px;
            min-width: 36px;
            text-align: right;
            font-family: inherit;
        }

        input[type=range].stealthSlider {
            -webkit-appearance: none;
            width: 100%;
            height: 7px;
            /*            background: #23292d;*/
            border-radius: 7px;
            outline: none;
            box-shadow: 0 1.2px 4px 0 #19ffd21a;
            transition: background .13s;
            margin-top: 0;
            margin-bottom: 0;
            position: relative;
        }

            /* Track - Chrome/Edge/Safari */
            input[type=range].stealthSlider::-webkit-slider-runnable-track {
                height: 7px;
                border-radius: 7px;
                /*                background: #23292d;*/
                margin-top: 0;
            }

            /* Thumb - Chrome/Edge/Safari */
            input[type=range].stealthSlider::-webkit-slider-thumb {
                -webkit-appearance: none;
                width: 16px;
                height: 16px;
                margin-top: -4.5px; /* Half of (thumb height - track height) for centering */
                border-radius: 50%;
                background: #23ffe2;
                border: 2px solid #16332d;
                box-shadow: 0 2px 8px #18d4b355;
                cursor: pointer;
                transition: background .15s, box-shadow .13s;
            }

            input[type=range].stealthSlider:focus::-webkit-slider-thumb,
            input[type=range].stealthSlider:hover::-webkit-slider-thumb {
                background: #e6fffa;
                box-shadow: 0 0 0 2.5px #16bfa744, 0 3px 7px #13ffcf2a;
            }

            /* Firefox */
            input[type=range].stealthSlider::-moz-range-thumb {
                width: 16px;
                height: 16px;
                border-radius: 50%;
                background: #23ffe2;
                border: 2px solid #16332d;
                box-shadow: 0 2px 8px #18d4b355;
                cursor: pointer;
            }

            input[type=range].stealthSlider:focus::-moz-range-thumb,
            input[type=range].stealthSlider:hover::-moz-range-thumb {
                background: #e6fffa;
                box-shadow: 0 0 0 2.5px #16bfa744, 0 3px 7px #13ffcf2a;
            }

            input[type=range].stealthSlider::-moz-range-track {
                height: 7px;
                border-radius: 7px;
                background: linear-gradient(90deg, #16bfa7 0%, #23292d 100%);
            }

            /* Remove the inner shadow in Firefox */
            input[type=range].stealthSlider::-ms-fill-lower {
                background: #16bfa7;
                border-radius: 7px;
            }

            input[type=range].stealthSlider::-ms-fill-upper {
                background: #23292d;
                border-radius: 7px;
            }

            input[type=range].stealthSlider:focus {
                outline: none;
                box-shadow: 0 0 0 2px #13ffd229;
            }

            /* Remove Firefox focus border */
            input[type=range].stealthSlider::-moz-focus-outer {
                border: 0;
            }


        .seedLockContainer {
            display: inline-flex; /* or inline-block if you prefer */
            align-items: center;
            gap: 8px;
        }

        /* Hidden checkbox: zero size, no opacity */
        .lockSeedCheckbox {
            position: absolute; /* absolutely remove from normal flow */
            opacity: 0;
            width: 0;
            height: 0;
            pointer-events: none; /* so clicks go to label instead */
        }

        /* The circle that we click. We'll rely on :checked state from .lockSeedCheckbox */
        .lockSeedCircle {
            width: 18px;
            height: 18px;
            border: 2px solid rgba(116,116,128,0.8); /* a subtle gray border or your seafoam style */
            border-radius: 50%;
            background: transparent;
            cursor: pointer;
            transition: background 0.3s;
            display: inline-block;
            /* optional: if you want it exactly like .sectionFocusBtn, do that styling here */
        }

        .lockSeedLabel {
            font-size: 14px;
            color: #bbb; /* or #ccc, #eee, etc. */
            cursor: pointer; /* so user sees clickable text */
        }

        /* When the hidden checkbox is checked => fill the circle with your seafoam color */
        .lockSeedCheckbox:checked + .lockSeedCircle {
            background: rgba(43,224,165,0.9);
            border-color: rgba(116,116,128,0.8);
        }

        /* For the numeric input, just reuse your existing dark styling */
        .darkInput.seedInput {
            background: #1b2227;
            border: 1.2px solid #22ffe2;
            border-radius: 6px;
            color: #f1f4f7;
            font-size: 14px;
            width: 60px; /* narrower input for seed # */
            /* You likely already have .darkInput { background: #1f1f1f; color: #fff; ... } */
            /* If you want a border that matches your theme: */
            padding: 4px 9px;
            margin-left: 8px;
            outline: none;
            box-shadow: 0 0 7px #21ffe219;
            transition: border-color 0.18s;
        }

        .lockSeedInput:focus {
            border-color: #44e7e4;
            background: #13222c;
        }

        .darkInput.seedInput:disabled {
            background-color: #2f2f2f; /* or something clearly “inactive” */
            color: #777;
            border-color: #555;
            cursor: not-allowed;
        }

        #sequencerHudContainer {
            position: fixed;
            left: 50%;
            bottom: 80px;
            transform: translateX(-50%);
            z-index: 12001;
            width: auto;
            min-width: 540px;
            max-width: 96vw;
            pointer-events: none; /* enabled on open */
        }

        .sequencerHudBar {
            background: rgba(22,28,34,0.45);
            box-shadow: 0 3px 20px 0 #1119, 0 0 0 1.5px #313233;
            border-radius: 8px;
            border: 1.3px solid #343d42;
            padding: 9px 18px 9px 14px;
            display: flex;
            align-items: center;
            gap: 14px;
            min-height: 78px;
            max-width: 1180px;
            overflow-x: auto;
            pointer-events: auto;
            position: relative;
        }

        .sequencerHudBar,
        .sequencerThumbs {
            overflow-x: visible !important;
        }


        .sequencerHudBar {
            cursor: grab;
        }

            .sequencerHudBar.dragging {
                cursor: grabbing;
                opacity: 0.97;
            }

        .sequencerHudTitle {
            font-weight: 600;
            color: #eee;
            font-size: 21px;
            margin-right: 13px;
            display: flex;
            align-items: center;
            gap: 7px;
        }

        .sequencerHudCloseBtn {
            position: absolute;
            top: 10px;
            right: 15px;
            background: none;
            border: none;
            color: #aaa;
            font-size: 1.25em;
            cursor: pointer;
            z-index: 12;
            border-radius: 12px;
            padding: 4px 12px;
            opacity: 0.82;
            transition: background 0.13s, color 0.13s;
        }

            .sequencerHudCloseBtn:hover {
                background: #fae0e0;
                color: #a50c0c;
            }

        .sequencerThumbs {
            display: flex;
            gap: 19px !important;
            flex: 1;
            align-items: center;
            overflow-x: auto;
            min-height: 125px !important;
            padding: 2px 0;
        }

        .sequencerThumb {
            border-radius: 9px;
            background: rgba(120,255,220,0.09);
            box-shadow: 0 0 7px 0 #00ffd355;
            border: 2px solid transparent;
            transition: border 0.14s, box-shadow 0.17s, transform 0.13s;
            min-width: 90px !important;
            width: 120px !important;
            height: 100px !important;
            max-width: 110px !important;
            margin: 0 2px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: grab;
            position: relative;
            overflow: hidden;
        }

            .sequencerThumb.selected,
            .sequencerThumb:hover {
                border: 2px solid #3fffd1;
                box-shadow: 0 0 0 4px #00ffd342;
                transform: scale(1.08);
            }

            .sequencerThumb img {
                width: 100%;
                height: 100%;
                object-fit: contain;
                display: block;
            }

            .sequencerThumb .thumbDeleteBtn {
                position: absolute;
                top: 4px;
                right: 5px;
                background: #fae0e0ee;
                color: #a60c2a;
                border: none;
                border-radius: 7px;
                font-size: 13px;
                padding: 0 5px;
                cursor: pointer;
                opacity: 0.82;
                transition: background 0.13s, color 0.13s;
            }

                .sequencerThumb .thumbDeleteBtn:hover {
                    background: #ff3355;
                    color: #fff;
                }

            .sequencerThumb.dragging,
            .sequencerThumb.dragging.selected,
            .sequencerThumb.dragging:hover {
                transform: none !important;
                z-index: 100;
            }

            .sequencerThumb.not-dragged-thumb {
                opacity: 1 !important;
            }


        @keyframes outlinePulse {
            0% {
                outline-color: rgba(43,224,165, 0.3);
            }

            100% {
                outline-color: rgba(43,224,165, 0.9);
            }
        }

        @keyframes pulse {
            0%, 100% {
                box-shadow: 0 0 5px rgba(43,224,165,0.7), 0 0 8px rgba(43,224,165,0.6);
            }

            50% {
                box-shadow: 0 0 20px rgba(43,224,165,0.9), 0 0 20px rgba(43,224,165,0.8);
            }
        }

        .pulsingBtn {
            animation: pulse 1.6s ease-in-out infinite;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 6px rgba(43,224,165,0.3);
            }

            100% {
                box-shadow: 0 0 14px rgba(43,224,165,0.8);
            }
        }

        .stickerGlow {
            outline: 3px solid rgba(43,224,165,0.85);
            box-shadow: 0 0 10px 3px rgba(43,224,165,0.4);
            border-radius: 2px;
            animation: pulse 1.6s infinite;
        }

        @keyframes canvasPulseOnce {
            0% {
                box-shadow: 0 0 6px rgba(43,224,165,0.7);
            }

            50% {
                box-shadow: 0 0 16px rgba(43,224,165,2.0);
            }

            100% {
                box-shadow: 0 0 0px rgba(43,224,165,0.0);
            }
        }

        .canvasPulseOnce {
            animation: canvasPulseOnce 2.0s ease-out 1;
        }

        .sliderCompare {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 1000;
        }

        .sliderTrack {
            position: relative;
            width: 100%;
            height: 100%;
            pointer-events: auto;
        }

            .sliderTrack img {
                position: absolute;
                top: 0;
                height: 100%;
                object-fit: contain;
            }

        #imgBefore {
            left: 0;
            width: 100%;
            clip-path: inset(0 50% 0 0);
        }

        #imgAfter {
            left: 0;
            width: 100%;
        }

        #sliderHandle {
            position: absolute;
            top: 0;
            left: 50%;
            width: 4px;
            height: 100%;
            background: rgba(43,224,165,0.85);
            cursor: ew-resize;
            z-index: 10;
        }

        .hidden {
            display: none;
        }

        .stickerDom {
            position: absolute;
            pointer-events: none;
            z-index: 500;
        }

        #sticker-3d-focusBtn {
            position: absolute;
            top: 50px;
            left: 140px;
            width: 11px;
            height: 11px;
            border: 1px solid #7ffcd5;
            border-radius: 50%;
            background: rgba(170,170,170,.60);
            cursor: pointer;
            opacity: 1;
            z-index: 1005;
            display: none;
        }

            #sticker-3d-focusBtn.active {
                background: #24f2b1;
                border-color: #30363c;
            }

        .stFocusBtn {
            position: absolute; /* we glue it in JS               */
            width: 11px;
            height: 11px;
            border: 1px solid #7ffcd5; /* outline ring                    */
            border-radius: 50%;
            background: rgba(170,170,170,.60); /* light fill                       */
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background .15s,border-color .15s,opacity .15s;
            opacity: 0; /* hidden until JS shows it        */
        }

            .stFocusBtn.active { /* sea-foam ON-state               */
                background: #24f2b1;
                border-color: #30363c;
            }


        /* tooltip that fades in under every .stModeBtn on hover */
        .stModeBtn::after {
            content: attr(data-tip);
            position: absolute;
            bottom: -26px;
            left: 50%;
            transform: translateX(-50%);
            font: 11px/1.2 "Inter", sans-serif;
            white-space: nowrap;
            background: rgba(0,0,0,0.85);
            color: #fff;
            padding: 2px 6px;
            border-radius: 4px;
            opacity: 0;
            pointer-events: none;
            transition: opacity .15s;
        }


        canvas.swapMode {
            outline: 2px dashed #7fdaff;
        }

        .canvasTooltip {
            position: fixed;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            font: 11px/1.2 "Inter", sans-serif;
            padding: 4px 8px;
            border-radius: 4px;
            white-space: nowrap;
            z-index: 99999;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.1s;
        }

            .canvasTooltip.visible {
                opacity: 1;
            }

        .stickerSwapReady {
            outline: 2px dashed #7fdaff;
            cursor: pointer;
        }

        .stScaleGui {
            position: absolute;
            display: none;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            gap: 6px;
            background: rgba(0, 0, 0, 0.65);
            padding: 4px 6px;
            border-radius: 6px;
            z-index: 1003;
        }

            .stScaleGui div {
                width: 24px;
                height: 24px;
                display: flex;
                align-items: center;
                justify-content: center;
                background: #30363c;
                color: #fff;
                border-radius: 50%;
                cursor: pointer;
                transition: background .15s;
            }

                .stScaleGui div:hover {
                    background: #2be0a5;
                    color: #0b0e11;
                }

        #sticker-3d-view {
            position: absolute;
            top: 100px;
            left: 100px;
            width: 100px;
            height: 100px;
            z-index: 1000;
            pointer-events: auto;
            overflow: visible; /* ADD THIS */
        }

            #sticker-3d-view:active {
                cursor: grabbing;
            }

        #sticker-3d-outline {
            position: absolute;
            transition: opacity .25s;
            opacity: 0; /* hidden until the glb is “active”   */
            box-sizing: border-box;
            z-index: 1002;
            border: 2px solid #24f2b1; /* solid seafoam outline */
            pointer-events: auto;
            overflow: visible;
            cursor: grab;
        }

            #sticker-3d-outline .glb-action-trigger {
                position: absolute;
                bottom: -12px;
                left: 50%;
                transform: translateX(-50%);
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                gap: 3px;
                width: 24px;
                height: 14px;
                cursor: pointer;
                opacity: 0;
                transition: opacity .2s;
                pointer-events: none;
            }

                #sticker-3d-outline .glb-action-trigger span {
                    width: 20px;
                    height: 3px;
                    background: #232c29;
                }

                #sticker-3d-outline .glb-action-trigger:hover span {
                    background: #2be0a5;
                }

        .glb-handle {
            position: absolute;
            width: 20px;
            height: 20px;
            background: #549dd1; /* base blue */
            border: 1.2px solid #e1f0fd; /* off-white ring */
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: nwse-resize;
            z-index: 1004;
            box-shadow: 0 0 3px #22aaff;
            transition: background .15s, box-shadow .15s;
        }

            .glb-handle:hover {
                background: #6dc2ed; /* brighter blue on hover */
                box-shadow: 0 0 9px #22aaff;
            }

            .glb-handle.dragging {
                background: #22ffd3; /* seafoam when dragging */
                box-shadow: 0 0 9px #2be0a5;
            }

        #sticker-3d-outline i {
            pointer-events: none;
            color: transparent;
            -webkit-text-stroke: 3px #2be0a5;
            line-height: 1;
            opacity: 0; /* hide diagonal icon by default */
            transition: opacity .15s;
        }

        .glb-handle:hover i,
        .glb-handle.dragging i {
            opacity: 1; /* show icon on hover or drag */
        }

        .glb-handle-nw {
            top: -10px;
            left: -10px;
            cursor: nwse-resize;
        }

        .glb-handle-ne {
            top: -10px;
            right: -10px;
            cursor: nesw-resize;
            transform: rotate(90deg);
        }

        .glb-handle-sw {
            bottom: -10px;
            left: -10px;
            cursor: nesw-resize;
            transform: rotate(270deg);
        }

        .glb-handle-se {
            bottom: -10px;
            right: -10px;
            cursor: nwse-resize;
        }

        .glb-flip {
            position: absolute;
            top: 50%;
            width: 24px;
            height: 24px;
            background: #30363c;
            color: #fff;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transform: translateY(-50%);
            cursor: pointer;
            z-index: 1004;
            transition: background .15s, color .15s, opacity .15s;
            opacity: 0; /* hidden until hover reveal */
            pointer-events: none;
        }

            .glb-flip:hover {
                background: #2be0a5;
                color: #0b0e11;
            }

        .glb-flip-left {
            left: -12px;
        }

        .glb-flip-right {
            right: -12px;
        }



        /* hover glow */
        #sticker-3d-outline.hovering {
            box-shadow: 0 0 10px 3px rgba(43,224,165,.7);
        }

        .sliderRow {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

            .sliderRow.compactRow {
                margin-bottom: 4px;
            }

        .sliderValue {
            font-size: 12px;
            color: #ccc;
            background: #222;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 2px 6px;
        }

        .sliderRow label {
            width: 60px;
            font-size: 13px;
            color: #bbb;
            text-align: left;
        }

        .darkBtn {
            background: #34464d;
            color: #ddd;
            border: 1px solid #444;
            border-radius: 5px;
            padding: 6px 10px;
            font-size: 15px;
            transition: background 0.2s, color 0.2s;
        }

            .darkBtn:hover {
                background: rgba(43,224,165,0.25);
                color: #fff;
                cursor: pointer;
            }

        .generator3dBtn {
            background: linear-gradient(110deg,#1d2329 65%,#1c292b 100%);
            color: #c5fbe6;
            border: 1.3px solid #66b8cc;
            border-radius: 7px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 9px;
            font-weight: 500;
            font-size: 15px;
            padding: 13px 16px 13px 14px;
            width: 49%; /* makes two buttons fit side by side */
            transition: background .18s, border .16s, color .16s, box-shadow .14s;
            box-shadow: 0 2px 16px 0 #1afcbe16;
            cursor: pointer;
        }

            .generator3dBtn i {
                font-size: 1.18em;
                color: #48ffe2;
                margin-right: 3px;
            }

            .generator3dBtn:hover,
            .generator3dBtn:focus {
                background: linear-gradient(110deg, #195b4b 10%, #27393c 100%);
                color: #f1f4f7; /* ← off-white for high contrast */
                border-color: #16bfa780;
                box-shadow: 0 0 0 2px #16bfa755;
                /* Deeper, less neon, still visible seafoam */
            }

                .generator3dBtn:hover i,
                .generator3dBtn:focus i {
                    color: #f1f4f7; /* icon becomes off-white on hover */
                }

            .generator3dBtn:active {
                background: #14786b;
                color: #f8fafd;
                border-color: #13b2d9;
            }

                .generator3dBtn:active i {
                    color: #f8fafd;
                }

        .generatorImgBtn {
            background: linear-gradient(110deg,#1d2329 65%,#1c292b 100%);
            color: #c5fbe6;
            border: 1.2px solid #a6ded050;
            border-radius: 7px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 7px;
            font-weight: 600;
            font-size: 14px;
            padding: 9px 10px 9px 10px;
            min-width: 0;
            min-height: 0;
            transition: background .18s, border .16s, color .16s, box-shadow .14s;
            box-shadow: 0 1.5px 8px 0 #1afcbe12;
            cursor: pointer;
            width: 100%;
        }

            .generatorImgBtn i {
                font-size: 1.1em;
                color: #48ffe2;
                margin-right: 2px;
            }

            .generatorImgBtn:hover,
            .generatorImgBtn:focus {
                background: linear-gradient(110deg, #265247 10%, #27393c 100%);
                color: #f1f4f7;
                border-color: #1f8199;
                box-shadow: 0 0 0 1px #36f0fa66;
            }

                .generatorImgBtn:hover i,
                .generatorImgBtn:focus i {
                    color: #f1f4f7;
                }

            .generatorImgBtn:active {
                background: #14786b;
                color: #f8fafd;
                border-color: #13b2d9;
            }

                .generatorImgBtn:active i {
                    color: #f8fafd;
                }

        /* Sleek ghost-style secondary buttons for Workflow HUD */
        .workflowGhostBtn {
            background: rgba(36,44,54,0.44);
            color: #bde7e4;
            border: 1.2px solid #34464d;
            border-radius: 7px;
            font-weight: 500;
            font-size: 15px;
            padding: 8px 0 8px 0;
            width: 100%;
            margin: 0;
            box-sizing: border-box;
            box-shadow: 0 1.5px 8px 0 #17f0c219;
            cursor: pointer;
            outline: none;
            transition: background .17s, color .17s, border-color .14s;
            letter-spacing: .02em;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

            .workflowGhostBtn:hover,
            .workflowGhostBtn:focus {
                background: linear-gradient(120deg,#212c33 75%, #173632 100%);
                color: #f2f6fa;
                border-color: #14b39a80;
                box-shadow: 0 0 0 1.2px #22ffe21a;
            }

            .workflowGhostBtn:active {
                background: #172027;
                color: #f2f6fa;
                border-color: #14ad8a;
            }

        .launchIcon {
            /*position: absolute;*/
            margin-left: 10px; /* Just a little gap from the text */
            font-size: 16px;
            color: #eee;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            transition: background 0.2s, color 0.2s;
        }

            .launchIcon:hover {
                background: rgba(43,224,165,0.2);
                color: rgb(43,224,165);
            }

        .workflowSection button, .workflowSection i.launchIcon {
            background: #282c2f;
            color: #ccc;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 6px 8px;
            cursor: pointer;
            transition: background 0.2s, color 0.2s;
            font-size: 14px;
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

            .workflowSection button:hover,
            .workflowSection i.launchIcon:hover {
                background: rgba(43,224,165,0.2);
                color: #fff;
            }

        .workflowSection h3 {
            margin: 0;
            font-size: 15px;
            color: rgb(30,170,145);
        }

        /* Hidden file inputs for BG/FG */
        label[for="bgInput"],
        label[for="fgImageInput"],
        label[for="fgAssetInput"],
        label[for="fgFlipBookBtn"] {
            width: 0;
            height: 0;
            opacity: 0;
        }

        /*— Prompt‑HUD close button —*/
        #promptCloseBtn {
            position: absolute;
            top: 6px;
            right: 8px;
            font-size: 20px;
            color: #aaa;
            cursor: pointer;
            opacity: 0;
            transition: opacity .20s;
        }

        #homePromptInner:hover #promptCloseBtn {
            opacity: 1;
        }

        #promptCloseBtn:hover {
            color: #fff;
        }

        /*— Toggle icon that lives half‑way down right edge —*/
        #promptParamToggle {
            position: absolute;
            right: -18px;
            top: 50%;
            transform: translateY(-50%);
            width: 26px;
            height: 26px;
            border: 2px solid #cdcdcd;
            border-radius: 50%;
            background: #cfd5d5;
            color: #111;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: background .25s;
        }

            #promptParamToggle:hover {
                background: #2c8567;
                color: #fff;
            }

        /*— Slide‑out drawer (hidden by default) —*/
        #promptParamDrawer {
            position: absolute;
            left: 100%; /* ⬅ origin sits flush to inner box */
            top: 10px;
            width: 155px;
            min-height: 180px;
            background: rgba(20,25,30,0.3);
            border: 0.5px solid #333;
            border-radius: 6px;
            box-shadow: 0 4px 16px rgba(0,0,0,.40);
            display: flex;
            flex-direction: column;
            gap: 12px;
            padding: 20px;
            opacity: 0;
            pointer-events: none;
            transition: linear .25s, opacity .25s;
            transform: translateZ(calc(100% + 12px));
            z-index: 6;
        }

            #promptParamDrawer.open {
                transform: translateX(18px);
                right: -5px;
                opacity: 1;
                pointer-events: auto;
            }

        #promptParamToggle {
            display: none;
        }

        /*— each param row —*/
        .paramRow {
            display: flex;
            align-items: center;
            gap: 15px;
        }

            .paramRow i {
                font-size: 16px;
                color: #ccc;
                cursor: default;
            }

        /*— number scrubbable input —*/
        .paramInput {
            width: 60px;
            background: #0f1317;
            border: 1px solid #444;
            color: #eee;
            border-radius: 4px;
            padding: 4px 4px;
            text-align: center;
            cursor: ns-resize;
        }

        .paramRow i:hover::after,
        .seedRow:hover::after { /* seed toggle shares the class below */
            composes: drawerTip;
            content: attr(data-tip);
            pointer-events: none;
            position: absolute;
            left: calc(100% + 8px); /* pop to the right of the drawer */
            top: 50%;
            transform: translateY(-50%);
            background: #000;
            color: #fff;
            font-family: 'Inter', system-ui, sans-serif; /* ← new font */
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 4px;
            white-space: nowrap;
            z-index: 50;
        }

        .paramRow .paramInput {
            margin-left: 0;
        }

        .disabledParam {
            opacity: .35; /* visually dim */
        }

            .disabledParam .paramInput {
                pointer-events: none; /* no interaction */
            }

        .drawerTip,
        .paramRow i:hover::after,
        .seedRow:hover::after {
            position: absolute;
            left: calc(100% + 8px);
            top: 50%;
            transform: translateY(-50%);
            background: #000;
            color: #fff;
            font-family: 'Inter', system-ui, sans-serif; /* match HUD headline */
            font-size: 13px;
            font-weight: 600;
            padding: 2px 6px;
            border-radius: 4px;
            white-space: nowrap;
            pointer-events: none;
            z-index: 50;
        }

        .processing {
            opacity: 0.6; /* dims button */
            pointer-events: none; /* blocks double‑clicks */
            position: relative;
        }

            .processing::after { /* little inline spinner */
                content: "";
                position: absolute;
                top: 40%;
                left: 26%;
                /*                transform: translate(-50%, -50%);*/
                width: 18px;
                height: 18px;
                margin-top: -7px;
                border: 2px solid rgba(255,255,255,0.4);
                border-left-color: rgb(43,224,165);
                border-radius: 50%;
                animation: spin 0.8s linear infinite;
            }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        #videoPromptHud {
            width: 100%;
            height: 35px;
        }

        #relightPrompt {
            position: absolute;
            z-index: 10001;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(16,20,24, 0.16); /* Subtle, not opaque */
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
        }

        .relightPromptBox.mini {
            position: relative; /* <-- ADD THIS LINE */
            background: #171d20ea;
            border-radius: 13px;
            box-shadow: 0 1px 8px 0 rgba(32,222,168,0.10), 0 0 0 1px #19d9b330;
            padding: 1.1rem 1.2rem 1.05rem 1.2rem;
            min-width: 228px;
            max-width: 92vw;
            display: flex;
            flex-direction: column;
            align-items: center;
            color: #e2f7ef;
        }

        .relightPromptTitle.mini {
            font-size: 1.10rem;
            font-weight: 700;
            color: #40d8b6c8;
            margin-bottom: 0.5em;
            letter-spacing: 0.02em;
        }

        .relightPromptDesc.mini {
            font-size: 0.97rem;
            font-weight: 450;
            color: #a7e5db;
            margin-bottom: 0.9em;
            text-align: center;
            opacity: 0.83;
        }

        .relightPromptBtnRow {
            display: flex;
            gap: 0.8em;
            justify-content: center;
            width: 100%;
            margin-top: 0.1em;
        }

        .relightPromptBtn {
            border: none;
            border-radius: 0.7em;
            padding: 0.44em 1.1em;
            font-size: 0.99rem;
            font-weight: 500;
            cursor: pointer;
            background: #1c2325;
            color: #a6ded0;
            border: 1.1px solid #27635b30;
            box-shadow: none;
            transition: background 0.14s, color 0.13s, border 0.13s, box-shadow 0.12s;
            outline: none;
        }

            .relightPromptBtn:hover, .relightPromptBtn:focus {
                background: #20282c;
                color: #eafff5;
                border: 1.1px solid #21b99d;
            }

        .relightPromptCloseBtn {
            position: absolute;
            top: 0.7em;
            right: 0.9em;
            font-size: 1.39em;
            color: #2fffd0cc;
            cursor: pointer;
            z-index: 14;
            background: none;
            border: none;
            padding: 0;
            line-height: 1;
            opacity: 0.68;
            transition: color 0.13s, opacity 0.13s;
        }

            .relightPromptCloseBtn:hover {
                color: #fff3b1;
                opacity: 0.95;
            }

        .relightPromptBox.mini {
            position: relative; /* Ensure absolute positioning of close btn is relative to prompt box */
        }


        .miniSeafoamBtn,
        .miniNeutralBtn {
            background: #1c2325;
            color: #a6ded0;
            border: 1.1px solid #27635b30;
            box-shadow: none;
            transition: color 0.14s, text-shadow 0.14s, background 0.14s, border 0.14s;
        }

            .miniSeafoamBtn:hover,
            .miniSeafoamBtn:focus {
                color: #96ffe5;
                text-shadow: 0 0 7px #36ffd5cc, 0 0 2.5px #29efc6a0;
                border: 1.1px solid #2ee3c1;
                background: #232c2c;
            }

            .miniNeutralBtn:hover,
            .miniNeutralBtn:focus {
                background: #20282c;
                color: #dcfff3;
                border: 1.1px solid #21b99d;
                text-shadow: none;
            }

        #matTypes .miniSeafoamBtn {
            min-width: 36px;
            min-height: 36px;
            font-size: 1.35em;
            border-radius: 50%;
            padding: 0;
            margin: 0 2px;
            background: #181c1d;
            color: #3fffd1;
            border: 1.5px solid #24e0b9;
        }

            #matTypes .miniSeafoamBtn.seafoam30Active {
                background: #25ffd1;
                color: #262b2e;
                border-color: #17ffd3;
            }


        #matHue { /* Chrome/Edge rotate trick already in inline style */
            background: linear-gradient(to right, red 0%, #ff0 17%, lime 33%, aqua 50%, blue 67%, magenta 83%, red 100%);
            border-radius: 7px;
        }

        .sliderLabel {
            font-size: 12px;
            margin-top: 4px;
            color: #bde7e4
        }

        .seedLockCircle {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 2px solid #ccc;
            cursor: pointer;
        }

        .seedLockCheckbox:checked + .seedLockCircle {
            background: #65c7ad;
            border-color: #65c7ad;
        }

        /* ────────────── Material-HUD NEW────────────── */


        .matRow.hueRow {
            flex-direction: column;
            align-items: center;
        }

            .matRow.hueRow > label {
                display: block;
                width: 100%;
                text-align: center;
                margin-bottom: 6px; /* spacing before swatches */
                font-weight: 500; /* match other section labels */
            }

        /* Make all 12 swatches one tight row */
        #matHueStrip {
            display: grid;
            grid-template-columns: repeat(12, 20px);
            gap: 4px;
            justify-content: center;
            margin-top: 6px;
        }

            /* Square-ish bevel swatches, still clickable */
            #matHueStrip .sw {
                width: 20px;
                height: 20px;
                border-radius: 4px;
                margin: 0;
            }

                /* keep your selected ring */
                #matHueStrip .sw.active {
                    outline: 2px solid #5cb3ff;
                }

        /* Centered rows + labels */
        .matRow {
            margin: 8px 0;
        }

        .matRow-centered {
            text-align: center;
        }


        /* Match the Image Workflow HUD look (drop the heavy 'Impact' vibe) */
        .matRowLabel {
            font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            font-weight: 700;
            letter-spacing: .2px;
            color: var(--hudLabelColor, #cfeff1);
            margin: 0;
        }

        /* Section heads */
        .matSection {
            border-radius: 10px;
            padding: 10px 12px;
        }

        .matSectionHead {
            display: flex;
            justify-content: center;
            margin-bottom: 6px;
        }

        /* Range rows + labels */
        .rangeRow {
            display: flex;
            align-items: center;
            gap: 10px;
        }

            .rangeRow input[type="range"] {
                flex: 1;
            }

        .rangeSideLabel {
            width: 70px;
            text-align: center;
            opacity: .8;
            font-size: .95rem;
        }

        .rangeValue {
            text-align: center;
            margin-top: 6px;
            font-variant-numeric: tabular-nums;
            opacity: .9;
        }

        /* Steps & Seed rows align cleanly and use full width */
        .stepsRow, .seedRow {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 12px;
        }

        .inlineLabel {
            width: 60px;
            text-align: left;
            opacity: .85;
        }

        .stepsRow input[type="range"] {
            flex: 1;
        }

        #matStepsValue {
            width: 40px;
            text-align: center;
        }

        .seedRow .iconBtn {
            width: 36px;
            height: 36px;
            border-radius: 8px;
            border: 1px solid rgba(120,220,200,.2);
            background: rgba(10,20,24,.55);
            line-height: 36px;
            text-align: center;
            cursor: pointer;
        }

            .seedRow .iconBtn.locked {
                outline: 2px solid var(--teal,#27e4b4);
            }

        .seedSelect {
            flex: 1;
            height: 36px;
            border-radius: 8px;
            padding: 0 10px;
        }

        /* Custom seed dropdown with hoverable check button */
        .seedDropdown {
            position: relative;
            flex: 1;
        }

            .seedDropdown .seedDisplay {
                height: 36px;
                border-radius: 8px;
                border: 1px solid rgba(120,220,200,.2);
                background: rgba(10,20,24,.55);
                padding: 0 10px;
                line-height: 36px;
                cursor: pointer;
            }

            .seedDropdown .seedList {
                display: none;
                position: absolute;
                top: 100%;
                left: 0;
                width: 100%;
                max-height: 160px;
                overflow-y: auto;
                scrollbar-width: none; /* hide scrollbar in Firefox */
                -ms-overflow-style: none; /* hide scrollbar in IE/Edge */
                background: #0f1317;
                border: 1px solid #444;
                border-radius: 6px;
                z-index: 100;
            }

                .seedDropdown .seedList::-webkit-scrollbar {
                    display: none; /* hide scrollbar in Chrome/Safari */
                }

            .seedDropdown.open .seedList {
                display: block;
            }

            .seedDropdown .seedList li {
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 4px 8px;
                cursor: pointer;
            }

                .seedDropdown .seedList li:hover {
                    background: rgba(255,255,255,0.07);
                }

                .seedDropdown .seedList li button {
                    display: none;
                    border: none;
                    background: transparent;
                    color: #0f0;
                    cursor: pointer;
                    font-size: 14px;
                }

                .seedDropdown .seedList li:hover button {
                    display: inline;
                }

                .seedDropdown .seedList li.pinned button {
                    display: inline;
                }

        /* Centered sub-headers inside Material Quality */
        .qualityBlock .qualityLabel {
            font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            font-weight: 500;
            letter-spacing: .2px;
            color: var(--hudLabelColor, #cfeff1);
            text-align: center;
            margin-bottom: 8px;
        }

        /* Row alignment stays the same */
        .rangeRow {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .rangeSideLabel {
            width: 70px;
            text-align: center;
            opacity: .8;
            font-size: .85rem;
        }

        .rangeValue {
            text-align: center;
            margin-top: 6px;
            font-variant-numeric: tabular-nums;
            opacity: .9;
        }


        /*        .matRowLabel {
            font-size: 12px;
            letter-spacing: .08em;
            color: #bcd;
            margin-bottom: 6px;
            text-transform: uppercase;
        }*/

        /* Toggle groups (Value/Saturation) */
        .matBtnGroup {
            display: inline-flex;
            gap: 8px;
            align-items: center;
            justify-content: center;
        }

        .hudSectionBody.centerSection {
            text-align: center;
        }

        .matToggle {
            background: #181c1d;
            color: #cfe;
            border: 1.5px solid #23343a;
            padding: 6px 12px;
            border-radius: 10px;
            cursor: pointer;
            transition: .14s;
        }

            .matToggle:hover {
                background: #1d2325;
            }

            .matToggle.active {
                background: rgba(43,224,165,0.10);
                border-color: #509989;
                color: #eee;
                font-weight: 600;
            }

        /* Hue strip */
        .hueStrip {
            display: flex;
            gap: 4px;
            justify-content: center;
            margin-top: 6px;
            flex-wrap: nowrap;
        }

            .hueStrip .sw {
                width: 26px;
                height: 26px;
                border-radius: 6px;
                border: 2px solid #0f171a;
                box-shadow: 0 0 0 1px #21353c, inset 0 0 0 1px rgba(255,255,255,0.25);
                cursor: pointer;
                transition: transform .08s, box-shadow .15s;
            }

                .hueStrip .sw:hover {
                    transform: translateY(-1px);
                }

                .hueStrip .sw.active {
                    box-shadow: 0 0 0 2px #21e9be, inset 0 0 0 1px rgba(255,255,255,0.6);
                }

        /* Small hint under hue strip */
        .matHint {
            color: #9fd;
            font-size: 12px;
            text-align: center;
            margin-top: 6px;
        }

        /* Pill buttons (Type + Preset) */
        .pillRow {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
            margin-top: 6px;
        }

        .pillRow-spaced {
            margin-top: 10px;
        }

        .pillBtn {
            padding: 6px 12px;
            border-radius: 999px;
            border: 1.5px solid #23343a;
            background: #181c1d;
            color: #cfe;
            cursor: pointer;
            transition: .12s;
        }

            .pillBtn:hover {
                background: #21282b;
            }

        .pillActive {
            background: rgba(43,224,165,0.25);
            border-color: #26e0b7;
            color: #fff;
            font-weight: 600;
        }

        .pillGhost {
            opacity: .9;
        }

            .pillGhost.pillActive {
                opacity: 1;
            }




        /* ——— Material Quality: centered layout ——— */
        .hudSectionHeader.active + .hudSectionBody .matSliderRow {
            display: grid;
            grid-template-columns: 1fr;
            row-gap: 6px;
            justify-items: center;
            text-align: center;
        }

        .matSliderLabel {
            width: 100%;
            text-align: center;
            font-weight: 400;
            letter-spacing: .02em;
        }

        /* slider track centered with a max width for a tidy read */
        .matSliderRow input[type="range"] {
            width: min(420px, 92%);
            margin: 0 auto;
        }

        /* numeric readout (right-aligned, same width as slider for alignment) */
        .matSliderReadout {
            width: min(420px, 92%);
            margin: 0 auto;
            display: flex;
            justify-content: flex-end;
            color: #9bd;
            font-variant-numeric: tabular-nums;
        }

        /* “less — value — more” on a single centered line */
        /*.matSliderHint {
            width: min(420px, 92%);
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            align-items: center;
            color: #9bd;
        }

            .matSliderHint span:first-child {
                justify-self: start;
            }

            .matSliderHint span:nth-child(2) {
                justify-self: center;
                font-variant-numeric: tabular-nums;
            }

            .matSliderHint span:last-child {
                justify-self: end;
            }*/

        /* Center the “less / more” labels under Texture Detail */
        #workflowMaterialHUD .endcaps {
            display: flex;
            justify-content: space-between;
            font-size: .9rem;
            opacity: .8;
            width: 100%;
            margin-top: -6px;
        }


        /* Compact column */
        .matTypeCompact {
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
        }

        /* Row wrapper */
        .pillSelectRow {
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 6px;
            align-items: center;
        }

        /* Label */
        .pillSelectLabel {
            font-size: 12px;
            letter-spacing: .08em;
            color: #bcd;
            text-align: center;
        }


        /* Pill-styled native select */
        .pillSelect {
            position: relative;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

            .pillSelect select {
                appearance: none;
                -webkit-appearance: none;
                -moz-appearance: none;
                text-align: center;
                text-align-last: center;
                border-radius: 999px;
                background: #152126;
                border: 1.5px solid #23343a;
                color: #cfe;
                font-weight: 600;
                cursor: pointer;
                min-width: 220px;
                box-shadow: inset 0 0 0 1px rgba(255,255,255,.06);
                transition: background .15s, border-color .15s, transform .03s;
            }

                .pillSelect select:hover {
                    background: #192a30;
                    border-color: #2f4852;
                }

                .pillSelect select:focus {
                    outline: 2px solid #26e0b7;
                    outline-offset: 2px;
                }

        /* Chevron */
        .pillChevron {
            position: absolute;
            right: 14px;
            pointer-events: none;
            color: #7fbfcf;
            font-weight: 700;
        }

        /* Optional: shrink width a bit for tighter HUD */
        @media (min-width: 420px) {
            .pillSelect select {
                min-width: 200px;
            }
        }






        .matHudSliderRow {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 14px;
            margin-top: 6px;
        }

        .matHudSliderLbl {
            font-size: 14px;
            color: #8fc6ef;
            min-width: 53px;
            text-align: center;
        }

        #qualitySlider {
            flex: 1;
            accent-color: #8fc6ef;
            height: 4px;
            margin: 0 8px;
        }




        .useBGGlowBtn {
            margin-bottom: 1.2em;
            margin-top: 0.3em;
            background: #1c2325;
            color: #a6ded0;
            border: 1.1px solid #27635b30;
            border-radius: 0.7em;
            font-size: 0.99rem;
            font-weight: 500;
            padding: 0.44em 1.1em;
            box-shadow: none;
            cursor: pointer;
            transition: box-shadow 0.16s, border 0.16s, background 0.13s, color 0.13s;
        }

            .useBGGlowBtn:hover, .useBGGlowBtn:focus {
                box-shadow: 0 0 11px 2.1px #36ffd5cc, 0 2px 9px 0 #22ffbf44;
                border: 1.1px solid #34ffd3cc;
                background: #232c2c;
                color: #e8fefa;
            }

        #samplesGalleryOverlay {
            display: flex;
            flex-direction: column;
            align-items: stretch;
        }

        .lbmIndicatorBtn {
            position: absolute;
            top: 0.54em;
            left: 0.62em;
            width: .9em;
            height: .9em;
            border-radius: 50%;
            border: none;
            background: #232b2b;
            box-shadow: 0 0 0 1.3px #26c9ae54;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            transition: box-shadow 0.16s, background 0.15s;
        }

            .lbmIndicatorBtn.glow {
                background: radial-gradient(circle at 60% 40%, #1fffc6 60%, #22d8ad 100%, #232b2b 130%);
                box-shadow: 0 0 8px 1.3px #36ffd58c, 0 2px 7px 0 #22ffbf29;
            }

            .lbmIndicatorBtn:after {
                background: #6dffe5;
                opacity: 0.25;
            }

            .lbmIndicatorBtn.glow:after {
                background: #2affd0;
                opacity: 0.72;
            }

        .modelsDropdownMenu {
            position: absolute;
            right: 0;
            top: 101%;
            min-width: 225px;
            margin-top: -2px;
            padding-top: 0;
            background: #151d21f8;
            border-radius: 12px;
            box-shadow: 0 .25px 18px 0 #22ffbf14;
            padding: 0.9em 0.6em 0.7em 0.6em;
            z-index: 8001;
            display: none;
            flex-direction: column;
            gap: 0.11em;
        }

        /*            #modelsDropdownNav:hover .modelsDropdownMenu,
            .modelsDropdownMenu:hover {
                display: flex;
            }*/
        /* Dropdown visibility is controlled via JS, so disable hover open */


        .modelRow {
            display: grid;
            grid-template-columns: 1fr 2.1em 2.2em;
            align-items: center;
            gap: 0.1em 0.38em;
            padding: 0.08em 0.14em;
            margin-bottom: 0.47em;
            min-width: 185px;
            width: 100%;
        }

            .modelRow + .modelRow {
                border-top: 1px solid #243238;
                margin-top: 0.24em;
                padding-top: 0.31em;
            }

        .modelName {
            font-size: 1.08em;
            font-weight: 400;
            color: #fff;
            letter-spacing: 0.015em;
            user-select: none;
            text-align: left;
            padding-right: 0.4em;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .modelFocusBtn {
            justify-self: center;
            width: 1.19em;
            height: 1.19em;
            border-radius: 50%;
            border: 2px solid #6ce2d2;
            background: transparent;
            box-shadow: none;
            cursor: pointer;
            transition: border 0.14s, box-shadow 0.14s, background 0.14s;
            margin: 0 0.16em;
        }

            .modelFocusBtn.on {
                border: 2px solid #18e4aecc;
                background: #18bfae;
                box-shadow: 0 0 8px 1.3px #29efc688, 0 0 2.2px #22ffbf60;
            }

            .modelFocusBtn.off {
                border: 2px solid #6ce2d2;
                background: transparent;
                box-shadow: none;
            }

        .modelIcon {
            justify-self: right;
            font-size: 1.16em;
            color: #a6ded0;
            margin-right: 0.10em;
            cursor: pointer;
            transition: color 0.14s, text-shadow 0.16s;
        }

            .modelIcon.locked,
            .modelIcon.locked:hover {
                color: #f9e06b;
                text-shadow: 0 0 10px #ffed6a88;
                cursor: pointer;
            }

            .modelIcon:hover:not(.locked) {
                color: #f9edb6;
                text-shadow: 0 0 8px #ffe05966;
            }

        .modelFocusBtn,
        .modelFocusBtn:focus,
        .modelFocusBtn:hover {
            cursor: pointer;
        }

        .modelName {
            cursor: default !important;
        }

        .modelFocusBtn.focus-processing {
            opacity: 0.90;
            pointer-events: none;
            box-shadow: 0 0 0 1.8px #3ac4fb, 0 0 13px 8px #3ac4fb3a;
            border-color: #19c2cf;
            background: transparent !important;
        }

        .historyDeleteIcon {
            position: absolute;
            top: 6px;
            right: 6px;
            color: #eee;
            font-size: 14px;
            cursor: pointer;
            display: none;
        }

        .historyFocusIcon {
            position: absolute;
            top: 6px;
            left: 6px;
            color: #e5b85c; /* warm yellow */
            font-size: 14px;
            cursor: pointer;
            display: none;
        }

        .historyThumb:hover .historyDeleteIcon,
        .historyThumb.lockedBefore .historyDeleteIcon {
            display: block;
        }

        .historyThumb:hover .historyFocusIcon,
        .historyThumb.lockedBefore .historyFocusIcon {
            display: block;
        }

        .historyThumb.lockedBefore .historyFocusIcon {
            background: #e5b85c;
            color: #0b0e11;
            border-radius: 50%;
            padding: 2px;
            box-shadow: 0 0 6px 2px rgba(229,184,92,0.6);
        }

        #historyPanelToggle {
            position: absolute;
            right: -39px; /* sits *just outside* the wrapper right edge */
            bottom: 35px; /* a bit above the canvas resizer, adjust to taste */
            width: 40px;
            height: 40px;
            background: rgba(20,25,30,0.83);
            border-radius: 12px 0 0 12px;
            border: 2.5px solid #1cfece7a;
            border-right: none;
            box-shadow: 2px 2px 10px #101a;
            color: #65ffe7;
            display: flex;
            align-items: center;
            justify-content: flex-start;
            font-size: 1.6em;
            cursor: pointer;
            opacity: 0.75;
            z-index: 11010;
            transition: background 0.18s, color 0.17s;
            padding-left: 8px;
            transform: scaleX(-1);
        }

            #historyPanelToggle i {
                transform: scaleX(-1); /* flips the icon back to normal */
                opacity: 0.85;
            }

            #historyPanelToggle:hover {
                background: #25e3c0cc;
                color: #111;
            }

        .frostedHistoryPanel {
            position: fixed;
            top: var(--menu-bar-h,48px); /* below top bar */
            right: 0;
            width: 330px;
            height: calc(100vh - var(--menu-bar-h,48px));
            background: rgba(22,28,34,0.68);
            backdrop-filter: blur(15px) saturate(110%);
            box-shadow: -8px 0 24px 0 #0a1116a8;
            border-left: 1.5px solid rgba(65,255,215,0.13);
            z-index: 11005;
            display: flex;
            flex-direction: column;
            transition: transform 0.34s cubic-bezier(.55,.09,.55,.93), opacity 0.21s;
            opacity: 0.96;
            transform: translateX(104%);
            pointer-events: none;
        }

            .frostedHistoryPanel.open {
                transform: translateX(0%);
                pointer-events: auto;
                opacity: 1;
            }

            .frostedHistoryPanel.closed {
                transform: translateX(104%);
                pointer-events: none;
                opacity: 0;
            }


        .historyPanelHeader {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 18px 24px 10px 22px;
            font-size: 1.17em;
            color: #65ffe7;
            font-weight: 500;
            letter-spacing: 0.02em;
            border-bottom: 1.3px solid #22ffd322;
        }

        #closeHistoryPanel {
            background: none;
            border: none;
            color: #aaa;
            font-size: 1.25em;
            padding: 3px 10px 0 35px;
            display: inline-flex;
            cursor: pointer;
            opacity: 0.85;
            transition: color 0.15s;
        }

            #closeHistoryPanel:hover {
                color: #fff;
            }

        .historyThumbsWrapper {
            position: relative;
            flex: 1;
            min-height: 0;
            display: flex;
            flex-direction: column;
        }

        .historyThumbs {
            flex: 1;
            min-height: 0;
            width: 100%;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 19px 13px 70px 13px;
            display: flex;
            flex-direction: column;
            gap: 13px;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }

            .historyThumbs::-webkit-scrollbar {
                display: none;
            }

        .historyScrollControls {
            position: absolute;
            right: 18px;
            bottom: 18px;
            display: none;
            flex-direction: column;
            gap: 8px;
            padding: 8px 6px;
            border-radius: 12px;
            background: rgba(13, 20, 25, 0.68);
            box-shadow: 0 12px 28px rgba(6, 12, 15, 0.45);
            z-index: 2;
        }

            .historyScrollControls.visible {
                display: flex;
            }

        .historyScrollArrow {
            width: 28px;
            height: 28px;
            border: none;
            background: none;
            color: #87fff0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            cursor: pointer;
            transition: color 0.18s, transform 0.18s, opacity 0.18s;
            padding: 0;
            touch-action: none;
        }

            .historyScrollArrow:hover {
                color: #ffffff;
                transform: translateY(-1px);
            }

            .historyScrollArrow.down:hover {
                transform: translateY(1px);
            }

            .historyScrollArrow.disabled {
                opacity: 0.35;
                pointer-events: none;
                transform: none;
            }

        .historyThumb {
            border-radius: 7px;
            background: rgba(125,255,255,0.10);
            box-shadow: 0 0 6px 0 #00ffd366;
            cursor: pointer;
            border: 2px solid transparent;
            transition: border 0.15s, box-shadow 0.17s, transform 0.13s;
            width: 96%;
            max-width: 260px;
            margin: 0 auto;
            padding: 4px;
            display: flex;
            align-items: center;
            position: relative;
        }

            .historyThumb.selected,
            .historyThumb:hover {
                border: 2px solid #23e1b6;
                box-shadow: 0 0 0 4px #00ffd34d;
                transform: scale(1.025);
            }

            .historyThumb img,
            .historyThumb video {
                width: 100%;
                border-radius: 5px;
                display: block;
                object-fit: contain;
            }

        .historyModelLabel {
            position: absolute;
            bottom: 6px;
            left: 6px;
            background: rgba(0, 0, 0, 0.7);
            padding: 2px 4px;
            font-size: 11px;
            border-radius: 3px;
            color: #fff;
            pointer-events: none;
        }

        .historyInfoIcon {
            position: absolute;
            bottom: 6px;
            right: 6px;
            color: #fff;
            font-size: 14px;
            cursor: pointer;
        }

        .historyInfoTooltip {
            position: absolute;
            bottom: 24px;
            left: 4px;
            right: 4px;
            background: #1d2327;
            color: #aaffef;
            padding: 4px 6px;
            border-radius: 4px;
            white-space: pre-wrap;
            word-break: break-word;
            font-size: 11px;
            z-index: 1000;
            max-height: calc(100% - 30px);
            overflow-y: auto;
            display: none;
        }

            .historyInfoIcon:hover + .historyInfoTooltip,
            .historyInfoTooltip:hover {
                display: block;
            }

        .thumbBlendSlider {
            position: absolute;
            bottom: 6px;
            left: 50%;
            transform: translateX(-50%);
            width: 45%;
            opacity: 0;
            pointer-events: none;
            z-index: 3;
            transition: opacity 0.15s;
        }

        .historyThumb:hover .thumbBlendSlider {
            opacity: 1;
            pointer-events: auto;
        }

        .thumbBlendOrig {
            position: absolute;
            top: 4px;
            left: 4px;
            width: calc(100% - 8px);
            height: calc(100% - 8px);
            border-radius: 5px;
            object-fit: contain;
            pointer-events: none;
            opacity: 0;
        }

        #stickerActionDrawer {
            position: absolute;
            display: none;
            left: 0;
            top: 0;
            z-index: 999999;
            min-width: 150px;
            padding: 12px 17px 12px 17px;
            border-radius: 8px;
            background: rgba(48,54,60,0.45);
            backdrop-filter: blur(1.25px) saturate(1.15) brightness(0.90);
            opacity: 0;
            pointer-events: none;
            transform-origin: top center;
            transform: scaleY(0.96);
            transition: opacity 0.23s cubic-bezier(.46,1.12,.63,.96), transform 0.22s cubic-bezier(.48,1.18,.73,.89);
        }

            #stickerActionDrawer.open {
                display: block;
                opacity: 1;
                pointer-events: auto;
                transform: scaleY(1.0);
            }

        .sticker-action-row {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 11px;
        }

        .sticker-action-btn {
            width: 38px;
            height: 38px;
            border-radius: 60%;
            background: transparent;
            border: none;
            padding: 2px 4px;
            transition: background 0.18s;
            outline: none;
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 25px;
            font-weight: 100;
            cursor: pointer;
            box-shadow: 0 0 0 0 #1fffd455;
        }

            .sticker-action-btn:hover {
                color: #262b2e;
                box-shadow: 0 0 8px 2px #1fffd433;
                border-color: #17ffd3;
            }

            .sticker-action-btn:hover, .sticker-action-btn:focus {
                background: rgba(40,55,60,0.97); /* Much darker pop */
                box-shadow: 0 0 6px 2px #1fffd42b; /* 60% weaker than before */
            }

            .sticker-action-btn svg {
                filter: none;
                /* Optionally tweak icon scale */
            }

            .sticker-action-btn:hover svg, .sticker-action-btn:focus svg {
                /* Reduce highlight/seafoam green by 40% (opacity) */
                stroke: #dbdbdb !important; /* White highlight */
                filter: brightness(1.28) drop-shadow(0 0 2px #fff9);
                opacity: 1;
                opacity: 0.8; /* 60% strength of normal */
            }

            .sticker-action-btn:hover .hudbox-stroke,
            .sticker-action-btn:focus .hudbox-stroke {
                stroke: #fff !important;
                filter: drop-shadow(0 0 3px #fff9);
            }

            .sticker-action-btn .hudbox-icon {
                stroke: #38ffe3 !important;
                /* No color change on hover! */
            }


        #workflowsTab {
            position: absolute;
            left: -39px; /* sits outside the wrapper left edge */
            bottom: 35px;
            width: 40px;
            height: 40px;
            background: rgba(20,25,30,0.83);
            border-radius: 0 12px 12px 0;
            border: 2.5px solid #1cfece7a;
            border-left: none;
            box-shadow: -2px 2px 10px #101a;
            color: #65ffe7;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            font-size: 1.6em;
            cursor: pointer;
            opacity: 0.75;
            z-index: 11000;
            transform: scaleX(-1);
            transition: background 0.18s, color 0.17s;
            padding-right: 8px;
        }

            #workflowsTab:hover {
                background: #25e3c0cc;
                color: #111;
            }

        #workflowsDrawer {
            position: absolute;
            left: -835px; /* align with canvas left edge */
            bottom: 45px; /* half above canvas bottom, half below */
            min-width: 220px;
            height: 80px;
            background: rgba(20,25,30,0.9);
            border: 0.5px solid #333;
            border-radius: 6px;
            box-shadow: 0 4px 16px rgba(0,0,0,.85);
            display: flex;
            flex-direction: row;
            gap: 12px;
            padding: 20px;
            opacity: 0;
            pointer-events: none;
            overflow: hidden;
            transition: ease-in-out .22s linear, opacity .11s;
            transform-origin: bottom left;
            transform: scaleY(0);
            z-index: 11010;
        }

            #workflowsDrawer.open {
                transform: scaleY(1);
                opacity: 1;
                pointer-events: auto;
                z-index: 11010;
            }

            #workflowsDrawer .buttonHudIcon {
                opacity: 1 !important;
                background: rgba(34, 54, 64, 0.97);
                color: #3fffd1;
                border: 1.5px solid #24e0b9;
                box-shadow: 0 2px 12px 0 rgba(36, 255, 212, 0.08);
                transition: background 0.13s, color 0.14s, border-color 0.12s, box-shadow 0.20s, opacity 0.15s;
            }

                #workflowsDrawer .buttonHudIcon:hover {
                    background: #22ffd6;
                    color: #161e21;
                    border-color: #4d748dff;
                    opacity: 1 !important;
                    /* GLOW EFFECT: inner + outer glows, seafoam accent */
                    box-shadow: 0 0 0 2.0px #20ffd8d0, /* bright border */
                    0 0 12px 1px #21ffd7a9, /* outer glow */
                    0 2px 18px 3px #3fffd155; /* ambient blur */
                    filter: brightness(.9) saturate(1.10);
                }




        .currentCanvasThumb {
            border: 1.5px solid #e5b85c !important; /* warm yellow */
            box-shadow: 0 0 0 4px #f3ce2170 !important; /* yellow glow */
            background: rgba(255,245,200,0.18) !important;
            position: relative;
        }

            .currentCanvasThumb.selected {
                border: 2.5px solid #e5b85c !important;
                box-shadow: 0 0 0 4px #f8e67066 !important;
            }

            .currentCanvasThumb::after {
                content: "CURRENT";
                position: absolute;
                bottom: 9px;
                right: 14px;
                background: #f6e07a;
                color: #785f16;
                font-weight: bold;
                font-size: 11px;
                border-radius: 6px;
                padding: 1px 8px 2px 8px;
                opacity: 0.88;
                letter-spacing: 0.05em;
                pointer-events: none;
                z-index: 1;
            }

        .historyFgToggleBtn,
        .historyCloseBtn,
        .historyModeToggleBtn {
            background: none;
            border: none;
            color: #87fff0;
            font-size: 0.90em;
            margin: 0 5px;
            padding: 3px 4px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border-radius: 7px;
            cursor: pointer;
            transition: color 0.15s, background 0.15s;
            position: relative;
            vertical-align: middle;
            top: 2px;
        }

        .historyCloseBtn {
            margin-left: 8px; /* align closer to other header buttons */
        }

        .historyFgToggleBtn.toggled {
            color: #fff;
            background: none;
        }

        .historyFgToggleBtn:not(.toggled) {
            background: none !important;
            color: #87fff0;
        }

        .historyFgToggleBtn:hover,
        .historyFgToggleBtn:focus,
        .historyCloseBtn:hover,
        .historyCloseBtn:focus,
        .historyModeToggleBtn:hover,
        .historyModeToggleBtn:focus {
            background: #2fffd928;
            outline: none;
        }

        .historyFgToggleBtn[data-tip]:hover:after,
        .historyFgToggleBtn[data-tip]:focus:after,
        .historyModeToggleBtn[data-tip]:hover:after,
        .historyModeToggleBtn[data-tip]:focus:after {
            content: attr(data-tip);
            position: absolute;
            top: 120%;
            left: 50%;
            transform: translateX(-50%);
            background: #181f1f;
            color: #fff;
            padding: 5px 16px 6px 16px;
            border-radius: 7px;
            font-size: 0.97em;
            font-weight: 500;
            white-space: nowrap;
            box-shadow: 0 4px 22px #0007;
            z-index: 99;
            pointer-events: none;
            opacity: 0.97;
            letter-spacing: 0.04em;
        }

        .historyPanelHeader {
            display: flex;
            align-items: center;
            justify-content: space-between; /* ensures "Session History" left, buttons right */
            padding: 18px 24px 10px 22px;
            font-size: 1.0em;
            color: #65ffe7;
            font-weight: 400;
            letter-spacing: 0.02em;
            border-bottom: 1.3px solid #22ffd322;
            white-space: nowrap;
            gap: 0; /* prevent any automatic extra space */
        }

        .historyTitle {
            flex-shrink: 0;
            font-size: 1.18em;
            font-weight: 600;
            color: #65ffe7;
            letter-spacing: 0.03em;
            white-space: nowrap;
        }

        .historyPanelHeaderBtnRow {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .historyPanelFooter {
            display: flex;
            align-items: center;
            justify-content: flex-start;
            padding: 10px 18px 14px 18px;
            border-top: 1px solid #22ffd322;
        }

        .historyClearBtn {
            background: none;
            border: none;
            color: #87fff0;
            font-size: 1.05em;
            padding: 4px 10px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border-radius: 7px;
            cursor: pointer;
            transition: color 0.15s, background 0.15s;
        }

            .historyClearBtn:hover,
            .historyClearBtn:focus {
                background: #2fffd928;
                color: #fff;
            }

        /* ComfyDock states */
        #comfyDock.disconnected {
            opacity: .7;
            filter: grayscale(.2);
        }

        #comfyDot {
            transition: background .3s, box-shadow .3s;
        }

        /* brief seafoam pulse when a job is dispatched */
        @keyframes glowPulse {
            0% {
                box-shadow: 0 0 0 0 rgba(43,224,165,.8);
            }

            70% {
                box-shadow: 0 0 0 10px rgba(43,224,165,0);
            }

            100% {
                box-shadow: 0 0 0 0 rgba(43,224,165,0);
            }
        }

        #comfyDot.glow {
            animation: glowPulse .9s ease-out;
        }

        /* --- ComfyDock placement & visibility --- */
        #comfyDock {
            right: 112px !important; /* leave room for the restore/resizer cluster */
            bottom: 25px !important; /* small lift feels less crowded */
            display: none !important; /* hidden until Send→Comfy is pressed */
        }

            #comfyDock.is-visible {
                display: flex !important;
            }

        /* Scope everything to the camera HUD to avoid global collisions */
        #workflowCameraHUD.cameraHUDCompact {
            width: 512px;
        }

        #workflowCameraHUD .camHUD-wrap {
            display: grid;
            grid-template-columns: minmax(0, 1.05fr) minmax(0, .95fr);
            gap: 16px;
            align-items: stretch;
        }

        #workflowCameraHUD .camHUD-card {
            background: linear-gradient(160deg, #161c1f, #121619);
            border: 1.5px solid #23343a;
            border-radius: 12px;
            padding: 12px;
            box-shadow: 0 14px 34px -24px rgba(25, 255, 220, 0.5), 0 0 0 1px rgba(33, 242, 201, 0.28);
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-width: 0;
        }

        #workflowCameraHUD .camHUD-padCard {
            padding: 14px 14px 12px;
            gap: 10px;
        }

        #workflowCameraHUD .camHUD-padHeader {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            gap: 4px;
        }

        #workflowCameraHUD .camHUD-padTitle {
            font-size: 11px;
            letter-spacing: 0.12em;
            text-transform: uppercase;
            color: #86f2d5;
            font-weight: 600;
            width: 100%;
            text-align: center;
        }

        #workflowCameraHUD .camHUD-padSurface {
            --pad-button-size: 38px;
            --pad-gap: 6px;
            --pad-corner-size: 32px;
            --pad-grid-size: calc(var(--pad-button-size) * 3 + var(--pad-gap) * 2);
            --pad-cell-step: calc(var(--pad-button-size) + var(--pad-gap));
            background: radial-gradient(circle at top, rgba(30, 50, 54, 0.65) 0, rgba(13, 23, 25, 0.95) 80%);
            border-radius: 12px;
            border: 1px solid rgba(37, 69, 71, 0.6);
            padding: 26px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            max-width: 260px;
            margin: 0 auto;
            position: relative;
            flex: 1;
        }

        /* Pad */
        #workflowCameraHUD .camHUD-grid {
            display: grid;
            grid-template-columns: repeat(3, var(--pad-button-size));
            grid-template-rows: repeat(3, var(--pad-button-size));
            gap: var(--pad-gap);
            justify-content: center;
            align-content: center;
            margin: 0;
        }

        #workflowCameraHUD .camHUD-btn {
            width: var(--pad-button-size);
            height: var(--pad-button-size);
            border-radius: 9px;
            background: #171c1e;
            color: #74e3c7;
            border: 1.5px solid #1f2b2f;
            box-shadow: 0 0 0 0.4px rgba(20, 255, 191, 0.12), inset 0 -2px 4px rgba(0, 0, 0, 0.35);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 15px;
            cursor: pointer;
            transition: .14s background, .14s box-shadow, .14s border-color, .14s color, .14s transform;
        }

            #workflowCameraHUD .camHUD-btn:hover,
            #workflowCameraHUD .camHUD-btn:focus-visible,
            #workflowCameraHUD .camHUD-btn.selected {
                background: #1f2629;
                color: #f2fff9;
                border-color: #24e6bf;
                box-shadow: 0 0 0 2.2px rgba(24, 240, 185, 0.65);
            }

            #workflowCameraHUD .camHUD-btn.active {
                box-shadow: 0 0 0 2.6px rgba(24, 240, 185, 0.8), 0 0 12px rgba(24, 240, 185, 0.35);
            }

            #workflowCameraHUD .camHUD-btn.conflict {
                border-color: #ff6b6b;
                box-shadow: 0 0 0 2.2px rgba(255, 107, 107, 0.65);
                animation: camHudConflict 0.4s ease;
            }

            #workflowCameraHUD .camHUD-btn:focus-visible {
                outline: none;
                transform: translateY(-1px);
            }

            #workflowCameraHUD .camHUD-btn.center i {
                font-size: 13px;
            }

        #workflowCameraHUD .camHUD-cornerBtn {
            position: absolute;
            width: var(--pad-corner-size);
            height: var(--pad-corner-size);
            border-radius: 50%;
            background: rgba(19, 29, 30, 0.92);
            color: #69dfbf;
            border: 1.5px solid rgba(27, 66, 62, 0.65);
            box-shadow: 0 0 0 0.4px rgba(20, 255, 191, 0.12), inset 0 -1px 3px rgba(0, 0, 0, 0.35);
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 13px;
            cursor: pointer;
            transition: .14s background, .14s box-shadow, .14s border-color, .14s color, .14s transform;
        }

            #workflowCameraHUD .camHUD-cornerBtn:hover,
            #workflowCameraHUD .camHUD-cornerBtn:focus-visible,
            #workflowCameraHUD .camHUD-cornerBtn.selected {
                background: #223034;
                color: #f2fff9;
                border-color: #24e6bf;
                box-shadow: 0 0 0 2px rgba(24, 240, 185, 0.45);
            }

            #workflowCameraHUD .camHUD-cornerBtn.active {
                box-shadow: 0 0 0 2.3px rgba(24, 240, 185, 0.65), 0 0 10px rgba(24, 240, 185, 0.32);
            }

            #workflowCameraHUD .camHUD-cornerBtn.conflict {
                border-color: #ff6b6b;
                box-shadow: 0 0 0 2.1px rgba(255, 107, 107, 0.6);
                animation: camHudConflict 0.4s ease;
            }

        @keyframes camHudConflict {
            0% {
                transform: translateY(0);
            }

            40% {
                transform: translateY(-2px);
            }

            100% {
                transform: translateY(0);
            }
        }

        #workflowCameraHUD .camHUD-cornerBtn:focus-visible {
            outline: none;
            transform: translateY(-1px);
        }

        #workflowCameraHUD .camHUD-cornerBtn.top-left {
            top: calc(50% - var(--pad-grid-size) / 2 + (var(--pad-button-size) - var(--pad-corner-size)) / 2);
            left: calc(50% - var(--pad-grid-size) / 2 + (var(--pad-button-size) - var(--pad-corner-size)) / 2);
        }

        #workflowCameraHUD .camHUD-cornerBtn.top-right {
            top: calc(50% - var(--pad-grid-size) / 2 + (var(--pad-button-size) - var(--pad-corner-size)) / 2);
            left: calc(50% - var(--pad-grid-size) / 2 + 2 * var(--pad-cell-step) + (var(--pad-button-size) - var(--pad-corner-size)) / 2);
        }

        #workflowCameraHUD .camHUD-cornerBtn.bottom-left {
            top: calc(50% - var(--pad-grid-size) / 2 + 2 * var(--pad-cell-step) + (var(--pad-button-size) - var(--pad-corner-size)) / 2);
            left: calc(50% - var(--pad-grid-size) / 2 + (var(--pad-button-size) - var(--pad-corner-size)) / 2);
        }

        #workflowCameraHUD .camHUD-cornerBtn.bottom-right {
            top: calc(50% - var(--pad-grid-size) / 2 + 2 * var(--pad-cell-step) + (var(--pad-button-size) - var(--pad-corner-size)) / 2);
            left: calc(50% - var(--pad-grid-size) / 2 + 2 * var(--pad-cell-step) + (var(--pad-button-size) - var(--pad-corner-size)) / 2);
        }


        #workflowCameraHUD .camHUD-actionLabel {
            margin-top: 16px;
            background: rgba(13, 25, 27, 0.92);
            border: 1px solid rgba(38, 78, 77, 0.45);
            border-radius: 12px;
            padding: 12px 16px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            align-items: center;
            text-align: center;
        }

        #workflowCameraHUD .camHUD-actionPrimary {
            font-weight: 600;
            color: #8ff2d8;
            font-size: 10px;
            letter-spacing: 0.16em;
            text-transform: uppercase;
        }

        #workflowCameraHUD .camHUD-actionSecondary {
            font-size: 11px;
            color: rgba(173, 236, 221, 0.8);
            line-height: 1.45;
        }

        #workflowCameraHUD .camHUD-currentAction {
            font-size: 11px;
            letter-spacing: 0.14em;
            text-transform: uppercase;
            color: rgba(193, 247, 229, 0.95);
            font-weight: 600;
        }

        #workflowCameraHUD .camHUD-sliderWrap {
            background: rgba(13, 25, 27, 0.92);
            border: 1px solid rgba(34, 62, 64, 0.6);
            border-radius: 10px;
            padding: 10px 12px 12px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-height: 72px;
        }

            #workflowCameraHUD .camHUD-sliderWrap.is-empty {
                background: rgba(13, 25, 27, 0.35);
                border-style: dashed;
                border-color: rgba(34, 62, 64, 0.35);
                padding: 12px;
                gap: 6px;
            }

        #workflowCameraHUD .camHUD-sliderHeader {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
        }

        #workflowCameraHUD .camHUD-sliderLabel {
            font-size: 9px;
            letter-spacing: 0.12em;
            text-transform: uppercase;
            color: rgba(154, 240, 214, 0.75);
        }

        #workflowCameraHUD .camHUD-sliderValue {
            font-size: 13px;
            color: #e8fff8;
            font-weight: 600;
            font-variant-numeric: tabular-nums;
        }

        #workflowCameraHUD .camHUD-sliderBody input[type=range] {
            width: 100%;
            min-width: 0;
        }

        #workflowCameraHUD .camHUD-title {
            font-size: 13px;
            font-weight: 600;
            color: #b8f5e2;
            white-space: nowrap;
            width: 100%;
            text-align: center;
        }

        #workflowCameraHUD .camHUD-reveal {
            gap: 12px;
            padding: 14px 16px 16px;
            min-width: 0;
        }

        #workflowCameraHUD .camHUD-revealHeader {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            gap: 12px;
        }

        #workflowCameraHUD .camHUD-toggleRow {
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: flex-start;
            width: 100%;
            padding-left: 4px;
        }


        #workflowCameraHUD .camHUD-lockRow {
            display: flex;
            justify-content: flex-start;
            padding-left: 4px;
            width: 100%;
        }

        #workflowCameraHUD .camHUD-switch {
            display: inline-flex;
            align-items: center;
            justify-content: space-between;
            gap: 6px;
            cursor: pointer;
            color: #c7f7ec;
            font-size: 10px;
            padding: 4px 6px;
            border-radius: 999px;
            background: rgba(14, 26, 28, 0.85);
            border: 1px solid rgba(33, 63, 66, 0.55);
            width: auto;
        }

            #workflowCameraHUD .camHUD-switch .lbl {
                font-size: 9px;
                letter-spacing: 0.1em;
                text-transform: uppercase;
                font-weight: 600;
                white-space: nowrap;
            }

            #workflowCameraHUD .camHUD-switch input {
                display: none;
            }

            #workflowCameraHUD .camHUD-switch .pill {
                position: relative;
                width: 34px;
                height: 18px;
                background: #1a2526;
                border-radius: 9px;
                border: 1px solid #2f3f41;
                transition: .2s background, .2s border;
                flex-shrink: 0;
            }

                #workflowCameraHUD .camHUD-switch .pill::after {
                    content: "";
                    position: absolute;
                    top: 2px;
                    left: 2px;
                    width: 14px;
                    height: 14px;
                    background: #304d4a;
                    border-radius: 50%;
                    transition: .2s transform, .2s background;
                    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.25);
                }

            #workflowCameraHUD .camHUD-switch input:checked + .pill {
                background: linear-gradient(135deg, #1ee2a1, #3ce9c4);
                border-color: #3df0c1;
            }

                #workflowCameraHUD .camHUD-switch input:checked + .pill::after {
                    transform: translateX(16px);
                    background: #0f2623;
                }

        #workflowCameraHUD .readout {
            width: auto;
            text-align: right;
            color: #e4fff6;
            font-variant-numeric: tabular-nums;
            font-size: 11px;
        }

        /* Keep Advanced Prompt collapsed initially like other HUDs */
        #workflowCameraHUD #cameraAdvBody.collapsed {
            display: none !important;
        }
    </style>
    <!--<script defer src="/static/js/three.min.js"></script>-->
    <!--<script defer src="/static/js/OrbitControls.js"></script>
    <script defer src="/static/js/GLTFLoader.js"></script>-->
    <script defer src="js/OrbitControls.js"></script>
    <script defer src="js/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>

    <script src="js/sticker_3d_container.js"></script>
</head>
<body>
    <div id="appContainer">
        <!-- TOP NAV BAR -->
        <div id="topNavBar">
            <div class="navLeft">
                <div class="topLogo">
                    <div class="topLogoIcon"></div>
                    <div class="topLogoText">LUMIFY</div>
                </div>

                <!-- IMPORT dropdown -->
                <div class="navItem" id="navImport">
                    <i class="fas fa-folder-open"></i>
                    <span>Import</span>
                    <div class="dropdownMenu" id="importMenu">
                        <div class="dropdownItem" id="uploadBgBtn">
                            <span>Upload BG</span>
                            <i class="fas fa-images"></i>
                            <div class="rightSubMenu">
                                <div class="dropdownItem" id="bgFromComputerBtn">
                                    <span>Frm Computer</span>
                                    <i class="fas fa-desktop"></i>
                                </div>
                                <div class="dropdownItem" id="bgSamplesBtn">
                                    <span>Samples</span>
                                    <i class="fas fa-th"></i>
                                </div>
                            </div>
                        </div>
                        <div class="dropdownItem" id="uploadFgBtn">
                            <span>Upload FG</span>
                            <i class="fas fa-layer-group"></i>
                            <div class="rightSubMenu">
                                <div class="dropdownItem" id="fgImageBtn">
                                    <span>Image</span>
                                    <i class="fas fa-image"></i>
                                </div>
                                <div class="dropdownItem" id="fgAssetBtn">
                                    <span>Asset</span>
                                    <i class="fas fa-box-open"></i>
                                </div>
                                <div class="dropdownItem" id="fgFlipBookBtn">
                                    <span>Flip Book</span>
                                    <i class="fas fa-book-open"></i>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- WORKFLOWS dropdown -->
                <div class="navItem" id="navImport">
                    <i class="fas fa-project-diagram"></i>
                    <span>Workflows</span>
                    <div class="dropdownMenu" id="importMenu">
                        <div class="dropdownItem" id="workflowImageBtn">
                            <span>Image</span>
                            <i class="fas fa-image"></i>
                        </div>
                        <div class="dropdownItem" id="workflowCameraBtn">
                            <span>Camera</span>
                            <i class="fa-solid fa-camera-rotate"></i>
                        </div>
                        <div class="dropdownItem" id="workflowLightingBtn">
                            <span>Composite</span>
                            <i class="fas fa-lightbulb"></i>
                        </div>
                        <div class="dropdownItem" id="workflowMaterialBtn">
                            <span>Material</span>
                            <i class="fas fa-gem"></i>
                        </div>
                        <div class="dropdownItem" id="workflowTimeBtn">
                            <span>Time of Day</span>
                            <i class="fa-solid fa-cloud-sun"></i>
                        </div>
                        <div class="dropdownItem" id="workflowStylizeBtn">
                            <span>Stylize</span>
                            <i class="fas fa-brush"></i>
                        </div>
                        <div class="dropdownItem" id="workflowPromptBtn">
                            <span>Prompt</span>
                            <i class="fas fa-keyboard"></i>
                        </div>
                        <div class="dropdownItem" id="workflow3DBtn">
                            <span>3D</span>
                            <i class="fas fa-cube"></i>
                        </div>
                        <div class="dropdownItem" id="workflowVideoBtn">
                            <span>Video</span>
                            <i class="fas fa-video"></i>
                        </div>
                    </div>
                </div>

                <!-- GENERATORS dropdown -->
                <div class="navItem" id="navImport">
                    <i class="fas fa-bolt"></i>
                    <span>Generators</span>
                    <div class="dropdownMenu" id="importMenu">
                        <div class="dropdownItem" id="computeDepthBtn">
                            <span>Img2Depth</span>
                            <i class="fas fa-water"></i>
                        </div>
                        <div class="dropdownItem" id="sdImg2ImgBtn">
                            <span>Img2Img</span>
                            <i class="fas fa-clone"></i>
                        </div>
                        <div class="dropdownItem" id="sdDepth2ImgBtn">
                            <span>Depth2Img</span>
                            <i class="fas fa-water"></i>
                        </div>
                        <!--<div class="dropdownItem" id="imgCaptionBtn">
                            <span>Img2Caption</span>
                            <i class="fas fa-comment-alt"></i>
                        </div>-->
                        <!--<div class="dropdownItem" id="threedGenBtn">
                            <span>3DGen</span>
                            <i class="fas fa-dice-d20"></i>
                        </div>-->
                        <div class="dropdownItem" id="img2PoseBtn">
                            <span>Img2Pose</span>
                            <i class="fas fa-person-running"></i>
                        </div>
                        <!--<div class="dropdownItem" id="img2VideoBtn">
                            <span>Img2Video</span>
                            <i class="fas fa-video"></i>
                        </div>-->
                        <div class="dropdownItem" id="enhanceBtn">
                            <span>Enhance</span>
                            <i class="fas fa-wand-magic-sparkles"></i>
                        </div>
                    </div>
                </div>

                <!-- GALLERY button -->
                <div class="standaloneBtn" id="galleryBtn">
                    <i class="fas fa-images"></i><span>Gallery</span>
                </div>
            </div>

            <div class="navRight">
                <div class="navItem" id="imageAdjustmentsToggle" role="button" aria-expanded="false" aria-controls="imageAdjustmentsBar" aria-label="Image Adjustments" title="Image Adjustments" tabindex="0">
                    <i class="fas fa-sliders-h"></i>
                </div>
                <div class="navItem" id="sendDropdownBtn">
                    <span>Send</span>
                    <i class="fas fa-paper-plane"></i>
                    <div class="dropdownMenu">
                        <div class="dropdownItem" id="sendToPsBtn">
                            <span>to PS</span>
                            <i class="fas fa-pen-nib"></i>
                        </div>
                        <div class="dropdownItem" id="sendToMixamo">
                            <span>to Mixamo</span>
                            <i class="fas fa-person-running"></i>
                        </div>
                        <div class="dropdownItem" id="sendToUnrealBtn">
                            <span>to Unreal</span>
                            <i class="fas fa-gamepad"></i>
                        </div>
                        <div class="dropdownItem" id="sendToComfyBtn">
                            <span>to Comfy UI</span>
                            <i class="fa-solid fa-c"></i>
                        </div>
                    </div>
                </div>
                <div class="navItem" id="modelsDropdownNav">
                    <span>AI Models</span>
                    <i class="fas fas fa-code-branch"></i>
                    <div class="modelsDropdownMenu" id="modelsDropdown">
                        <div class="modelRow">
                            <span class="modelName">DepthAnything</span>
                            <button class="modelFocusBtn off" data-model="depth" title="Toggle Depth On/Off"></button>
                            <i class="fas fa-layer-group modelIcon" data-model="depth" title="Lock Depth"></i>
                        </div>
                        <div class="modelRow">
                            <span class="modelName">SegmentAnything</span>
                            <button class="modelFocusBtn off" data-model="sam" title="Toggle SAM On/Off"></button>
                            <i class="fas fa-mask modelIcon" data-model="sam" title="Lock SAM"></i>
                        </div>
                        <div class="modelRow">
                            <span class="modelName">LBM Relighting</span>
                            <button class="modelFocusBtn off" data-model="lbm" title="Toggle LBM On/Off"></button>
                            <i class="fas fa-lightbulb modelIcon" data-model="lbm" title="Lock LBM"></i>
                        </div>
                        <!--<div class="modelRow">
                            <span class="modelName">Flux Schnell</span>
                            <button class="modelFocusBtn off" data-model="flux_schnell" title="Toggle Flux Schnell On/Off"></button>
                            <i class="fas fa-bolt modelIcon" data-model="flux_schnell" title="Lock Flux Schnell"></i>
                        </div>-->
                        <div class="modelRow">
                            <span class="modelName">Flux Kontext</span>
                            <button class="modelFocusBtn off" data-model="flux_kontext" title="Toggle Flux Kontext On/Off"></button>
                            <i class="fas fa-image modelIcon" data-model="flux_kontext" title="Lock Flux Kontext"></i>
                        </div>
                        <div class="modelRow">
                            <span class="modelName">Hunyuan3D</span>
                            <button class="modelFocusBtn off" data-model="shape" title="Toggle Hunyuan3D On/Off"></button>
                            <i class="fas fa-cube modelIcon" data-model="shape" title="Lock Hunyuan3D"></i>
                        </div>
                        <div class="modelRow">
                            <span class="modelName">Wan2.2</span>
                            <button class="modelFocusBtn off" data-model="wan" title="Toggle Wan2.2 On/Off"></button>
                            <i class="fas fa-images modelIcon" data-model="wan" title="Lock Wan2.2"></i>
                        </div>
                        <div class="modelRow">
                            <span class="modelName">JoyCaption</span>
                            <button class="modelFocusBtn off" data-model="caption" title="Toggle JoyCaption On/Off"></button>
                            <i class="fas fa-comment modelIcon" data-model="caption" title="Lock JoyCaption"></i>
                        </div>
                    </div>
                </div>
                <div class="bottomBtn" id="gpuBtn" title="Toggle GPU/CPU Mode">
                    <i class="fas fa-microchip"></i>
                </div>
                <div class="bottomBtn" id="purgeCacheBtn" title="Purge Cache">
                    <i class="fas fa-trash-restore"></i>
                </div>
                <div class="bottomBtn" id="settingsBtn" title="App Settings">
                    <i class="fas fa-cog"></i>
                </div>
            </div>
        </div>

        <div id="imageAdjustmentsBar" aria-hidden="true">
            <div id="imageAdjustmentsBarContent">
                <div id="imageAdjustmentsRestore" role="button" tabindex="0" title="Restore All Adjustments" aria-label="Restore All Adjustments">
                    <i class="fas fa-undo"></i>
                </div>
                <div class="imageAdjustmentControl" data-adjustment="exposure">
                    <span class="imageAdjustmentLabel">Exposure</span>
                    <input id="imageAdjustExposure" class="stealthSlider imageAdjustmentSlider" type="range" min="-2" max="2" step="0.1" value="0" aria-label="Adjust Exposure" />
                    <span class="imageAdjustmentValue" id="imageAdjustExposureValue">0.0</span>
                </div>
                <div class="imageAdjustmentControl" data-adjustment="contrast">
                    <span class="imageAdjustmentLabel">Contrast</span>
                    <input id="imageAdjustContrast" class="stealthSlider imageAdjustmentSlider" type="range" min="-100" max="100" step="1" value="0" aria-label="Adjust Contrast" />
                    <span class="imageAdjustmentValue" id="imageAdjustContrastValue">0</span>
                </div>
                <div class="imageAdjustmentControl" data-adjustment="vibrance">
                    <span class="imageAdjustmentLabel">Vibrance</span>
                    <input id="imageAdjustVibrance" class="stealthSlider imageAdjustmentSlider" type="range" min="-100" max="100" step="1" value="0" aria-label="Adjust Vibrance" />
                    <span class="imageAdjustmentValue" id="imageAdjustVibranceValue">0</span>
                </div>
                <div id="imageAdjustmentsBeforeAfter" class="disabled" role="button" tabindex="-1" aria-disabled="true" aria-pressed="false" title="Show Original View" aria-label="Show Original View">
                    <i class="fas fa-right-left"></i>
                    <span class="imageAdjustmentsToggleLabel" id="imageAdjustmentsBeforeAfterLabel">After</span>
                </div>
            </div>
        </div>

        <div id="relightPrompt" style="display:none;">
            <div class="relightPromptBox mini">
                <div id="closeRelightPromptBtn" class="relightPromptCloseBtn" title="Close">&times;</div>
                <button id="lbmStatusIndicator" class="lbmIndicatorBtn" title="LBM Model Status"></button>
                <div class="relightPromptTitle mini">Relight This FG Image?</div>
                <div class="relightPromptDesc mini">
                    Would you like to match background lighting?
                </div>
                <div class="relightPromptBtnRow">
                    <button id="relightYesBtn" class="relightPromptBtn miniSeafoamBtn">Relight</button>
                    <button id="relightNoBtn" class="relightPromptBtn miniNeutralBtn">As-Is</button>
                </div>
            </div>
        </div>
        <!-- MAIN AREA -->
        <div id="mainArea">
            <h1 id="mainHeader">
                Action Output: <span id="actionText"></span>
            </h1>
            <div id="homeImageContainer">
                <img id="homeImage" src="/lumify.png" alt="Lumify" />
            </div>
            <div id="canvasContainer">
                <div id="canvasWrapper">
                    <div id="canvasViewport">
                        <canvas id="canvas"></canvas>
                        <canvas id="overlayCanvas"></canvas>
                        <canvas id="sticker-3d-view" style="position:absolute;display:none;"></canvas>
                        <div id="sticker-3d-outline">
                            <div class="glb-flip glb-flip-left"><i class="fa-solid fa-right-left"></i></div>
                            <div class="glb-flip glb-flip-right"><i class="fa-solid fa-right-left"></i></div>
                            <div class="glb-handle glb-handle-nw"><i class="fa-solid fa-up-right-and-down-left-from-center"></i></div>
                            <div class="glb-handle glb-handle-ne"><i class="fa-solid fa-up-right-and-down-left-from-center"></i></div>
                            <div class="glb-handle glb-handle-sw"><i class="fa-solid fa-up-right-and-down-left-from-center"></i></div>
                            <div class="glb-handle glb-handle-se"><i class="fa-solid fa-up-right-and-down-left-from-center"></i></div>
                        </div>
                        <div id="sticker-3d-focusBtn" data-tip="Toggle visibility (focus)"></div>

                        <div class="stScaleGui" id="fg-scale-gui">
                            <div id="scaleBtn" title="Scale"><i class="fas fa-expand-arrows-alt"></i></div>
                            <div id="moveBtn" title="Move"><i class="fas fa-arrows-alt"></i></div>
                        </div>
                    </div>

                    <div id="stickerActionDrawer"></div>

                    <div id="comfyDock" style="position:fixed;right:14px;bottom:14px;z-index:10060;display:flex;gap:10px;align-items:center;background:#15181d;border:1px solid #2b2f35;border-radius:6px;padding:6px 10px;">
                        <div id="comfyDot" style="width:8px;height:8px;border-radius:50%;background:#ef5350;"></div>
                        <button id="comfyToggle" class="modelFocusBtn on" title="Disconnect / Connect" style="min-width:18px;min-height:18px;"></button>
                        <div id="comfyDockText" style="color:#cfd8dc;font-size:13px;">Comfy UI offline</div>
                    </div>

                    <!-- MATERIAL (Flux Kontext) WORKFLOW HUD -->
                    <div id="workflowMaterialHUD" class="workflowHUDBox materialHUD-compact" style="display:none;">
                        <div class="hudTitleBar" id="workflowMaterialHUDTitle">
                            <span><i style="color: var(--hud-accent-2); margin-right:6px">🎨</i> MATERIAL WORKFLOW</span>
                            <span class="hudCloseBtn" id="closeMaterialHUDBtn" data-close="workflowMaterialHUD">✕</span>
                        </div>

                        <!-- Material Type / Preset -->
                        <section class="hudSection">
                            <div class="hudSectionBody">
                                <div class="fieldRow" style="display:flex; flex-direction:column; align-items:center; text-align:center;">
                                    <div class="label">Material Type</div>
                                    <div class="pillSelect">
                                        <div class="pill">
                                            <select id="matTypeSelect">
                                                <option value="plastic">Plastic</option>
                                                <option value="metal">Metal</option>
                                                <option value="wood">Wood</option>
                                                <option value="fabric">Fabric</option>
                                                <option value="ceramic">Ceramic</option>
                                                <option value="stone">Stone</option>
                                                <option value="leather">Leather</option>
                                                <option value="glass">Glass</option>
                                                <option value="carbon fiber">Carbon Fiber</option>
                                            </select>
                                        </div>
                                    </div>
                                </div>
                                <div class="fieldRow" style="display:flex; flex-direction:column; align-items:center; text-align:center;">
                                    <div class="label">Material Preset</div>
                                    <div class="pillSelect">
                                        <div class="pill">
                                            <select id="matPresetSelect">
                                                <option value="">None</option>
                                                <option value="brushed_aluminum">Brushed Aluminum</option>
                                                <option value="polished_chrome">Polished Chrome</option>
                                                <option value="anodized_aluminum">Anodized Aluminum</option>
                                                <option value="oiled_leather">Oiled Leather</option>
                                                <option value="boucle_fabric">Bouclé Fabric</option>
                                                <option value="velvet">Velvet</option>
                                                <option value="distressed_wood">Distressed Wood</option>
                                                <option value="polished_marble">Polished Marble</option>
                                                <option value="ceramic_tile">Ceramic Tile</option>
                                                <option value="carbon_fiber">Carbon Fiber</option>
                                            </select>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </section>

                        <!-- Color -->
                        <section class="hudSection">
                            <div class="hudSectionBody centerSection">
                                <div class="label">Value</div>
                                <div class="matBtnGroup" id="matValRow">
                                    <button class="matToggle" data-value="light">Light</button>
                                    <button class="matToggle active" data-value="neutral">Neutral</button>
                                    <button class="matToggle" data-value="dark">Dark</button>
                                </div>
                                <div class="label">Saturation</div>
                                <div class="matBtnGroup" id="matSatRow">
                                    <button class="matToggle" data-sat="desat">Desaturated</button>
                                    <button class="matToggle active" data-sat="neutral">Neutral</button>
                                    <button class="matToggle" data-sat="sat">Saturated</button>
                                </div>
                                <div class="label">Hue</div>
                                <div class="hueStrip" id="matHueStrip">
                                    <div class="sw" data-hue="red" style="background:#e74c3c"></div>
                                    <div class="sw" data-hue="orange" style="background:#f39c12"></div>
                                    <div class="sw" data-hue="yellow" style="background:#f1c40f"></div>
                                    <div class="sw" data-hue="chartreuse" style="background:#2ecc71"></div>
                                    <div class="sw" data-hue="green" style="background:#27ae60"></div>
                                    <div class="sw" data-hue="teal" style="background:#16a085"></div>
                                    <div class="sw" data-hue="cyan" style="background:#1abc9c"></div>
                                    <div class="sw" data-hue="azure" style="background:#3498db"></div>
                                    <div class="sw" data-hue="blue" style="background:#2980b9"></div>
                                    <div class="sw" data-hue="violet" style="background:#8e44ad"></div>
                                    <div class="sw" data-hue="magenta" style="background:#9b59b6"></div>
                                    <div class="sw" data-hue="rose" style="background:#e91e63"></div>
                                </div>
                                <div class="label" id="matColorPreview" style="margin-top:8px">Current color phrase: <em>neutral neutral</em></div>
                            </div>
                        </section>

                        <!-- Prompt / Sliders / Seed -->
                        <section class="hudSection">
                            <div class="hudSectionHeader">Advanced Prompt</div>
                            <div class="hudSectionBody collapsed">
                                <div class="fieldRow" style="align-items:start">
                                    <div class="label" style="padding-top:6px">Prompt</div>
                                    <textarea id="matPrompt" class="darkInput" placeholder="Describe surface/finish…"></textarea>
                                </div>
                                <div class="sliderRow">
                                    <div class="label">Shiny/Matte</div>
                                    <input id="matReflectSlider" type="range" min="0" max="100" step="5" value="50">
                                    <div id="matReflectValue" class="readout">0.50</div>
                                </div>
                                <div class="sliderRow">
                                    <div class="label">Texture Detail</div>
                                    <input id="matDetailSlider" type="range" min="0" max="5" step="1" value="2">
                                    <div id="matDetailValue" class="readout">2</div>
                                </div>
                                <div class="sliderRow">
                                    <div class="label">Steps</div>
                                    <input id="matStepsSlider" type="range" min="4" max="16" step="1" value="8">
                                    <div id="matStepsValue" class="readout">8</div>
                                </div>
                                <div class="seedRow">
                                    <div class="label">Seed</div>
                                    <button id="matSeedLock" class="iconBtn" title="unlock/lock">🔓</button>
                                    <div class="pill" style="max-width:150px">
                                        <select id="matSeedSelect" class="seedSelect">
                                            <option value="random">Random</option>
                                            <option>12345</option>
                                            <option>24601</option>
                                        </select>
                                    </div>
                                </div>

                            </div>
                        </section>
                        <div class="buttonHudRow">
                            <button id="generateMaterialBtn" class="generatorImgBtn"><i class="fas fa-bolt"></i> Generate Material</button>
                        </div>

                    </div>
                    <!-- Over the canvas -->
                    <div id="canvasSpinnerOverlay">
                        <div class="spinner"></div>
                    </div>

                    <div id="processBarWrapper">
                        <div id="processBar"></div>
                    </div>
                    <!-- resize handle -->
                    <div id="bgFilename"><span id="bgFilenameText"></span><span id="beforeAfterLabel"></span><i id="canvasBeforeLock" class="fas fa-crosshairs historyFocusIcon"></i></div>
                    <div class="buttonHudRow" id="buttonHudRow">
                        <button id="cancelModelBtn" class="hudCancelBtn" title="Cancel Running Model/Process" style="display:none;">
                            <i class="fas fa-times-circle"></i>
                        </button>
                        <button id="imgCaptionBtn" class="buttonHudIcon" title="Generate Caption">
                            <i class="fas fa-quote-right"></i>
                        </button>
                        <button id="sendToSequencerBtn" class="buttonHudIcon" title="Send to Sequence">
                            <i class="fas fa-clapperboard"></i>
                        </button>
                        <button id="beforeAfterBtn" class="buttonHudIcon" title="Show Before" style="display:none;">
                            <i class="fas fa-right-left"></i>
                        </button>
                        <button id="downloadCanvasBtn" class="buttonHudIcon" title="Download Canvas">
                            <i class="fas fa-download"></i>
                        </button>
                        <div id="canvasResizer" title="Drag to resize">
                            <svg viewBox="0 0 24 24">
                                <polyline points="6,18 18,6" />
                                <polyline points="10,18 18,10" />
                                <polyline points="14,18 18,14" />
                            </svg>
                            <div id="canvasRestore" title="Restore Canvas & HUD"></div>
                        </div>
                        <div id="canvasResizerLeft" title="Drag to resize">
                            <svg viewBox="0 0 24 24">
                                <polyline points="6,18 18,6" />
                                <polyline points="10,18 18,10" />
                                <polyline points="14,18 18,14" />
                            </svg>
                            <div id="canvasRestoreLeft" title="Restore Canvas & HUD"></div>
                        </div>
                    </div>
                    <div class="captionBarContainer" id="captionBarContainer" style="display:none;">
                        <span class="captionIcon"><i class="fas fa-quote-left"></i></span>
                        <span class="captionText" id="captionText">No caption yet.</span>
                        <button class="captionCopyBtn" id="captionCopyBtn" title="Copy Caption" style="display:none;">
                            <i class="fas fa-copy"></i>
                        </button>
                    </div>
                    <div id="historyPanelToggle" title="Show session history">
                        <i class="fas fa-clock-rotate-left"></i>
                    </div>
                    <div id="workflowsTab" title="Workflows">
                        <i class="fas fa-project-diagram"></i>
                        <div id="workflowsDrawer">
                            <button id="workflowDrawer3DBtn" class="buttonHudIcon" title="3D HUD">
                                <i class="fas fa-cube"></i>
                            </button>
                            <button id="workflowDrawerVideoBtn" class="buttonHudIcon" title="Video HUD">
                                <i class="fas fa-video"></i>
                            </button>
                            <button id="workflowDrawerStylizeBtn" class="buttonHudIcon" title="Stylize HUD">
                                <i class="fa-solid fa-spray-can"></i>
                            </button>
                            <button id="workflowDrawerTimeBtn" class="buttonHudIcon" title="Time of Day HUD">
                                <i class="fa-solid fa-cloud-sun"></i>
                            </button>
                            <button id="workflowDrawerLightingBtn" class="buttonHudIcon" title="Composite HUD">
                                <i class="fas fa-lightbulb"></i>
                            </button>
                            <button id="workflowDrawerMaterialBtn" class="buttonHudIcon" title="Material HUD">
                                <i class="fas fa-gem"></i>
                            </button>
                            <button id="workflowDrawerImageBtn" class="buttonHudIcon" title="Image HUD">
                                <i class="fas fa-image"></i>
                            </button>
                            <button id="workflowDrawerCameraBtn" class="buttonHudIcon" title="Camera HUD">
                                <i class="fa-solid fa-camera-rotate"></i>
                            </button>
                            <button id="workflowDrawerPromptBtn" class="buttonHudIcon" title="Prompt HUD">
                                <i class="fas fa-keyboard"></i>
                            </button>
                            <button id="workflowDrawerRecentBtn" class="buttonHudIcon" title="Recent Images">
                                <i class="fas fa-code"></i>
                            </button>
                        </div>
                    </div>
                </div>
                <div id="historyPanel" class="frostedHistoryPanel closed">
                    <div class="historyPanelHeader">
                        <span class="historyTitle">Session History</span>
                        <div class="historyPanelHeaderBtnRow">
                            <button id="toggleHideFgBtn" class="historyFgToggleBtn" data-tip="Toggle FG Visibility">
                                <i class="fas fa-eye"></i>
                            </button>
                            <button id="historyModeToggle" class="historyModeToggleBtn" data-tip="Show video history">
                                <i class="fas fa-video"></i>
                            </button>
                            <button id="closeHistoryPanel" class="historyCloseBtn" data-tip="Close History Panel">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                    </div>
                    <div class="historyThumbsWrapper">
                        <div id="historyThumbs" class="historyThumbs"></div>
                        <div id="historyScrollControls" class="historyScrollControls" aria-hidden="true">
                            <button id="historyScrollUp" class="historyScrollArrow up" type="button" aria-label="Scroll up">
                                <i class="fas fa-chevron-up"></i>
                            </button>
                            <button id="historyScrollDown" class="historyScrollArrow down" type="button" aria-label="Scroll down">
                                <i class="fas fa-chevron-down"></i>
                            </button>
                        </div>
                    </div>
                    <div class="historyPanelFooter">
                        <button id="clearHistoryBtn" class="historyClearBtn" title="Clear History">
                            <i class="fas fa-trash-alt"></i>
                        </button>
                    </div>
                </div>


                <!-- Prompt Box Overlay or Container -->
                <div id="homePromptContainer">
                    <div id="bgHoverArea" title="Upload BG from Computer"></div>
                    <div id="homePromptInner">
                        <span id="promptCloseBtn">&times;</span>

                        <!-- toggle button -->
                        <div id="promptParamToggle" title="Settings" class="noDrag">
                            <i class="fas fa-sliders-h"></i>
                        </div>

                        <!-- hidden drawer -->
                        <div id="promptParamDrawer" class="noDrag">

                            <!-- ⬇ Resolution –‑ Flux only -->
                            <div class="paramRow" id="paramResolutionRow" style="display:none;">
                                <i class="fas fa-expand-arrows-alt" data-tip="Output Resolution"></i>
                                <select id="paramResolution" class="darkInput" style="width:90px;cursor:pointer;">
                                    <option value="512x512" selected>512×512</option>
                                    <option value="1024x1024">1024×1024</option>
                                    <option value="1024x512">1024×512</option>
                                    <option value="768x384">768×384</option>
                                    <option value="960x544">960×544</option>
                                    <option value="1024x576">1024x576</option>
                                    <option value="1360x768">1360x768</option>
                                </select>
                            </div>

                            <!-- ⬇ Creative Power –‑ SD Img‑to‑Img only -->
                            <div class="paramRow" id="paramCreativeRow">
                                <i class="fas fa-wand-magic-sparkles" data-tip="Creative Power"></i>
                                <input id="paramCreative" class="paramInput"
                                       type="number" step="0.1" min="0.1" max="1" value="0.2">
                            </div>

                            <div class="paramRow">
                                <i class="fas fa-bullseye" data-tip="Prompt Power"></i>
                                <input id="paramPrompt" class="paramInput"
                                       type="number" step="0.5" min="1" max="30" value="7">
                            </div>

                            <div class="paramRow">
                                <i class="fas fa-forward-fast" data-tip="Sampling Steps"></i>
                                <input id="paramSteps" class="paramInput"
                                       type="number" step="1" min="1" max="75" value="4">
                            </div>

                            <div class="paramRow seedRow" data-tip="Lock Seed">
                                <label style="position:relative; cursor:pointer;">
                                    <input id="paramSeedLock" type="checkbox" class="lockSeedCheckbox">
                                    <span class="lockSeedCircle"></span>
                                </label>
                                <input id="paramSeed" class="paramInput" type="number" value="0">
                            </div>

                        </div>
                        <h1 id="promptHudModeLabel">Generate With Text2Image</h1>

                        <div id="promptBoxRow" class="noDrag">
                            <textarea id="homePromptInput"
                                      placeholder="Describe your idea…"
                                      rows="1"
                                      style="resize:none; overflow:hidden;"></textarea>

                            <!-- Model dropdown always present; we toggle its .style.display in JS -->
                            <select id="homePromptModelSelect">
                                <!--<option value="sd15" selected>SD 1.5</option>-->
                                <option value="sd21" selected>SD 2.1</option>
                                <option value="sdxl">SDXL</option>
                                <option value="sdxl-inpaint">SDXL + InPaint</option>
                                <option value="flux">Kontext</option>
                            </select>

                            <button id="homeGenerateBtn">
                                <i class="fas fa-bolt"></i> Generate
                            </button>
                        </div>

                        <p id="homePromptCaption">
                            Type a prompt and create a new image or click above to import an image
                        </p>
                    </div>
                </div>
            </div>
            <div id="sequencerHudContainer" style="display: none;">
                <div class="sequencerHudBar">
                    <span class="sequencerHudTitle">
                        <i class="fas fa-film"></i> Sequence
                    </span>
                    <button id="closeSequencerHudBtn" class="sequencerHudCloseBtn" title="Close">
                        <i class="fas fa-times"></i>
                    </button>
                    <div id="sequencerThumbs" class="sequencerThumbs"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- SAMPLES OVERLAY -->
    <div id="samplesOverlay" style="display:none;">
        <div id="samplesBox">
            <div id="closeSamplesBtn"><i class="fas fa-times"></i></div>
            <img id="samplesImage" src="" alt="sample" />
            <button id="useSampleBtn" class="relightPromptBtn useBGGlowBtn">Use This Image</button>
            <div class="samplesArrow" id="samplesArrowLeft"><i class="fas fa-chevron-left"></i></div>
            <div class="samplesArrow" id="samplesArrowRight"><i class="fas fa-chevron-right"></i></div>
        </div>
    </div>

    <!-- GALLERY OVERLAY -->
    <div id="galleryOverlay">
        <div id="galleryControls">
            <div id="galleryControlsTop">
                <input id="gallerySizeSlider" type="range" min="0.5" max="2" step="0.1" value="1" title="Gallery Size" aria-label="Gallery Size" />
                <div id="closeGalleryBtn"><i class="fa-solid fa-xmark"></i></div>
            </div>
            <button id="galleryCollectionsToggle" type="button">Collections</button>
        </div>
        <div id="galleryHeader">Gallery Library</div>
        <div id="galleryGrid"></div>
    </div>

    <div id="flipBookOverlay">
        <!-- Close Button -->
        <div id="closeFlipBookBtn">
            <i class="fas fa-times"></i>
        </div>

        <!-- Optional Header -->
        <div id="flipBookHeader">FlipBook Library</div>

        <!-- Main scroll area with up/down arrows -->
        <div id="flipBookScrollArea">
            <div class="flipBookScrollControls">
                <div id="flipBookArrowUp" class="flipBookArrow">
                    <i class="fas fa-chevron-up"></i>
                </div>
                <div id="flipBookImportTop" class="flipBookImportBtn">
                    <i class="fa-solid fa-file-import"></i>
                </div>
            </div>

            <div id="flipBookImagesWrapper">
                <!-- Dynamically populated by JS -->
            </div>

            <div class="flipBookScrollControls">
                <div id="flipBookArrowDown" class="flipBookArrow">
                    <i class="fas fa-chevron-down"></i>
                </div>
                <div id="flipBookImportBottom" class="flipBookImportBtn">
                    <i class="fa-solid fa-file-import"></i>
                </div>
            </div>
        </div>
    </div>

    <div id="assetsOverlay">
        <!-- Close Button -->
        <div id="closeAssetsBtn">
            <i class="fas fa-times"></i>
        </div>

        <!-- Optional Header -->
        <div id="assetsHeader">Assets Library</div>

        <!-- Main scroll area with up/down arrows -->
        <div id="assetsScrollArea">
            <div class="assetsScrollControls">
                <div id="assetsArrowUp" class="assetsArrow">
                    <i class="fas fa-chevron-up"></i>
                </div>
                <div id="assetsImportTop" class="assetsImportBtn">
                    <i class="fa-solid fa-file-import"></i>
                </div>
            </div>

            <div id="assetsImagesWrapper">
                <!-- Dynamically populated by JS -->
            </div>

            <div class="assetsScrollControls">
                <div id="assetsArrowDown" class="assetsArrow">
                    <i class="fas fa-chevron-down"></i>
                </div>
                <div id="assetsImportBottom" class="assetsImportBtn">
                    <i class="fa-solid fa-file-import"></i>
                </div>
            </div>
        </div>
    </div>

    <div id="recentOverlay">
        <div id="closeRecentBtn">
            <i class="fas fa-times"></i>
        </div>
        <div id="recentHeader">Recent Images</div>
        <div id="recentScrollArea">
            <div id="recentArrowUp" class="flipBookArrow">
                <i class="fas fa-chevron-up"></i>
            </div>
            <div id="recentImagesWrapper">
            </div>
            <div id="recentArrowDown" class="flipBookArrow">
                <i class="fas fa-chevron-down"></i>
            </div>
        </div>
    </div>

    <!-- ENHANCE PREVIEW OVERLAY -->
    <div id="enhancePreviewOverlay">
        <div id="enhancePreviewBox">
            <img id="enhancePreviewImg" src="" alt="enhanced preview" />
            <button id="downloadEnhancePreviewBtn" class="buttonHudIcon" title="Download Enhanced">
                <i class="fas fa-download"></i>
            </button>
            <div id="fullscreenEnhancePreviewBtn"><i class="fas fa-expand"></i></div>
            <div id="closeEnhancePreviewBtn"><i class="fas fa-times"></i></div>
        </div>
    </div>

    <!-- SETTINGS OVERLAY -->
    <div id="settingsOverlay">
        <div id="settingsBox">
            <div id="restoreDefaultsBtn" title="Restore default settings">
                <i class="fas fa-undo-alt"></i>
            </div>
            <div id="closeSettingsBtn" title="Close Settings">
                <i class="fas fa-times"></i>
            </div>
            <h2>App Settings</h2>
            <div class="settingsScrollable">
                <!-- Masking / SAM -->
                <div class="settingsSection">
                    <h3>Masking (SAM)</h3>
                    <label for="samModelSelect">SAM Model Preference:</label>
                    <select id="samModelSelect">
                        <option value="vit_b">ViT-B</option>
                        <option value="vit_l" selected>ViT-L</option>
                        <option value="vit_h">ViT-H</option>
                    </select>
                </div>
                <!-- Image Generation -->
                <div class="settingsSection">
                    <h3>
                        Image Generation
                        <!--<i id="sdImg2ImgHudBtn" class="fas fa-bolt launchIcon" title="Run Img2Img Generation"></i>-->
                    </h3>
                    <label for="imgGenModelSelect">ImgGen Model:</label>
                    <select id="imgGenModelSelect">
                        <option value="stable" selected>Stable Diffusion</option>
                        <option value="flux">Flux</option>
                        <option value="lightning">Lightning</option>
                    </select>
                    <label for="imgGenStrength">Strength Value</label>
                    <div class="sliderRow">
                        <input type="range" id="imgGenStrength" min="0.1" max="1" step="0.1" value="0.2" />
                        <span class="sliderValue" id="strengthValueLabel">0.2</span>
                    </div>
                    <label for="imgGenGuidance">Guidance Scale</label>
                    <div class="sliderRow">
                        <input type="range" id="imgGenGuidance" min="1" max="30" step="1" value="7" />
                        <span class="sliderValue" id="guidanceValueLabel">7</span>
                    </div>
                    <label for="imgGenSteps">Inference Steps</label>
                    <div class="sliderRow">
                        <input type="range" id="imgGenSteps" min="20" max="75" step="1" value="30" />
                        <span class="sliderValue" id="stepsValueLabel">30</span>
                    </div>
                </div>
                <!-- 3D Generation -->
                <!--<div class="settingsSection">
                    <h3>
                        3D Generation
                        <i id="threeDGenLaunchIcon" class="fas fa-cube launchIcon" title="Open 3DGen HUD"></i>
                    </h3>
                    <label for="threedModelSelect">Shape Pipeline:</label>
                    <select id="threedModelSelect">
                        <option value="mini" selected>Hunyuan3D-2mini (fast)</option>
                        <option value="full">Hunyuan3D-2 (high quality)</option>
                    </select>
                </div>-->
                <!-- Enhance -->
                <div class="settingsSection">
                    <h3>
                        Enhance
                        <i id="enhanceLaunchIcon" class="fas fa-wand-magic-sparkles launchIcon" title="Run Enhancement"></i>
                    </h3>
                    <label for="enhanceStrengthSlider">Enhance Strength</label>
                    <div class="sliderRow">
                        <input type="range" id="enhanceStrengthSlider" min="0" max="1" step="0.05" value="0.8" />
                        <span class="sliderValue" id="enhanceStrengthLabel">0.8</span>
                    </div>
                </div>
                <div class="settingsSection">
                    <h3>Text to Image</h3>

                    <!-- 1) Text2Img Model -->
                    <label for="txt2ImgModelSelect">Text2Img Model:</label>
                    <select id="txt2ImgModelSelect">
                        <!-- You can have more options if desired, but here's just the single requested model -->
                        <option value="flux_schnell" selected>Flux.1 schnell</option>
                    </select>

                    <!-- 2) Resolution -->
                    <label for="txt2ImgResolution">Resolution:</label>
                    <select id="txt2ImgResolution">
                        <option value="512x512" selected>512x512</option>
                        <option value="1024x1024">1024x1024</option>
                        <option value="1024x512">1024x512</option>
                        <option value="768x384">768x384</option>
                        <option value="960x544">960x544</option>
                        <option value="1024x576">1024x576</option>
                        <option value="1360x768">1360x768</option>
                    </select>

                    <!-- 3) Inference Steps & Guidance Scale -->
                    <label for="txt2ImgGuidance">Guidance Scale</label>
                    <div class="sliderRow">
                        <input type="range" id="txt2ImgGuidance" min="1" max="20" step="1" value="5" />
                        <span class="sliderValue" id="txt2ImgGuidanceVal">5</span>
                    </div>

                    <label for="txt2ImgSteps">Inference Steps</label>
                    <div class="sliderRow">
                        <input type="range" id="txt2ImgSteps" min="1" max="40" step="1" value="2" />
                        <span class="sliderValue" id="txt2ImgStepsVal">2</span>
                    </div>
                </div>
                <!-- Image Caption -->
                <!--<div class="settingsSection">
                    <h3>Image Caption</h3>
                    <label for="captionModelSelect">Caption Model:</label>
                    <select id="captionModelSelect">
                        <option value="blip2" selected>BLIP2</option>
                        <option value="llava">LLaVA</option>
                        <option value="joycaption">JoyCaption</option>
                    </select>
                </div>-->
                <!-- Video / Animation -->
                <div class="settingsSection">
                    <h3>Video / Animation</h3>
                    <label for="img2VideoPrompt">Img2Video Prompt:</label>
                    <input type="text" id="img2VideoPrompt" placeholder="Enter text prompt..." />
                    <label for="img2VideoStyle">Img2Video Style:</label>
                    <input type="text" id="img2VideoStyle" placeholder="Describe desired style..." />
                </div>
            </div>
            <div id="scrollArrowsRow">
                <div id="scrollUpBtn"><i class="fas fa-angle-up"></i></div>
                <div id="scrollDownBtn"><i class="fas fa-angle-down"></i></div>
            </div>
            <div class="settingsActions">
                <button id="saveSettingsBtn">Save</button>
                <button id="cancelSettingsBtn">Cancel</button>
            </div>
        </div>
    </div>

    <!-- 3D WORKFLOW HUD -->
    <div id="workflow3DHUD" class="workflowHUDBox materialHUD-compact" style="display:none; top:200px; left:500px;">
        <div class="hudTitleBar" id="workflow3DHUDTitle">
            <span style="font-size:15px; font-weight:600;">
                <i class="fas fa-cube" style="color: #cc9687; margin-right: 6px; "></i>
                3D WORKFLOW
            </span>
            <span id="close3DHUD" class="hudCloseBtn">X</span>
        </div>
        <!--<div class="hudSection">
            <div class="hudSectionHeader">
                <span>Shape Pipeline</span>
            </div>
            <div class="hudSectionBody" style="display: flex; flex-direction: column; gap: 8px;">
                <label for="threedModelSelectHud" style="font-size: 13px;">
                    Choose pipeline:
                </label>
                <select id="threedModelSelectHud" style="font-size: 13px;">
                    <option value="mini" selected>Hunyuan3D-2mini (fast)</option>
                    <option value="full">Hunyuan3D-2 (high quality)</option>
                </select>
            </div>
        </div>-->
        <div class="hudSection">
            <div class="hudSectionBody" style="display:flex; gap:12px; justify-content:space-between;">
                <button id="shapeOnlyBtn" class="generator3dBtn" title="Generate 3D Shape">
                    <i class="fas fa-cube"></i>
                    <span>Shape Only</span>
                </button>
                <button id="shapeAndTexBtn" class="generator3dBtn" title="Generate Shape + Texture">
                    <i class="fas fa-paint-brush"></i>
                    <span>Shape + Texture</span>
                </button>
            </div>
        </div>
        <div class="hudSection">
            <div class="hudSectionHeader">
                <span>Quality</span>
            </div>
            <div class="hudSectionBody" style="display:flex; flex-direction:column; gap:8px;">
                <label style="font-size:13px; margin-bottom:8px;">Speed <span style="float:right;">Quality</span></label>
                <div id="shapeQualitySlider" class="notched-slider"></div>
                <div id="shapeQualityLabel" style="text-align:center;font-size:13px; color:#ccebff; margin-top:2px;"></div>
            </div>
        </div>

        <div class="hudSection">
            <div class="hudSectionHeader">
                <span>Smoothing</span>
            </div>
            <div class="hudSectionBody" style="display:flex; flex-direction:column; gap:8px;">
                <label style="font-size:13px; margin-bottom:8px;">Rigid <span style="float:right;">Smooth</span></label>
                <div id="smoothingSlider" class="notched-slider"></div>
                <div id="smoothingLabel" style="text-align:center;font-size:13px; color:#ccebff; margin-top:2px;"></div>
            </div>
        </div>
    </div>

    <!-- VIDEO WORKFLOW HUD -->
    <div id="workflowVideoHUD" class="workflowHUDBox" style="display:none; top:470px; left:500px;">
        <div class="hudTitleBar" id="workflowVideoHUDTitle">
            <span style="font-size:15px; font-weight:600;">
                <i class="fas fa-video" style="color: #99ff99; margin-right: 6px; "></i>
                VIDEO WORKFLOW
            </span>
            <span id="closeVideoHUD" class="hudCloseBtn">X</span>
        </div>
        <div class="hudSection">
            <div class="hudSectionHeader">
                <span>Video Options</span>
            </div>
            <div class="hudSectionBody" style="display:flex; flex-direction:column; gap:8px;">
                <label for="videoStyleSelectHud" style="font-size:13px;">Video Style:</label>
                <select id="videoStyleSelectHud" style="font-size:13px;">
                    <option value="slow-mo">Slow Motion</option>
                    <option value="truck-right">Truck Right</option>
                    <option value="truck-left">Truck Left</option>
                    <option value="dolly-right">Dolly Right</option>
                    <option value="dolly-left">Dolly Left</option>
                    <option value="pan-right">Pan Right</option>
                    <option value="tilt-up">Tilt Up</option>
                    <option value="tilt-down">Tilt Down</option>
                    <option value="static-cam">Static Cam</option>
                    <option value="cine-zoom">Cinematic Zoom</option>
                    <option value="cine-reveal">Cinematic Reveal</option>
                    <!--<option value="pose-anim">Animation</option>-->
                </select>
                <label for="videoPromptHud" style="font-size:16px;">Prompt:</label>
                <input type="text" id="videoPromptHud" style="background: #1f1f1f; color: #eee; font-size: 13px;" placeholder="Describe style..." autocomplete="off" />
            </div>
        </div>
        <div class="hudSection">
            <div class="hudSectionHeader">
                <span>Generators</span>
                <div class="sectionFocusBtn"></div>
            </div>
            <div class="hudSectionBody" style="display:flex; flex-wrap:wrap; gap:6px;">
                <button id="img2VideoBtn" class="generator3dBtn" title="Img2Video">
                    <i class="fas fa-video"></i>
                    <span>Image2Video</span>
                </button>
                <button id="frames2VideoBtn" class="generator3dBtn" title="Frames2Video">
                    <i class="fas fa-video"></i>
                    <span>Frames2Video</span>
                </button>
            </div>
        </div>
    </div>

    <!-- LIGHTING (Flux Kontext) WORKFLOW HUD -->
    <div id="workflowLightingHUD" class="workflowHUDBox materialHUD-compact" style="display:none; top:330px; left:500px;">
        <div class="hudTitleBar" id="workflowLightingHUDTitle">
            <span style="font-size:15px; font-weight:600;">
                <i class="fas fa-lightbulb" style="color: #e5b85c; margin-right: 6px; "></i>
                LUMIFY
            </span>
            <span id="closeLightingHUD" class="hudCloseBtn">X</span>
        </div>

        <div class="hudScrollArea">
            <section class="hudSection">
                <div class="hudSectionBody">
                    <div class="buttonHudRow styleIconRow" role="group" aria-label="Rendering style">
                        <button class="buttonHudIcon styleIconButton active"
                                data-style="photo" title="Realistic Photograph" aria-pressed="true">
                            <i class="fas fa-camera"></i>
                        </button>
                        <button class="buttonHudIcon styleIconButton"
                                data-style="painterly" title="Painterly Artwork" aria-pressed="false">
                            <i class="fas fa-palette"></i>
                        </button>
                        <button class="buttonHudIcon styleIconButton"
                                data-style="cinematic" title="Cinematic Style" aria-pressed="false">
                            <i class="fas fa-film"></i>
                        </button>
                        <button class="buttonHudIcon styleIconButton"
                                data-style="hyperreal" title="Hyper‑realistic" aria-pressed="false">
                            <i class="fas fa-star"></i>
                        </button>
                    </div>
                    <div id="lightingStyleDisplay" aria-live="polite"></div>
                </div>
            </section>
            <div class="hudSection kontextToggleSection" id="lightingKontextToggles">
                <div class="hudSectionBody">
                    <div class="kontextToggleRow">
                        <div class="kontextToggle">
                            <span class="kontextToggleLabel">Align</span>
                            <button type="button" id="lightingAlignToggle" class="kontextToggleBtn" data-setting="align" aria-pressed="false" aria-label="Toggle align (ECC)" title="Toggle align (ECC)"></button>
                        </div>
                        <div class="kontextToggle">
                            <span class="kontextToggleLabel">Use Depth</span>
                            <button type="button" id="lightingDepthToggle" class="kontextToggleBtn" data-setting="depth" aria-pressed="false" aria-label="Toggle depth guidance" title="Toggle depth guidance"></button>
                        </div>
                        <div class="kontextToggle">
                            <span class="kontextToggleLabel">Full Res</span>
                            <button type="button" id="lightingFullResToggle" class="kontextToggleBtn" data-setting="fullRes" aria-pressed="false" aria-label="Toggle full resolution processing" title="Toggle full resolution processing"></button>
                        </div>
                    </div>
                </div>
            </div>
            <div class="hudSection">
                <div class="hudSectionHeader">Advanced Prompt</div>
                <div class="hudSectionBody collapsed" style="display:flex; flex-direction:column; gap:12px;">
                    <div class="fieldRow" style="display:flex; flex-direction:column; gap:6px;">
                        <div class="label">Prompt</div>
                        <input id="fluxPromptInput" class="darkInput" type="text" placeholder="Optional: additional descriptors…" />
                    </div>
                    <div class="sliderRow">
                        <div class="label">Guidance</div>
                        <input id="fluxGuidance" type="range" min="1.0" max="2.5" step="0.1" value="1.8" class="stealthSlider" />
                        <div class="readout" id="fluxGuidanceVal">1.8</div>
                    </div>
                    <div class="sliderRow">
                        <div class="label">Steps</div>
                        <input id="fluxSteps" type="range" min="4" max="48" step="1" value="16" class="stealthSlider" />
                        <div class="readout" id="fluxStepsVal">16</div>
                    </div>
                    <div class="seedRow">
                        <div class="label">Seed</div>
                        <button id="fluxSeedLock" class="iconBtn" title="unlock/lock">🔓</button>
                        <div class="pill" style="max-width:150px">
                            <select id="fluxSeedSelect" class="seedSelect">
                                <option value="random">Random</option>
                                <option>12345</option>
                                <option>24601</option>
                            </select>
                        </div>
                    </div>
                </div>
            </div>
            <div class="buttonHudRow">
                <button id="runFluxKontextBtn" class="generatorImgBtn">
                    <i class="fas fa-bolt"></i> Generate Integration
                </button>
            </div>
        </div>
    </div>

    <!-- TIME OF DAY WORKFLOW HUD -->
    <div id="workflowTimeOfDayHUD" class="workflowHUDBox materialHUD-compact" style="display:none; top:330px; left:710px;">
        <div class="hudTitleBar" id="workflowTimeOfDayHUDTitle">
            <span style="font-size:15px; font-weight:600;">
                <i class="fa-solid fa-cloud-sun" style="color:#f5d17a; margin-right:6px;"></i>
                TIME OF DAY
            </span>
            <span id="closeTimeOfDayHUD" class="hudCloseBtn">X</span>
        </div>

        <div class="hudScrollArea">
            <!-- Time of Day selection -->
            <div class="hudSection">
                <div class="hudSectionBody" style="display:flex; flex-direction:column; align-items:center; gap:10px;">
                    <div class="hudSectionBody todTint" id="todTintPane">

                        <!-- (unchanged) icons row -->
                        <div class="buttonHudRow todIconRow" role="group" aria-label="Time of Day">
                            <button class="buttonHudIcon todIconButton" data-tod="golden_am" title="Golden AM" aria-pressed="false"><i class="fa-solid fa-sun"></i></button>
                            <button class="buttonHudIcon todIconButton" data-tod="midday" title="Midday" aria-pressed="false"><i class="fa-solid fa-cloud-sun"></i></button>
                            <button class="buttonHudIcon todIconButton" data-tod="overcast" title="Overcast" aria-pressed="false"><i class="fas fa-cloud"></i></button>
                            <button class="buttonHudIcon todIconButton" data-tod="blue_hour" title="Blue Hour" aria-pressed="false"><i class="fas fa-cloud-moon"></i></button>
                            <button class="buttonHudIcon todIconButton" data-tod="sunset" title="Sunset" aria-pressed="false"><i class="fa-regular fa-sun"></i></button>
                            <button class="buttonHudIcon todIconButton" data-tod="night" title="Night" aria-pressed="false"><i class="fas fa-moon"></i></button>
                        </div>
                        <div id="todDaypartLabel" style="font-size:14px; font-weight:700; text-align:center; width:100%; text-transform:uppercase;"></div>
                        <div id="todDaypartDisplay" style="font-size:13px; font-weight:600; text-align:center; width:100%;"></div>
                    </div>
                </div>
            </div>

            <!-- Extras and Sweeteners -->
            <div class="hudSection">
                <div class="hudSectionHeader active">Refinement</div>
                <div class="hudSectionBody" style="display:flex; flex-direction:column; align-items:center; gap:12px;">

                    <!-- Keep your hidden select for compatibility (JS keeps it in sync) -->
                    <select id="todSweetenerSelect" class="darkInput" multiple>
                        <option value="match-sky" selected>Match Sky</option>
                        <option value="match-shadows" selected>Match Shadows</option>
                        <option value="mist">Mist</option>
                        <option value="godrays">God Rays</option>
                        <option value="longShadows">Long Shadows</option>
                        <option value="volumetric">Volumetric</option>
                        <option value="warm">Warm Bias</option>
                        <option value="cool">Cool Bias</option>
                    </select>

                    <!-- New compact dropdown -->
                    <div class="pillSelectRow" style="align-items:center;">
                        <label class="qualityLabel">Add sweeteners</label>
                        <div id="todExtrasControl" class="pillSelect" role="combobox" aria-expanded="false" aria-controls="todExtrasMenu">
                            <button id="todExtrasToggle" type="button" aria-label="Choose extras">Choose extras</button>
                            <div id="todExtrasMenu" role="listbox" aria-multiselectable="true"></div>
                        </div>
                    </div>

                    <!-- Selected chips / quick remove -->
                    <div id="todExtrasSummary" aria-live="polite"></div>

                    <div class="hudInnerSeparator"></div>
                    <!-- Centered INTENSITY slider (gentle — value — strong) -->
                    <div class="qualityBlock" aria-label="Extras Intensity">
                        <div class="qualityLabel">Refinement Intensity</div>
                        <div class="rangeRow" style="width:min(420px,92%);">
                            <span class="rangeSideLabel">gentle</span>
                            <input id="todIntensity" class="stealthSlider" type="range" min="0" max="100" step="5" value="55" />
                            <span class="rangeSideLabel">strong</span>
                        </div>
                        <div class="rangeValue" id="todIntensityValue">55</div>
                    </div>
                </div>
            </div>

            <!-- Advanced Prompt -->
            <div class="hudSection kontextToggleSection" id="todKontextToggles">
                <div class="hudSectionBody">
                    <div class="kontextToggleRow">
                        <div class="kontextToggle">
                            <span class="kontextToggleLabel">Align</span>
                            <button type="button" id="todAlignToggle" class="kontextToggleBtn" data-setting="align" aria-pressed="false" aria-label="Toggle align (ECC)" title="Toggle align (ECC)"></button>
                        </div>
                        <div class="kontextToggle">
                            <span class="kontextToggleLabel">Use Depth</span>
                            <button type="button" id="todDepthToggle" class="kontextToggleBtn" data-setting="depth" aria-pressed="false" aria-label="Toggle depth guidance" title="Toggle depth guidance"></button>
                        </div>
                        <div class="kontextToggle">
                            <span class="kontextToggleLabel">Full Res</span>
                            <button type="button" id="todFullResToggle" class="kontextToggleBtn" data-setting="fullRes" aria-pressed="false" aria-label="Toggle full resolution processing" title="Toggle full resolution processing"></button>
                        </div>
                    </div>
                </div>
            </div>
            <div class="hudSection">
                <div class="hudSectionHeader">Advanced Prompt</div>
                <div class="hudSectionBody collapsed" style="display:flex; flex-direction:column; gap:12px;">
                    <textarea id="todPromptInput" class="darkInput" rows="3" placeholder="Optional: additional descriptors…"></textarea>

                    <div class="sliderRow">
                        <div class="label">Guidance</div>
                        <input id="todGuidance" class="stealthSlider" type="range" min="1.0" max="3.0" step="0.1" value="1.8" />
                        <div class="readout" id="todGuidanceVal">1.8</div>
                    </div>

                    <!-- Steps: label left, centered slider, value right -->
                    <div class="matSliderRow" style="grid-template-columns: 1fr; row-gap: 0;">
                        <div style="display:grid; grid-template-columns: auto 1fr auto; align-items:center; width:min(420px,92%); margin:0 auto;">
                            <div class="inlineLabel" style="justify-self:start;">Steps</div>
                            <input id="todSteps" class="stealthSlider" type="range" min="4" max="48" step="1" value="16" />
                            <div id="todStepsVal" class="matSliderReadout" style="justify-content:flex-end; width:auto; margin:0 0 0 8px;">16</div>
                        </div>
                    </div>

                    <!-- Seed lock identical to Material HUD -->
                    <div class="seedRow">
                        <button id="todSeedLock" class="iconBtn" title="unlock/lock">🔓</button>
                        <div class="pill" style="max-width:150px">
                            <select id="todSeedSelect" class="seedSelect">
                                <option value="random">Random</option>
                                <option>12345</option>
                                <option>24601</option>
                            </select>
                        </div>
                    </div>
                </div>
            </div>
            <div class="buttonHudRow">
                <button id="runTimeOfDayBtn" class="generatorImgBtn">
                    <i class="fas fa-bolt"></i> Apply Time of Day
                </button>
            </div>
        </div>
    </div>

    <!-- STYLIZE WORKFLOW HUD -->
    <div id="workflowStylizeHUD" class="workflowHUDBox materialHUD-compact" style="display:none; top:330px; left:920px;">
        <div class="hudTitleBar" id="workflowStylizeHUDTitle">
            <span style="font-size:15px; font-weight:600;">
                <i class="fa-solid fa-brush" style="color:#f5d17a; margin-right:6px;"></i>
                STYLIZE
            </span>
            <span id="closeStylizeHUD" class="hudCloseBtn">X</span>
        </div>

        <div class="hudScrollArea">
            <!-- Mode Buttons -->
            <div class="hudSection">
                <div class="hudSectionBody" style="display:flex; flex-direction:column; align-items:center; gap:10px;">
                    <div class="buttonHudRow stylizeIconRow" role="group" aria-label="Stylize Actions">
                        <button class="buttonHudIcon stylizeIconButton active" data-mode="style-transfer" title="Style Transfer" aria-pressed="true"><i class="fa-solid fa-paint-brush"></i></button>
                        <button class="buttonHudIcon stylizeIconButton" data-mode="refine" title="Refine" aria-pressed="false"><i class="fa-solid fa-wand-magic-sparkles"></i></button>
                        <button class="buttonHudIcon stylizeIconButton" data-mode="add-item" title="Add Item" aria-pressed="false"><i class="fa-solid fa-plus"></i></button>
                        <button class="buttonHudIcon stylizeIconButton" data-mode="remove-item" title="Remove Item" aria-pressed="false"><i class="fa-solid fa-eraser"></i></button>
                    </div>
                    <div id="stylizeModeLabel" style="font-size:14px; font-weight:700; text-align:center; width:100%; text-transform:uppercase;"></div>
                    <div id="stylizeModeDisplay" style="font-size:13px; font-weight:600; text-align:center; width:100%;"></div>
                </div>
            </div>

            <!-- Reference Image Upload -->
            <div class="hudSection">
                <div class="hudSectionHeader">Reference Image</div>
                <div class="hudSectionBody" style="display:flex; flex-direction:column; align-items:center; gap:12px;">
                    <div id="stylizeImageDrop" class="dropZone">
                        <i class="fa-solid fa-image"></i>
                        <input id="stylizeImageInput" type="file" accept="image/*" style="display:none" />
                    </div>
                </div>
            </div>

            <!-- Style Transfer Controls (visible only in Style Transfer mode) -->
            <div class="hudSection" id="styleTransferControls">
                <div class="hudSectionHeader active">Style Transfer</div>
                <div class="hudSectionBody" style="display:flex; flex-direction:column; gap:8px;">

                    <div class="sliderRow compactRow">
                        <div class="label">Palette</div>
                        <input id="stylePalette" class="stealthSlider" type="range" min="0" max="100" step="1" value="70" />
                        <div class="readout" id="stylePaletteVal">70</div>
                    </div>

                    <div class="sliderRow compactRow">
                        <div class="label">Texture</div>
                        <input id="styleTexture" class="stealthSlider" type="range" min="0" max="100" step="1" value="60" />
                        <div class="readout" id="styleTextureVal">60</div>
                    </div>

                    <div class="sliderRow compactRow">
                        <div class="label">Line</div>
                        <input id="styleLine" class="stealthSlider" type="range" min="0" max="100" step="1" value="40" />
                        <div class="readout" id="styleLineVal">40</div>
                    </div>

                    <label style="display:flex; align-items:center; gap:8px; margin-top:6px; user-select:none;">
                        <input id="styleLightingLock" type="checkbox" checked />
                        Keep original lighting (lock luminance/shadows)
                    </label>

                </div>
            </div>

            <!-- Refinement and Descriptors -->
            <div class="hudSection">
                <div class="hudSectionHeader active">Refinement</div>
                <div class="hudSectionBody" style="display:flex; flex-direction:column; align-items:center; gap:12px;">
                    <select id="stylizeDescriptorSelect" class="darkInput" multiple>
                        <option value="character-consistency" selected>Character Consistency</option>
                        <option value="style-matching" selected>Style Matching</option>
                        <option value="local-editing">Local Editing</option>
                        <option value="background-harmony">Background Harmony</option>
                    </select>

                    <div class="pillSelectRow" style="align-items:center;">
                        <label class="qualityLabel">Add descriptors</label>
                        <div id="stylizeExtrasControl" class="pillSelect" role="combobox" aria-expanded="false" aria-controls="stylizeExtrasMenu">
                            <button id="stylizeExtrasToggle" type="button" aria-label="Choose descriptors">Choose descriptors</button>
                            <div id="stylizeExtrasMenu" role="listbox" aria-multiselectable="true"></div>
                        </div>
                    </div>

                    <div id="stylizeExtrasSummary" aria-live="polite"></div>

                    <div class="hudInnerSeparator"></div>
                    <div class="qualityBlock" aria-label="Descriptor Intensity">
                        <div class="qualityLabel">Refinement Intensity</div>
                        <div class="rangeRow" style="width:min(420px,92%);">
                            <span class="rangeSideLabel">gentle</span>
                            <input id="stylizeIntensity" class="stealthSlider" type="range" min="0" max="100" step="5" value="50" />
                            <span class="rangeSideLabel">strong</span>
                        </div>
                        <div class="rangeValue" id="stylizeIntensityValue">50</div>
                    </div>
                </div>
            </div>

            <!-- Advanced Prompt -->
            <div class="hudSection">
                <div class="hudSectionHeader">Advanced Prompt</div>
                <div class="hudSectionBody collapsed" style="display:flex; flex-direction:column; gap:12px;">
                    <textarea id="stylizePromptInput" class="darkInput" rows="3" placeholder="Optional: additional descriptors…"></textarea>

                    <div class="sliderRow">
                        <div class="label">Guidance</div>
                        <input id="stylizeGuidance" class="stealthSlider" type="range" min="1.0" max="3.0" step="0.1" value="1.8" />
                        <div class="readout" id="stylizeGuidanceVal">1.8</div>
                    </div>

                    <div class="matSliderRow" style="grid-template-columns: 1fr; row-gap: 0;">
                        <div style="display:grid; grid-template-columns: auto 1fr auto; align-items:center; width:min(420px,92%); margin:0 auto;">
                            <div class="inlineLabel" style="justify-self:start;">Steps</div>
                            <input id="stylizeSteps" class="stealthSlider" type="range" min="4" max="48" step="1" value="16" />
                            <div id="stylizeStepsVal" class="matSliderReadout" style="justify-content:flex-end; width:auto; margin:0 0 0 8px;">8</div>
                        </div>
                    </div>

                    <div class="seedRow">
                        <button id="stylizeSeedLock" class="iconBtn" title="unlock/lock">🔓</button>
                        <div class="pill" style="max-width:150px">
                            <select id="stylizeSeedSelect" class="seedSelect">
                                <option value="random">Random</option>
                                <option>12345</option>
                                <option>24601</option>
                            </select>
                        </div>
                    </div>
                </div>
            </div>

            <div class="buttonHudRow">
                <button id="runStylizeBtn" class="generatorImgBtn">
                    <i class="fas fa-bolt"></i> Apply Stylization
                </button>
            </div>
        </div>
    </div>

    <!-- Camera HUD) -->
    <div id="workflowCameraHUD" class="workflowHUDBox materialHUD-compact cameraHUDv3"
         style="display:none; top:220px; left:860px;">
        <div class="hudTitleBar" id="workflowCameraHUDTitle">
            <span style="font-size:15px; font-weight:600;">
                <i class="fas fa-camera-rotate" style="color:#7fe7cc; margin-right:6px;"></i>
                CAMERA
            </span>
            <span id="closeCameraHUD" class="hudCloseBtn">X</span>
        </div>

        <div class="hudScrollArea">
            <!-- Section 1: pad + tweaks (compact) -->
            <section class="hudSection" style="padding:12px 14px 14px;">
                <div class="camHUD-wrap">
                    <!-- Left: camera pad -->
                    <div class="camHUD-card camHUD-padCard">
                        <div class="camHUD-padHeader">
                            <div class="camHUD-padTitle">Camera Pad</div>
                        </div>
                        <div class="camHUD-padSurface">
                            <button class="camHUD-cornerBtn camActionBtn top-left" data-action="zoom_out" title="Zoom Out" aria-label="Zoom Out">
                                <i class="fas fa-magnifying-glass-minus"></i>
                            </button>
                            <button class="camHUD-cornerBtn camActionBtn top-right" data-action="zoom_in" title="Zoom In" aria-label="Zoom In">
                                <i class="fas fa-magnifying-glass-plus"></i>
                            </button>
                            <button class="camHUD-cornerBtn camActionBtn bottom-left" data-action="roll_left" title="Roll Left" aria-label="Roll Left">
                                <i class="fas fa-undo"></i>
                            </button>
                            <button class="camHUD-cornerBtn camActionBtn bottom-right" data-action="roll_right" title="Roll Right" aria-label="Roll Right">
                                <i class="fas fa-redo"></i>
                            </button>
                            <div class="camHUD-grid">
                                <!-- row 1 -->
                                <div></div>
                                <button class="camHUD-btn camActionBtn" data-action="tilt_up" title="Tilt Up" aria-label="Tilt Up">
                                    <i class="fas fa-angle-up"></i>
                                </button>
                                <div></div>
                                <!-- row 2 -->
                                <button class="camHUD-btn camActionBtn" data-action="pan_left" title="Pan Left" aria-label="Pan Left">
                                    <i class="fas fa-angle-left"></i>
                                </button>
                                <button class="camHUD-btn camActionBtn center" data-action="recenter" title="Recenter" aria-label="Recenter">
                                    <i class="fas fa-crosshairs"></i>
                                </button>
                                <button class="camHUD-btn camActionBtn" data-action="pan_right" title="Pan Right" aria-label="Pan Right">
                                    <i class="fas fa-angle-right"></i>
                                </button>
                                <!-- row 3 -->
                                <div></div>
                                <button class="camHUD-btn camActionBtn" data-action="tilt_down" title="Tilt Down" aria-label="Tilt Down">
                                    <i class="fas fa-angle-down"></i>
                                </button>
                                <div></div>
                            </div>
                        </div>
                    </div>

                    <!-- Right: tweaks / expose-reveal -->
                    <div class="camHUD-card camHUD-reveal" id="camRevealPane" aria-live="polite">
                        <div class="camHUD-revealHeader">
                            <div class="camHUD-title" id="camRevealTitle">Camera Tweaks</div>
                            <div class="camHUD-toggleRow">
                                <label class="camHUD-switch">
                                    <input id="camUseDegrees" type="checkbox" checked />
                                    <span class="pill"></span><span class="lbl">Degrees</span>
                                </label>
                                <label class="camHUD-switch">
                                    <input id="camFovTweak" type="checkbox" />
                                    <span class="pill"></span><span class="lbl">FOV</span>
                                </label>
                            </div>
                        </div>

                        <div class="camHUD-currentAction" id="camSelectedMove">Choose a camera move</div>

                        <div class="camHUD-sliderWrap" id="camValueControl">
                            <div class="camHUD-sliderHeader">
                                <span class="camHUD-sliderLabel" id="camSliderLabel">Value</span>
                                <span class="camHUD-sliderValue" id="camSelectedValue">—</span>
                            </div>
                            <div class="camHUD-sliderBody" id="camSliderBody"></div>
                        </div>

                        <div class="camHUD-lockRow">
                            <label class="camHUD-switch">
                                <input id="camSubjectLock" type="checkbox" checked />
                                <span class="pill"></span><span class="lbl">Focus Lock</span>
                            </label>
                        </div>
                    </div>
                </div>
                <div class="camHUD-actionLabel" id="cameraActionLabel">
                    <div class="camHUD-actionPrimary" id="camActionPrimary">Choose a camera move</div>
                    <div class="camHUD-actionSecondary" id="camActionSecondary">Pick a control on the pad to reveal its settings.</div>
                </div>
            </section>

            <!-- Section 2: Advanced Prompt (collapsed by default) -->
            <section class="hudSection">
                <div class="hudSectionHeader" id="cameraAdvHeader">Advanced Prompt</div>
                <div class="hudSectionBody collapsed" id="cameraAdvBody" style="display:flex; flex-direction:column; gap:12px;">
                    <div class="fieldRow" style="display:flex; flex-direction:column; gap:6px;">
                        <div class="label">Extra Prompt</div>
                        <input id="cameraAdvPrompt" class="darkInput" type="text" placeholder="Optional: extra descriptors…" />
                    </div>
                    <div class="sliderRow">
                        <div class="label">Guidance</div>
                        <input id="cameraGuidance" type="range" min="1.0" max="2.5" step="0.1" value="1.8" class="stealthSlider" />
                        <div class="readout" id="cameraGuidanceVal">1.8</div>
                    </div>
                    <div class="sliderRow">
                        <div class="label">Steps</div>
                        <input id="cameraSteps" type="range" min="4" max="48" step="1" value="16" class="stealthSlider" />
                        <div class="readout" id="cameraStepsVal">16</div>
                    </div>
                    <div class="seedRow">
                        <div class="label">Seed</div>
                        <button id="cameraSeedLock" class="iconBtn" aria-pressed="false" title="Lock seed">🔓</button>
                        <div class="pill" style="max-width:150px">
                            <select id="cameraSeedSelect" class="seedSelect">
                                <option value="random">Random</option>
                                <option>12345</option>
                                <option>24601</option>
                            </select>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Section 3: Apply -->
            <div class="hudSection">
                <div class="hudSectionBody" style="display:flex; justify-content:center;">
                    <button id="runCameraKontextBtn" class="generatorImgBtn" title="Apply camera to background">
                        <i class="fas fa-bolt"></i> Apply Camera Adjustments
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- IMAGE WORKFLOW HUD -->
    <div id="workflowImageHUD" class="workflowHUDBox materialHUD-compact" style="display:none; top:220px; left: 130px;">
        <div class="hudTitleBar" id="workflowImageHUDTitle">
            <span style="font-size:15px; font-weight:600;">
                <i class="fas fa-image" style="color: #6dc2ed; margin-right: 6px; "></i>
                IMAGE WORKFLOW
            </span>
            <span id="closeImageHUD" class="hudCloseBtn">X</span>
        </div>

        <div class="hudScrollArea">
            <div class="hudSection">
                <div class="hudSectionBody"
                     style="display:grid; grid-template-columns: repeat(3, 1fr); grid-gap:12px 10px; justify-items:stretch;">
                    <button id="computeDepthHudBtn" class="generatorImgBtn" title="Compute Depth">
                        <i class="fas fa-water"></i>
                        <span>Depth</span>
                    </button>
                    <button id="i2iGenerateBtn" class="generatorImgBtn" title="Img2Img">
                        <i class="fas fa-clone"></i>
                        <span>Img2Img</span>
                    </button>
                    <button id="sdDepth2ImgBtn" class="generatorImgBtn" title="Depth2Img">
                        <i class="fas fa-layer-group"></i>
                        <span>Depth2Img</span>
                    </button>
                    <button id="enhanceLaunchIconHud" class="generatorImgBtn" title="Enhance Image">
                        <i class="fas fa-wand-magic-sparkles"></i>
                        <span>Enhance</span>
                    </button>
                    <button id="generateMaskIconHud" class="generatorImgBtn" title="Generate Mask">
                        <i class="fas fa-mask"></i>
                        <span>Mask</span>
                    </button>
                </div>
            </div>

            <!-- MASKING (SAM) -->
            <div class="hudSection">
                <div class="hudSectionHeader" id="sectionHeaderSamMask">
                    <span>SAM Mask</span>
                    <i class="fas fa-mask launchIcon"
                       style="right:8px;"
                       title="Run Generate Mask"
                       id="generateMaskIcon"></i>

                    <div class="sectionFocusBtn"></div>
                </div>
                <div class="hudSectionBody" style="display:flex; flex-direction:column; gap:8px;">
                    <div>
                        <label for="samModelSelectHud" style="display:block; margin-bottom:4px; font-size:13px;">
                            SAM Model
                        </label>
                        <select id="samModelSelectHud" style="width:50%;">
                            <option value="vit_b">ViT-B</option>
                            <option value="vit_l" selected>ViT-L</option>
                            <option value="vit_h">ViT-H</option>
                        </select>
                    </div>
                    <div style="display:flex; flex-wrap:wrap; gap:7px;">
                        <button id="toggleModeBtn" class="workflowGhostBtn">
                            <span>BG/FG</span>
                            <i class="fas fa-random"></i>
                        </button>
                        <button id="clickModeBtn" class="workflowGhostBtn">
                            <span>Click Mode</span>
                            <i class="fas fa-mouse-pointer"></i>
                        </button>
                        <button id="invertMaskBtn" class="workflowGhostBtn">
                            <span>Invert</span>
                            <i class="fas fa-exchange-alt"></i>
                        </button>
                    </div>

                    <div style="border-top:1px solid #444; padding-top:10px; margin-top:4px;">
                        <div style="display:flex; align-items:center; gap:6px; margin-bottom:6px;">
                            <span style="font-weight:400; font-size:14px;">Refine Mask</span>
                            <i class="fas fa-edit" style="color:#aaa;"></i>

                            <i id="toggleRefineMaskBtn"
                               class="fas fa-eye"
                               style="position: absolute; right: 0; top: 8; cursor: pointer; padding: 22px; font-size: 12px"
                               title="Toggle Mask Overlay">
                            </i>
                        </div>
                        <div class="stealthSliderWrapper">
                            <div class="stealthSliderLabel">Opacity</div>
                            <input type="range" min="0" max="1" step="0.1" value="0.5" class="stealthSlider" id="maskOpacitySlider">
                            <span class="stealthSliderValue" id="maskOpacityVal">0.5</span>
                        </div>
                        <div class="stealthSliderWrapper">
                            <div class="stealthSliderLabel">Dilation</div>
                            <input type="range" min="-50" max="50" step="0.1" value="0" class="stealthSlider" id="maskDilationSlider">
                            <span class="stealthSliderValue" id="maskDilationVal">0.0</span>
                        </div>
                        <div class="stealthSliderWrapper">
                            <div class="stealthSliderLabel">Blur</div>
                            <input type="range" min="0" max="10" step="1" value="0" class="stealthSlider" id="maskBlurSlider">
                            <span class="stealthSliderValue" id="maskBlurVal">0</span>
                        </div>
                        <div style="display:flex; gap:7px; margin-top:7px;">
                            <button id="applyRefineBtn" class="workflowGhostBtn" style="flex:1;">
                                <span>Apply</span>
                                <i class="fas fa-check"></i>
                            </button>
                            <button id="clearMaskBtn" class="workflowGhostBtn" style="flex:1;">
                                <span>Clear</span>
                                <i class="fas fa-ban"></i>
                            </button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- IMAGE GENERATION (renamed to Image 2 Image) -->
            <div class="hudSection">
                <div class="hudSectionHeader" id="sectionHeaderImg2Img">
                    <span>Img2Img</span>
                    <i id="sdImg2ImgHudBtn"
                       class="fas fa-layer-group launchIcon"
                       style="right:8px;"
                       title="Run Image to Image"></i>

                    <div class="sectionFocusBtn"></div>
                </div>
                <div class="hudSectionBody" style="display:flex; flex-direction:column; gap:8px;">

                    <!-- Model Dropdown -->
                    <label for="i2iModelSelect" style="margin-bottom:4px;">Model Choice:</label>
                    <select id="i2iModelSelect">
                        <option value="sd15" selected>Stable Diffusion 1.5</option>
                        <option value="sd21">Stable Diffusion 2.1</option>
                        <option value="flux">Flux.1</option>
                    </select>

                    <!--<label for="i2iResolution">Resolution</label>
                    <select id="i2iResolution">
                        <option value="512x512" selected>512×512</option>
                        <option value="768x768">768×768</option>
                        <option value="1024x1024">1024×1024</option>
                        <option value="512x768">512×768 (portrait)</option>
                        <option value="768x512">768×512 (landscape)</option>
                    </select>-->
                    <!-- Prompt & Negative Prompt -->
                    <label for="i2iPromptInput" style="margin-top:10px;">Prompt</label>
                    <input type="text"
                           id="i2iPromptInput"
                           class="darkInput"
                           placeholder="Describe your idea…"
                           style="width: 90%;" />

                    <label for="i2iNegativePromptInput" style="margin-top:10px;">Negative Prompt</label>
                    <input type="text"
                           id="i2iNegativePromptInput"
                           class="darkInput"
                           placeholder="What to avoid…"
                           style="width: 90%;" />

                    <!-- Creative Power (strength) => 0..1 -->
                    <div class="sliderRow compactRow" style="margin-top:10px;">
                        <label>Creative Power</label>
                        <input type="range"
                               id="i2iCreativePower"
                               min="0"
                               max="1"
                               step="0.1"
                               value="0.6"
                               class="stealthSlider"
                               title="0 = minimal changes; 1 = drastic changes from init image" />
                        <span class="stealthSliderValue" id="i2iCreativePowerVal">0.6</span>
                    </div>

                    <!-- Prompt Power (guidance) => 1..10 -->
                    <div class="sliderRow compactRow">
                        <label>Prompt Power</label>
                        <input type="range"
                               id="i2iPromptPower"
                               min="1"
                               max="10"
                               step="0.5"
                               value="7.5"
                               class="stealthSlider"
                               title="How strongly to follow your prompt" />
                        <span class="stealthSliderValue" id="i2iPromptPowerVal">7.5</span>
                    </div>

                    <!-- Steps => 10..80 -->
                    <div class="sliderRow compactRow">
                        <label>Steps</label>
                        <input type="range"
                               id="i2iSteps"
                               min="10"
                               max="80"
                               step="1"
                               value="30"
                               class="stealthSlider"
                               title="Sampling Steps" />
                        <span class="stealthSliderValue" id="i2iStepsVal">30</span>
                    </div>

                    <!-- Lock Seed Toggle -->
                    <div class="seedLockContainer">
                        <!-- Hidden checkbox for true/false logic -->
                        <input type="checkbox" id="lockSeedCheckbox" class="lockSeedCheckbox" />

                        <!-- The circle label that fills in if checked -->
                        <label for="lockSeedCheckbox" class="lockSeedCircle"></label>

                        <span class="lockSeedLabel">Lock Seed</span>

                        <!-- The numeric seed input -->
                        <input type="number" id="seedInput" class="darkInput seedInput" value="0" />
                    </div>
                </div>
            </div>
            <!-- Depth 2 Image -->
            <div class="hudSection">
                <div class="hudSectionHeader" id="sectionHeaderDepth2Img">
                    <span>Depth2Img</span>
                    <!-- Use a water icon or something similar -->
                    <i id="sdDepth2ImgHudBtn"
                       class="fas fa-layer-group launchIcon"
                       style="right:8px;"
                       title="Run Depth2Image">
                    </i>

                    <div class="sectionFocusBtn"></div>
                </div>
                <div class="hudSectionBody" style="display:flex; flex-direction:column; gap:8px;">

                    <!-- Prompt & Negative Prompt -->
                    <label for="d2iPromptInput" style="margin-top:10px;">Prompt</label>
                    <input type="text"
                           id="d2iPromptInput"
                           class="darkInput"
                           placeholder="Describe your idea…"
                           style="width: 90%;" />

                    <label for="d2iNegativePromptInput" style="margin-top:10px;">Negative Prompt</label>
                    <input type="text"
                           id="d2iNegativePromptInput"
                           class="darkInput"
                           placeholder="What to avoid…"
                           style="width: 90%;" />

                    <!-- Strength -->
                    <div class="sliderRow compactRow" style="margin-top:10px;">
                        <label>Depth Strength</label>
                        <input type="range"
                               id="d2iStrength"
                               min="0"
                               max="1"
                               step="0.1"
                               value="0.6"
                               class="stealthSlider"
                               title="0 = minimal change; 1 = big changes from the depth" />
                        <span class="stealthSliderValue" id="d2iStrengthVal">0.6</span>
                    </div>

                    <!-- Guidance -->
                    <div class="sliderRow compactRow">
                        <label>Prompt Power</label>
                        <input type="range"
                               id="d2iGuidance"
                               min="1"
                               max="10"
                               step="0.5"
                               value="7.5"
                               class="stealthSlider"
                               title="How strongly to follow your prompt" />
                        <span class="stealthSliderValue" id="d2iGuidanceVal">7.5</span>
                    </div>

                    <!-- Steps -->
                    <div class="sliderRow compactRow">
                        <label>Steps</label>
                        <input type="range"
                               id="d2iSteps"
                               min="10"
                               max="80"
                               step="1"
                               value="30"
                               class="stealthSlider"
                               title="Sampling Steps" />
                        <span class="stealthSliderValue" id="d2iStepsVal">30</span>
                    </div>
                    <div class="seedLockContainer">
                        <input type="checkbox" id="lockSeedCheckboxD2i" class="lockSeedCheckbox" />
                        <label for="lockSeedCheckboxD2i" class="lockSeedCircle"></label>
                        <span class="lockSeedLabel">Lock Seed</span>
                        <input type="number" id="seedInputD2i" class="darkInput seedInput" value="0" />
                    </div>
                </div>
            </div>

            <!-- ENHANCE -->
            <div class="hudSection">
                <div class="hudSectionHeader" id="sectionHeaderUpscale">
                    <span>Upscale</span>
                    <i id="enhanceLaunchIcon"
                       class="fas fa-wand-magic-sparkles launchIcon"
                       style="right:8px;"
                       title="Run Enhancement"></i>

                    <div class="sectionFocusBtn"></div>
                </div>
                <div class="hudSectionBody">
                    <div class="sliderRow compactRow">
                        <label>Strength</label>
                        <input type="range" id="enhanceStrengthHud" min="0" max="1" step="0.05" value="0.8" class="stealthSlider" />
                        <span class="stealthSliderValue" id="enhanceStrengthValHud">0.8</span>
                    </div>
                </div>
            </div>
            <div id="sliderCompareContainer" class="sliderCompare hidden">
                <div class="sliderTrack">
                    <img id="imgBefore" />
                    <div id="sliderHandle"></div>
                    <img id="imgAfter" />
                </div>
            </div>

            <!-- CAPTION -->
            <div class="hudSection">
                <div class="hudSectionHeader" id="sectionHeaderImage2Caption">
                    <span>Img2Caption</span>
                    <i id="captionRunIcon"
                       class="fas fa-comment-dots launchIcon"
                       style="right:8px;"></i>

                    <div class="sectionFocusBtn"></div>
                </div>
                <div class="hudSectionBody">
                    <button id="captionRunIconHud" class="darkBtn" title="Caption (LLaVA)">
                        <i class="fas fa-comment-dots"></i>
                    </button>
                </div>
            </div>

            <!-- Hidden file inputs for BG/FG -->
            <label for="bgInput"><input type="file" id="bgInput" accept="image/*" /></label>
            <input type="file" id="fgImageInput" accept="image/*" style="display:none;" />
            <label for="fgAssetInput"><input type="file" id="fgAssetInput" accept="image/*,.glb,.gltf" style="display:none" /></label>
            <label for="fgFlipBookInput"><input type="file" id="fgFlipBookInput" accept="image/*" style="display:none" multiple /></label>

            <!-- OpenCV if needed -->
            <script src="https://docs.opencv.org/4.5.5/opencv.js"></script>

            <script>
                /******************************************************
                 * FULL JS (Consolidated to avoid redundant listeners)
                 ******************************************************/
                const FALLBACK_PLACEHOLDER_BASE64 =
                    "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAA" +
                    "AAfFcSJAAAADUlEQVR42mNk+M/wHwAFAAOFKN3K5QAAAABJRU5ErkJggg==";
                const MAX_CANVAS_W = 2048;
                const MAX_CANVAS_H = 2048;

                const canvas = document.getElementById("canvas");
                //const imageCursor = `url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='45' height='45' viewBox='0 0 512 512'%3E%3Cpath fill='%23ffffff' stroke='%2365c7ad' stroke-width='9' d='M464 448H48c-26.5 0-48-21.5-48-48V112c0-26.5 21.5-48 48-48h64l28.7-57.3A24 24 0 01162.7 0h186.6a24 24 0 0121.9 14.7L400 64h64c26.5 0 48 21.5 48 48v288c0 26.5-21.5 48-48 48zM176 96h160l-16-32H192l-16 32zm-48 96a48 48 0 100 96 48 48 0 000-96zm320 192l-96-128-64 80-48-64-128 160h336z'/%3E%3C/svg%3E") 24 24, auto`; const imageCursorBulb = `url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='30' height='30' viewBox='0 0 384 512'%3E%3Cpath fill='%23f5cd7d' d='M192 0C86 0 0 86 0 192c0 69 41 134 105 163l12 40h150l12-40c64-29 105-94 105-163C384 86 298 0 192 0zM96 480v16c0 8.8 7.2 16 16 16h160c8.8 0 16-7.2 16-16v-16H96z'/%3E%3C/svg%3E") 24 24, auto`;
                const ctx = canvas.getContext("2d");
                const overlayCanvas = document.getElementById("overlayCanvas");
                const overlayCtx = overlayCanvas.getContext("2d");

                const topNavBar = document.getElementById("topNavBar");
                const imageAdjustmentsBar = document.getElementById("imageAdjustmentsBar");
                const imageAdjustmentsToggle = document.getElementById("imageAdjustmentsToggle");
                const imageAdjustmentsRestore = document.getElementById("imageAdjustmentsRestore");
                const imageAdjustmentsBeforeAfter = document.getElementById("imageAdjustmentsBeforeAfter");
                const imageAdjustmentsBeforeAfterLabel = document.getElementById("imageAdjustmentsBeforeAfterLabel");
                const imageAdjustmentElements = {
                    exposure: {
                        slider: document.getElementById("imageAdjustExposure"),
                        valueEl: document.getElementById("imageAdjustExposureValue")
                    },
                    contrast: {
                        slider: document.getElementById("imageAdjustContrast"),
                        valueEl: document.getElementById("imageAdjustContrastValue")
                    },
                    vibrance: {
                        slider: document.getElementById("imageAdjustVibrance"),
                        valueEl: document.getElementById("imageAdjustVibranceValue")
                    }
                };

                const imageAdjustmentDefaults = {
                    exposure: 0,
                    contrast: 0,
                    vibrance: 0
                };

                const imageAdjustments = {
                    exposure: 0,
                    contrast: 0,
                    vibrance: 0
                };

                let isImageAdjustmentsPreviewBefore = false;

                function areImageAdjustmentsNeutral() {
                    return (
                        Math.abs(imageAdjustments.exposure - imageAdjustmentDefaults.exposure) < 0.0001 &&
                        Math.abs(imageAdjustments.contrast - imageAdjustmentDefaults.contrast) < 0.0001 &&
                        Math.abs(imageAdjustments.vibrance - imageAdjustmentDefaults.vibrance) < 0.0001
                    );
                }

                function formatImageAdjustmentValue(type, value) {
                    const safe = Math.abs(value) < 0.0001 ? 0 : value;
                    if (type === "exposure") {
                        const fixed = safe.toFixed(1);
                        if (safe > 0) return `+${fixed}`;
                        return fixed;
                    }
                    const rounded = Math.round(safe);
                    if (rounded === 0) return "0";
                    return rounded > 0 ? `+${rounded}` : `${rounded}`;
                }

                function updateImageAdjustmentUI(type, value) {
                    const entry = imageAdjustmentElements[type];
                    if (!entry) return;
                    if (entry.slider && entry.slider.value !== String(value)) {
                        entry.slider.value = value;
                    }
                    if (entry.valueEl) {
                        entry.valueEl.textContent = formatImageAdjustmentValue(type, value);
                    }
                }

                function updateImageAdjustmentsPreviewUI() {
                    if (!imageAdjustmentsBeforeAfter) return;
                    const hasAdjustments = !areImageAdjustmentsNeutral();
                    if (!hasAdjustments && isImageAdjustmentsPreviewBefore) {
                        isImageAdjustmentsPreviewBefore = false;
                    }
                    const active = hasAdjustments && isImageAdjustmentsPreviewBefore;
                    imageAdjustmentsBeforeAfter.classList.toggle("active", active);
                    imageAdjustmentsBeforeAfter.classList.toggle("disabled", !hasAdjustments);
                    imageAdjustmentsBeforeAfter.setAttribute("aria-pressed", active ? "true" : "false");
                    imageAdjustmentsBeforeAfter.setAttribute("aria-disabled", hasAdjustments ? "false" : "true");
                    imageAdjustmentsBeforeAfter.setAttribute(
                        "title",
                        active ? "Show Adjusted View" : "Show Original View"
                    );
                    imageAdjustmentsBeforeAfter.setAttribute(
                        "aria-label",
                        active ? "Show Adjusted View" : "Show Original View"
                    );
                    imageAdjustmentsBeforeAfter.setAttribute("tabindex", hasAdjustments ? "0" : "-1");
                    if (imageAdjustmentsBeforeAfterLabel) {
                        imageAdjustmentsBeforeAfterLabel.textContent = active ? "Before" : "After";
                    }
                }

                function refreshImageAdjustmentState() {
                    const active = !areImageAdjustmentsNeutral();
                    if (imageAdjustmentsBar) {
                        imageAdjustmentsBar.classList.toggle("has-adjustments", active);
                    }
                    if (imageAdjustmentsToggle) {
                        imageAdjustmentsToggle.classList.toggle("has-adjustments", active);
                    }
                    updateImageAdjustmentsPreviewUI();
                }

                function setImageAdjustmentsPreviewMode(previewBefore) {
                    const hasAdjustments = !areImageAdjustmentsNeutral();
                    const next = !!previewBefore && hasAdjustments;
                    if (isImageAdjustmentsPreviewBefore === next) {
                        updateImageAdjustmentsPreviewUI();
                        return;
                    }
                    isImageAdjustmentsPreviewBefore = next;
                    updateImageAdjustmentsPreviewUI();
                    if (typeof scheduleRedraw === "function") {
                        scheduleRedraw();
                    } else if (typeof drawCanvas === "function") {
                        drawCanvas();
                    }
                }

                function setImageAdjustment(type, rawValue, options = {}) {
                    const entry = imageAdjustmentElements[type];
                    if (!entry) return false;
                    const numeric = parseFloat(rawValue);
                    if (Number.isNaN(numeric)) return false;
                    let normalized = numeric;
                    if (type === "exposure") {
                        normalized = Math.round(numeric * 10) / 10;
                    } else {
                        normalized = Math.round(numeric);
                    }
                    const prev = imageAdjustments[type];
                    imageAdjustments[type] = normalized;
                    updateImageAdjustmentUI(type, normalized);
                    refreshImageAdjustmentState();
                    const changed = Math.abs(prev - normalized) > 0.0001;
                    if (changed && isImageAdjustmentsPreviewBefore) {
                        isImageAdjustmentsPreviewBefore = false;
                        updateImageAdjustmentsPreviewUI();
                    }
                    if (changed && options.schedule !== false) {
                        if (typeof scheduleRedraw === "function") {
                            scheduleRedraw();
                        } else if (typeof drawCanvas === "function") {
                            drawCanvas();
                        }
                    }
                    return changed;
                }

                function updateImageAdjustmentsBarPosition() {
                    if (!imageAdjustmentsBar) return;
                    let offset = 62;
                    if (topNavBar) {
                        const rect = topNavBar.getBoundingClientRect();
                        offset = rect.bottom;
                    }
                    const safeOffset = Math.max(offset, 0);
                    imageAdjustmentsBar.style.setProperty("--image-adjustments-top", `${safeOffset}px`);
                    imageAdjustmentsBar.style.top = `${safeOffset}px`;
                }

                function closeImageAdjustments() {
                    if (!imageAdjustmentsBar || !imageAdjustmentsBar.classList.contains("open")) return;
                    imageAdjustmentsBar.classList.remove("open");
                    imageAdjustmentsBar.setAttribute("aria-hidden", "true");
                    if (imageAdjustmentsToggle) {
                        imageAdjustmentsToggle.classList.remove("active");
                        imageAdjustmentsToggle.setAttribute("aria-expanded", "false");
                    }
                }

                function openImageAdjustments() {
                    if (!imageAdjustmentsBar || imageAdjustmentsBar.classList.contains("open")) return;
                    updateImageAdjustmentsBarPosition();
                    imageAdjustmentsBar.classList.add("open");
                    imageAdjustmentsBar.setAttribute("aria-hidden", "false");
                    if (imageAdjustmentsToggle) {
                        imageAdjustmentsToggle.classList.add("active");
                        imageAdjustmentsToggle.setAttribute("aria-expanded", "true");
                    }
                }

                if (imageAdjustmentsToggle && imageAdjustmentsBar) {
                    imageAdjustmentsToggle.addEventListener("click", e => {
                        e.preventDefault();
                        e.stopPropagation();
                        if (imageAdjustmentsBar.classList.contains("open")) {
                            closeImageAdjustments();
                        } else {
                            openImageAdjustments();
                        }
                    });
                    imageAdjustmentsToggle.addEventListener("keydown", e => {
                        if (e.key === "Enter" || e.key === " ") {
                            e.preventDefault();
                            imageAdjustmentsToggle.click();
                        }
                    });
                }

                Object.entries(imageAdjustmentElements).forEach(([type, entry]) => {
                    if (!entry || !entry.slider) return;
                    entry.slider.addEventListener("input", e => {
                        setImageAdjustment(type, e.target.value);
                    });
                });

                if (imageAdjustmentsBeforeAfter) {
                    const toggleImageAdjustmentsPreview = () => {
                        if (areImageAdjustmentsNeutral()) return;
                        setImageAdjustmentsPreviewMode(!isImageAdjustmentsPreviewBefore);
                    };
                    imageAdjustmentsBeforeAfter.addEventListener("click", e => {
                        e.preventDefault();
                        e.stopPropagation();
                        toggleImageAdjustmentsPreview();
                    });
                    imageAdjustmentsBeforeAfter.addEventListener("keydown", e => {
                        if (e.key === "Enter" || e.key === " ") {
                            e.preventDefault();
                            toggleImageAdjustmentsPreview();
                        }
                    });
                }

                if (imageAdjustmentsRestore) {
                    const resetAllAdjustments = () => {
                        let changed = false;
                        Object.entries(imageAdjustmentDefaults).forEach(([type, defaultValue]) => {
                            const entry = imageAdjustmentElements[type];
                            if (entry?.slider) entry.slider.value = defaultValue;
                            changed = setImageAdjustment(type, defaultValue, { schedule: false }) || changed;
                        });
                        refreshImageAdjustmentState();
                        if (changed) {
                            if (typeof scheduleRedraw === "function") {
                                scheduleRedraw();
                            } else if (typeof drawCanvas === "function") {
                                drawCanvas();
                            }
                        }
                    };
                    imageAdjustmentsRestore.addEventListener("click", resetAllAdjustments);
                    imageAdjustmentsRestore.addEventListener("keydown", e => {
                        if (e.key === "Enter" || e.key === " ") {
                            e.preventDefault();
                            resetAllAdjustments();
                        }
                    });
                }

                if (imageAdjustmentsBar) {
                    imageAdjustmentsBar.addEventListener("click", e => e.stopPropagation());
                }

                document.addEventListener("click", e => {
                    if (!imageAdjustmentsBar || !imageAdjustmentsBar.classList.contains("open")) return;
                    if (imageAdjustmentsBar.contains(e.target)) return;
                    if (imageAdjustmentsToggle && imageAdjustmentsToggle.contains(e.target)) return;
                    closeImageAdjustments();
                });

                document.addEventListener("keydown", e => {
                    if (e.key === "Escape") closeImageAdjustments();
                });

                Object.entries(imageAdjustments).forEach(([type, value]) => {
                    updateImageAdjustmentUI(type, value);
                });
                refreshImageAdjustmentState();
                updateImageAdjustmentsBarPosition();

                window.addEventListener("resize", updateImageAdjustmentsBarPosition);
                if (typeof ResizeObserver === "function" && topNavBar) {
                    const navResizeObserver = new ResizeObserver(() => updateImageAdjustmentsBarPosition());
                    navResizeObserver.observe(topNavBar);
                }

                function applyImageAdjustmentsToCanvas(can, context, options = {}) {
                    if (!can || !context) return;
                    applyImageAdjustmentsToContext(context, can.width, can.height, options);
                }

                function applyImageAdjustmentsToContext(context, width, height, options = {}) {
                    if (!context || !width || !height) return;
                    if (areImageAdjustmentsNeutral()) return;
                    if (isImageAdjustmentsPreviewBefore && !options.force) return;
                    try {
                        const imageData = context.getImageData(0, 0, width, height);
                        applyImageAdjustmentsToImageData(imageData);
                        context.putImageData(imageData, 0, 0);
                    } catch (err) {
                        console.warn("Global image adjustments skipped", err);
                    }
                }

                function applyImageAdjustmentsToImageData(imageData) {
                    if (!imageData) return;
                    const data = imageData.data;
                    const exp = imageAdjustments.exposure;
                    const contrast = imageAdjustments.contrast;
                    const vibrance = imageAdjustments.vibrance;

                    const exposureEnabled = Math.abs(exp) > 0.0001;
                    const contrastEnabled = Math.abs(contrast) > 0.0001;
                    const vibranceEnabled = Math.abs(vibrance) > 0.0001;

                    if (!exposureEnabled && !contrastEnabled && !vibranceEnabled) return;

                    const exposureFactor = exposureEnabled ? Math.pow(2, exp) : 1;
                    const contrastFactor = contrastEnabled ? Math.max(0, 1 + contrast / 100) : 1;
                    const vibranceAmount = vibranceEnabled ? vibrance / 100 : 0;

                    for (let i = 0; i < data.length; i += 4) {
                        let r = data[i] / 255;
                        let g = data[i + 1] / 255;
                        let b = data[i + 2] / 255;

                        if (exposureEnabled) {
                            r = clamp01(r * exposureFactor);
                            g = clamp01(g * exposureFactor);
                            b = clamp01(b * exposureFactor);
                        }

                        if (contrastEnabled) {
                            r = clamp01(((r - 0.5) * contrastFactor) + 0.5);
                            g = clamp01(((g - 0.5) * contrastFactor) + 0.5);
                            b = clamp01(((b - 0.5) * contrastFactor) + 0.5);
                        }

                        if (vibranceEnabled) {
                            let [h, s, l] = rgbToHsl(r, g, b);
                            if (vibranceAmount >= 0) {
                                s += (1 - s) * vibranceAmount;
                            } else {
                                s += s * vibranceAmount;
                            }
                            s = clamp01(s);
                            [r, g, b] = hslToRgb(h, s, l);
                        }

                        data[i] = Math.round(clamp01(r) * 255);
                        data[i + 1] = Math.round(clamp01(g) * 255);
                        data[i + 2] = Math.round(clamp01(b) * 255);
                    }
                }

                function clamp01(v) {
                    if (v < 0) return 0;
                    if (v > 1) return 1;
                    return v;
                }

                function rgbToHsl(r, g, b) {
                    const max = Math.max(r, g, b);
                    const min = Math.min(r, g, b);
                    let h = 0, s = 0;
                    const l = (max + min) / 2;
                    if (max !== min) {
                        const d = max - min;
                        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                        switch (max) {
                            case r:
                                h = (g - b) / d + (g < b ? 6 : 0);
                                break;
                            case g:
                                h = (b - r) / d + 2;
                                break;
                            case b:
                                h = (r - g) / d + 4;
                                break;
                        }
                        h /= 6;
                    }
                    return [h, s, l];
                }

                function hslToRgb(h, s, l) {
                    let r, g, b;
                    if (s === 0) {
                        r = g = b = l;
                    } else {
                        const hue2rgb = (p, q, t) => {
                            if (t < 0) t += 1;
                            if (t > 1) t -= 1;
                            if (t < 1 / 6) return p + (q - p) * 6 * t;
                            if (t < 1 / 2) return q;
                            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                            return p;
                        };
                        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                        const p = 2 * l - q;
                        r = hue2rgb(p, q, h + 1 / 3);
                        g = hue2rgb(p, q, h);
                        b = hue2rgb(p, q, h - 1 / 3);
                    }
                    return [r, g, b];
                }

                let sessionOutputs = [];
                let historyMode = 'images';
                let videoHistory = [];
                let currentOutIndex = -1;
                let liveBGImage = null;
                let liveFGStickers = [];
                let recentImports = [];
                function trackRecentImport(src) {
                    if (src && !recentImports.includes(src)) {
                        recentImports.push(src);
                    }
                }
                let areFgStickersHidden = false;
                let isHistoryPreviewActive = false;
                let leftHudOpen = null;
                let rightHudOpen = null;
                let belowHudStack = [];

                let needsHudSnap = false;
                let materialHudDocked = true;
                let currentStickerForMaterial = null;


                let selectedHistoryIndex = -1; // -1 means "current canvas"

                let hoverPreviewState = null;
                let isLiveHistoryPreview = false;
                let isBeforeAfterPreview = false;
                let beforeAfterState = null;
                let beforeAfterFresh = false;
                let beforeLockIndex = -1; // -1 = current thumb as "Before"
                let lastSessionOutputCount = 0;

                let currentCanvasThumbImg = null;

                //const API_BASE = "http://127.0.0.1:5000";
                //const API = "http://127.0.0.1:5000";

                //const API_5100 = "http://127.0.0.1:5100";

                const API_BASE = window.location.origin;
                const API = window.location.origin;

                const barWrap = document.getElementById("processBarWrapper");
                const barFill = document.getElementById("processBar");
                let _pollTimer = null, _raf = null;
                let _curr = 0, _target = 0;

                let backgroundImage = null;
                let todBlendOriginal = null;
                let todBlendRatio = 1;
                let depthImage = null;
                let imgGenImage = null;
                let segmentationMask = null;
                let refinedMaskImage = null;
                let stickers = [];
                let activeStickerIndex = -1;
                const selectedStickerIndices = new Set(); // track multi-select

                function isMaterialHudVisible() {
                    const hud = document.getElementById('workflowMaterialHUD');
                    return !!(hud && hud.style.display !== 'none');
                }

                function refreshMaterialHudTarget(options = {}) {
                    const { force = false } = options;
                    if (!force && (!isMaterialHudVisible() || materialHudDocked)) return;

                    let target = null;

                    if (typeof activeStickerIndex === 'number' && activeStickerIndex >= 0) {
                        target = stickers[activeStickerIndex] || null;
                    } else if (selectedStickerIndices.size) {
                        const first = selectedStickerIndices.values().next().value;
                        if (typeof first === 'number' && first >= 0) {
                            target = stickers[first] || null;
                        }
                    }

                    if (!target && window.glbActiveSticker) {
                        target = window.glbActiveSticker;
                    }

                    currentStickerForMaterial = target;
                }

                window.refreshMaterialHudTarget = refreshMaterialHudTarget;
                let hoveredStickerIndex = -1;
                let isOverlayVisible = false;
                let userLoadedBg = false;
                let isEnhanceVisible = false;
                let enhanceImage = null;
                let isGpuMode = true;

                let lastUsedSeed = 0;

                // Camera zoom
                let camOffsetX = 0;
                let camOffsetY = 0;
                let camScale = 1.0;

                let firstPromptRun = true;

                let isPanning = false;
                let isDraggingSticker = false;
                let didSomething = false;
                let isResizingCorner = false;
                let isGlbStamped = false;
                let viewModeClicks = 0;
                let isHudInteracting = false;
                let showHudManually = false;
                let is3DActive = false;

                let hoverWX = null;           // world-x under the cursor (or null if outside canvas)
                let hoverWY = null;           // world-y under the cursor

                let startPanX = 0, startPanY = 0;   // used in panning
                let lastMouseX = 0, lastMouseY = 0; // optional for panning

                let dragOffsetX = 0, dragOffsetY = 0;
                let resizeCornerIndex = -1;
                let scaleStartDist = 1;
                let stickerCenterX = 0;
                let stickerCenterY = 0;
                let originalScale = 1;

                let dragLockAxis = null;
                let panLockAxis = null;
                let isRotatingSticker = false;
                let rotationCenterX = 0;
                let rotationCenterY = 0;
                let rotationStartAngle = 0;
                let ctrlDown = false;

                const rotateHint = document.createElement('div');
                rotateHint.id = 'rotateHint';
                rotateHint.innerHTML = '<i class="fa-solid fa-rotate"></i>';
                Object.assign(rotateHint.style, {
                    position: 'absolute',
                    display: 'none',
                    color: '#2be0a5',
                    fontSize: '48px',
                    textShadow: '0 0 8px #1fffd4',
                    zIndex: 10000,
                    pointerEvents: 'none'
                });
                document.body.appendChild(rotateHint);
                let rotateHintTimer = null;

                let actionMenuHoverIndex = -1;
                let actionMenuOpenIndex = -1;
                let flipButtonSide = null; // "left" | "right" | null

                const PANNING_SPEED = 0.5;      // the smaller, the less sensitive
                const ZOOM_FACTOR_STEP = 1.06;  // e.g. 1.02 is gentler, 1.1 is more extreme

                let isRightDragging = false;
                let dragStartX = 0;
                let dragStartY = 0;

                let isDraggingOrb = false;
                let lastX, lastY;

                let hoveredCornerIndex = -1;
                const PIN_DRAW_R = 6;      // visual radius of the green pin
                const PIN_HIT_R = 110;     // how far outside / inside it still counts as “on the pin”
                const PIN_HIT_R2 = PIN_HIT_R * PIN_HIT_R;   // pre-square for fast distance test
                const HOVER_TINT = "#afffde";

                /* ---------- Model Sync ------------------ */
                let aiModelsDropdownSticky = false;
                let modelsStatusInterval = null;

                const modelLocks = {
                    sam: false,
                    lbm: false,
                    shape: false,
                    caption: false,
                    //flux_schnell: false,
                    flux_kontext: false
                };

                function openAIDropdown() {
                    syncModelFocusBtns(); // Always fetch once on open
                    document.getElementById('modelsDropdown').style.display = "flex";
                    // Start polling only when open
                    if (modelsStatusInterval) clearInterval(modelsStatusInterval);
                    modelsStatusInterval = setInterval(syncModelFocusBtns, 1200);
                }

                function CloseAIDropdown() {
                    // Stop polling on close
                    if (modelsStatusInterval) clearInterval(modelsStatusInterval);
                    modelsStatusInterval = null;
                    document.getElementById('modelsDropdown').style.display = "none";
                    aiModelsDropdownSticky = false;
                }

                async function syncModelFocusBtns() {
                    const res = await fetch('/model-status');
                    const status = await res.json();
                    document.querySelectorAll('.modelFocusBtn').forEach(btn => {
                        const model = btn.dataset.model;
                        if (status[model]) {
                            btn.classList.add('on');
                            btn.classList.remove('off');
                        } else {
                            btn.classList.remove('on');
                            btn.classList.add('off');
                        }
                    });
                    // Update lock icon states
                    Object.keys(modelLocks).forEach(model => {
                        const icon = document.querySelector(`.modelIcon[data-model="${model}"]`);
                        if (icon && status.locks) {
                            modelLocks[model] = !!status.locks[model];
                            if (modelLocks[model]) {
                                icon.classList.add('locked');
                            } else {
                                icon.classList.remove('locked');
                            }
                        }
                    });
                }
                // Toggle dropdown on click
                document.getElementById('modelsDropdownNav').addEventListener('click', () => {
                    const menu = document.getElementById('modelsDropdown');
                    if (menu.style.display === 'flex') {
                        CloseAIDropdown();
                    } else {
                        openAIDropdown();
                    }
                });
                document.getElementById('modelsDropdown').addEventListener('mouseleave', () => {
                    setTimeout(() => {
                        if (!aiModelsDropdownSticky) CloseAIDropdown();
                    }, 120);
                });

                // On model button click:
                document.querySelectorAll('.modelFocusBtn').forEach(btn => {
                    btn.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        const model = btn.dataset.model;
                        // BLOCK load/unload if locked
                        if (modelLocks[model]) {
                            setActionText("Model is locked. Unlock before loading/unloading.");
                            return;
                        }
                        const isOn = btn.classList.contains('on');
                        aiModelsDropdownSticky = true;
                        btn.classList.add('focus-processing');
                        btn.disabled = true;
                        let resp;
                        if (isOn) {
                            resp = await fetch(`/unload-model`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ model })
                            });
                        } else {
                            resp = await fetch(`/load-model`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ model })
                            });
                        }
                        if (resp.ok) {
                            syncModelFocusBtns();
                            updateLBMIndicatorBtn();
                        }
                        aiModelsDropdownSticky = false;
                        btn.classList.remove('focus-processing');
                        btn.disabled = false;
                        CloseAIDropdown();
                    });
                });

                document.querySelectorAll('.modelIcon').forEach(icon => {
                    icon.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        const model = icon.dataset.model;
                        // Toggle lock state (ask backend)
                        const locked = !modelLocks[model];
                        icon.classList.toggle('locked', locked);
                        modelLocks[model] = locked;
                        await fetch('/lock-model', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ model, locked })
                        });
                        setActionText(model.toUpperCase() + (locked ? " model locked." : " model unlocked."));
                        syncModelFocusBtns();
                    });
                });

                /* ---------- CANVAS Panel History Outputs ------------------ */
                function showHistoryPanel() {
                    document.getElementById('historyPanel').style.display = 'flex';
                    setTimeout(() =>
                        document.getElementById('historyPanel').classList.remove('closed'), 10
                    );
                }
                function hideHistoryPanel() {
                    document.getElementById('historyPanel').classList.add('closed');
                    setTimeout(() =>
                        document.getElementById('historyPanel').style.display = 'none', 310
                    );
                }
                document.getElementById('closeHistoryPanel').onclick = hideHistoryPanel;

                /* ---------- CANVAS RESIZER (top‑centre anchor) ------------------ */
                const wrapper = document.getElementById("canvasWrapper");
                wrapper.addEventListener('transitionend', (e) => {
                    if (e.propertyName === 'transform') scheduleHudSnap();
                });
                const resizers = [
                    document.getElementById("canvasResizer"),
                    document.getElementById("canvasResizerLeft")
                ];
                const restoreBts = [
                    document.getElementById("canvasRestore"),
                    document.getElementById("canvasRestoreLeft")
                ];
                const caption = document.getElementById("captionBarContainer");

                // Auto-expand text for long captions:
                const captionText = document.getElementById("captionText");
                captionText.addEventListener('click', function () {
                    // Toggle expand/collapse on click if needed
                    this.style.maxHeight = this.style.maxHeight === "12em" ? "none" : "12em";
                });

                document.getElementById("captionCopyBtn").onclick = function () {
                    navigator.clipboard.writeText(document.getElementById("captionText").textContent || "");
                    this.classList.add("copied");
                    setTimeout(() => this.classList.remove("copied"), 1100);
                }


                let wrapperScale = 1;
                let baseW, startScale, startX, startY;

                function syncCaption() {
                    const newW = wrapper.getBoundingClientRect().width;
                    caption.style.left = "0";                 // no manual offset any more
                }

                resizers.forEach(resizerEl => {
                    resizerEl.addEventListener("mousedown", e => {
                        const r = wrapper.getBoundingClientRect();
                        baseW = r.width;                      // width *before* scaling
                        startScale = wrapperScale;
                        startX = e.clientX;
                        startY = e.clientY;
                        document.addEventListener("mousemove", resizeDrag);
                        document.addEventListener("mouseup", stopDrag);
                        e.preventDefault();

                    });
                });

                function resizeDrag(e) {
                    /* use the larger delta so the grip feels 1-axis and uniform */
                    const delta = Math.max(e.clientX - startX, e.clientY - startY);
                    wrapperScale = Math.max(1, startScale + delta / baseW);   // never shrink below 1
                    wrapper.style.transform = `scale(${wrapperScale})`;

                    scheduleHudSnap();
                    scheduleRedraw();
                    syncCaption();
                }

                function stopDrag() {
                    document.removeEventListener('mousemove', resizeDrag);
                    document.removeEventListener('mouseup', stopDrag);
                    scheduleHudSnap();     // one final exact snap when the user lets go
                }

                /* restore */
                restoreBts.forEach(bt => bt.addEventListener("click", () => {
                    camScale = 1;
                    camOffsetX = 0;
                    camOffsetY = 0;
                    wrapperScale = 1;
                    wrapper.style.transform = "scale(1)";
                    syncCaption();
                    drawCanvas();
                    scheduleHudSnap();    // keep HUDs flush
                    scheduleRedraw();
                }));

                /* first pass */
                requestAnimationFrame(syncCaption);

                document.querySelectorAll('.buttonHudIcon').forEach(btn => {
                    btn.addEventListener('click', function () {
                        btn.classList.remove('flash'); // restart the animation if needed
                        void btn.offsetWidth;          // force reflow
                        btn.classList.add('flash');
                        setTimeout(() => btn.classList.remove('flash'), 240); // remove after anim
                    });
                });

                (function makeSequencerHudDraggable() {
                    const hudContainer = document.getElementById('sequencerHudContainer');
                    const hudBar = document.querySelector('.sequencerHudBar');
                    let isDragging = false, dragOffsetX = 0, dragOffsetY = 0;

                    hudBar.addEventListener('mousedown', e => {
                        if (e.button !== 0) return;
                        // Calculate true on-screen position, even if centered
                        const rect = hudContainer.getBoundingClientRect();
                        hudContainer.style.left = rect.left + "px";
                        hudContainer.style.top = rect.top + "px";
                        hudContainer.style.transform = "none";  // Remove centering
                        hudContainer.style.position = 'fixed';
                        hudContainer.style.zIndex = 99999;
                        isDragging = true;
                        hudBar.classList.add('dragging');
                        dragOffsetX = e.clientX - rect.left;
                        dragOffsetY = e.clientY - rect.top;
                        document.body.style.userSelect = 'none';
                        e.preventDefault();
                    });
                    document.addEventListener('mousemove', e => {
                        if (!isDragging) return;
                        hudContainer.style.left = (e.clientX - dragOffsetX) + 'px';
                        hudContainer.style.top = (e.clientY - dragOffsetY) + 'px';
                        hudContainer.style.transform = 'none'; // disable center transform while dragging
                    });
                    document.addEventListener('mouseup', () => {
                        isDragging = false;
                        hudBar.classList.remove('dragging');
                        document.body.style.userSelect = '';
                    });
                })();

                // =============== Sequence HUD Logic (Classic Reordering) ===============
                const SEQ_SELECTED_BORDER = '#3fffd1';
                const SEQ_DRAG_OVER_BORDER = '#e5b85c';
                const SEQ_EMPTY_BG = 'rgba(120,255,220,0.09)';
                let sequenceImages = [];
                let maxSequenceImages = 6;
                let sequenceSelectedIndex = -1;
                let dragFromIndex = null;
                let dragOverIndex = null;

                function getCurrentCanvasThumbImage() {
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = canvas.width;
                    tempCanvas.height = canvas.height;
                    tempCanvas.getContext('2d').drawImage(canvas, 0, 0, canvas.width, canvas.height);
                    return tempCanvas.toDataURL('image/png');
                }

                sendToSequencerBtn.addEventListener('click', () => {
                    sequencerHudContainer.style.display = 'block';
                    sendCurrentToSequence();
                });
                closeSequencerHudBtn.addEventListener('click', () => {
                    sequencerHudContainer.style.display = 'none';
                    sequenceSelectedIndex = -1;
                    dragFromIndex = null;
                });

                function sendCurrentToSequence() {
                    if (sequenceImages.length >= maxSequenceImages) return;
                    const src = getCurrentCanvasThumbImage();
                    const imgObj = new Image();
                    imgObj.src = src;
                    imgObj.onload = () => {
                        sequenceImages.push({ src, imgObj });
                        sequenceSelectedIndex = sequenceImages.length - 1;
                        renderSequenceThumbs();
                    };
                }

                function renderSequenceThumbs() {
                    sequencerThumbs.innerHTML = '';
                    let count = sequenceImages.length;

                    sequenceImages.forEach((item, idx) => {
                        const div = document.createElement('div');
                        div.className = 'sequencerThumb';
                        div.draggable = true;

                        // Always show teal border if selected (not during drag)
                        if (idx === sequenceSelectedIndex && dragFromIndex !== idx && dragOverIndex !== idx) {
                            div.style.border = `2px solid #3fffd1`;
                            div.style.boxShadow = `0 0 0 4px #00ffd342`;
                        } else if (dragOverIndex === idx && dragFromIndex !== null && dragFromIndex !== idx) {
                            div.style.border = `2.5px solid #e5b85c`;
                            div.style.boxShadow = `0 0 0 4px #f8e67066`;
                        } else {
                            div.style.border = '2px solid transparent';
                            div.style.boxShadow = 'none';
                        }

                        // Remove all scaling (kills the "wobble" forever)
                        if (dragFromIndex === idx) {
                            div.classList.add('dragging');
                            div.style.transform = "none";
                        }

                        // ---- Drag Events ----
                        div.addEventListener('dragstart', e => {
                            dragFromIndex = idx;
                            dragOverIndex = null;
                            div.classList.add('dragging');
                            // For Chrome bug: setTimeout to delay, then add a class to all thumbs
                            setTimeout(() => {
                                document.querySelectorAll('.sequencerThumb').forEach(el => el.classList.add('not-dragged-thumb'));
                            }, 0);
                        });

                        div.addEventListener('dragend', e => {
                            dragFromIndex = null;
                            dragOverIndex = null;
                            div.classList.remove('dragging');
                            document.querySelectorAll('.sequencerThumb').forEach(el => el.classList.remove('not-dragged-thumb'));
                            renderSequenceThumbs();
                        });

                        div.addEventListener('dragover', e => {
                            e.preventDefault();
                            // Only if not dragging over itself
                            if (dragFromIndex !== idx) {
                                if (dragOverIndex !== idx) {
                                    dragOverIndex = idx;
                                    // Do NOT call renderSequenceThumbs here; just update border:
                                    div.style.border = `2.5px solid #e5b85c`;
                                    div.style.boxShadow = `0 0 0 4px #f8e67066`;
                                }
                            }
                        });

                        div.addEventListener('dragleave', e => {
                            // If mouse actually left, clear border (don't rerender)
                            if (dragOverIndex === idx) {
                                dragOverIndex = null;
                                // Revert border
                                div.style.border = '2px solid transparent';
                                div.style.boxShadow = 'none';
                            }
                        });

                        div.addEventListener('drop', e => {
                            e.preventDefault();
                            if (dragFromIndex !== null && dragFromIndex !== idx) {
                                // Remove the dragged item and insert after the drop target
                                const moved = sequenceImages.splice(dragFromIndex, 1)[0];
                                // Insert *after* the target
                                let insertAt = idx;
                                if (dragFromIndex < idx) insertAt = idx;
                                else insertAt = idx + 1;
                                sequenceImages.splice(insertAt, 0, moved);
                                sequenceSelectedIndex = insertAt;
                                dragFromIndex = null;
                                dragOverIndex = null;
                                renderSequenceThumbs();
                            }
                        });

                        // Image
                        const img = document.createElement('img');
                        img.src = item.src;
                        img.style.pointerEvents = "none";
                        div.appendChild(img);

                        // Delete button (pointerdown to avoid drag)
                        const delBtn = document.createElement('button');
                        delBtn.className = 'thumbDeleteBtn';
                        delBtn.title = 'Delete';
                        delBtn.innerHTML = '<i class="fas fa-trash"></i>';
                        // Make delete button a full drop zone
                        delBtn.addEventListener('dragover', e => { e.preventDefault(); div.dispatchEvent(new DragEvent('dragover', e)); });
                        delBtn.addEventListener('dragleave', e => { div.dispatchEvent(new DragEvent('dragleave', e)); });
                        delBtn.addEventListener('drop', e => { div.dispatchEvent(new DragEvent('drop', e)); });
                        delBtn.addEventListener('pointerdown', (e) => {
                            e.stopPropagation();
                            e.preventDefault();
                            sequenceImages.splice(idx, 1);
                            if (sequenceSelectedIndex >= sequenceImages.length) {
                                sequenceSelectedIndex = sequenceImages.length - 1;
                            }
                            renderSequenceThumbs();
                        });
                        div.appendChild(delBtn);

                        // Preview on hover (don't trigger if dragging)
                        div.onmouseenter = () => {
                            if (dragFromIndex === null) {
                                sequenceSelectedIndex = idx;
                                if (item.imgObj) {
                                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                                    ctx.drawImage(item.imgObj, 0, 0, canvas.width, canvas.height);
                                }
                                renderSequenceThumbs();
                            }
                        };

                        sequencerThumbs.appendChild(div);
                    });

                    // Empty slot at end (drop here to move to end)
                    if (count < maxSequenceImages) {
                        const emptyDiv = document.createElement('div');
                        emptyDiv.className = 'sequencerThumb';
                        emptyDiv.style.opacity = 0.18;
                        emptyDiv.style.border = '2px dashed #e5b85c';
                        emptyDiv.style.background = SEQ_EMPTY_BG;
                        emptyDiv.style.pointerEvents = 'all';
                        emptyDiv.addEventListener('dragover', e => { e.preventDefault(); emptyDiv.style.border = '2.5px solid #e5b85c'; });
                        emptyDiv.addEventListener('dragleave', e => { emptyDiv.style.border = '2px dashed #e5b85c'; });
                        emptyDiv.addEventListener('drop', e => {
                            e.preventDefault();
                            if (dragFromIndex !== null) {
                                const moved = sequenceImages.splice(dragFromIndex, 1)[0];
                                sequenceImages.push(moved);
                                sequenceSelectedIndex = sequenceImages.length - 1;
                                dragFromIndex = null;
                                dragOverIndex = null;
                                renderSequenceThumbs();
                            }
                        });
                        sequencerThumbs.appendChild(emptyDiv);
                    }

                    sequencerHudContainer.style.minWidth = Math.max(640, Math.min(128 * (count + 1), 1150)) + "px";
                }

                /******************************************************
                * Stickers + State
                ******************************************************/
                let isForegroundMode = false;
                let isClickMode = false;

                // toggle masking view
                let isMaskOverlayVisible = true;
                const toggleRefineMaskBtn = document.getElementById("toggleRefineMaskBtn");

                toggleRefineMaskBtn.addEventListener("click", () => {
                    isMaskOverlayVisible = !isMaskOverlayVisible;

                    if (!isMaskOverlayVisible) {
                        // We are turning OFF the overlay => clear it
                        overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

                        // Switch icon to "eye-slash" if you want
                        toggleRefineMaskBtn.classList.remove("fa-eye");
                        toggleRefineMaskBtn.classList.add("fa-eye-slash");

                        setActionText("Refine Mask => hidden");
                    } else {
                        // We are turning it ON => re-draw
                        updateMaskPreview(); // or whatever your "draw overlay" function is

                        toggleRefineMaskBtn.classList.remove("fa-eye-slash");
                        toggleRefineMaskBtn.classList.add("fa-eye");

                        setActionText("Refine Mask => visible");
                    }
                });

                // Canvas layout
                //canvas.addEventListener("contextmenu", e => e.preventDefault());
                canvas.addEventListener("contextmenu", e => {
                    e.preventDefault();
                    const { x, y } = getWorldCoords(e.clientX, e.clientY);
                    if (hitTestSticker(x, y) === -1) {
                        fgImageInput.click();
                    }
                });

                // Toggling the top logo
                const topLogoIcon = document.querySelector(".topLogoIcon");
                const topLogoText = document.querySelector(".topLogoText");
                let isLumify = false;
                topLogoIcon.addEventListener("click", () => {
                    if (!isLumify) {
                        topLogoIcon.style.backgroundImage = 'src("/lum_logo.png")';
                        homeImage.src = "/lumafi.png";
                        topLogoText.textContent = "LUMAFI";
                        isLumify = true;
                    } else {
                        topLogoIcon.style.backgroundImage = 'src("/lum_logo.png")';
                        homeImage.src = "/lumify.png";
                        topLogoText.textContent = "LUMIFY";
                        isLumify = false;
                    }
                });


                function openWorkflowMaterialHUD(sticker) {
                    const hud = document.getElementById('workflowMaterialHUD');
                    if (!hud) return;

                    // Default to the currently active sticker if none is specified
                    if (!sticker && typeof activeStickerIndex === 'number' && activeStickerIndex >= 0) {
                        sticker = stickers[activeStickerIndex];
                    }

                    if (sticker) {
                        // Remove from workflow stack when docking to a sticker
                        detachWorkflowHUD(hud);

                        currentStickerForMaterial = sticker;
                        materialHudDocked = true;
                        showHUD(hud);
                        if (typeof snapMaterialHudToSticker === 'function') {
                            snapMaterialHudToSticker();
                        }
                    } else {
                        currentStickerForMaterial = null;
                        materialHudDocked = false;
                        hud.style.left = '';
                        hud.style.top = '';
                        if (typeof openWorkflowHUD === 'function') {
                            openWorkflowHUD(hud);
                        } else {
                            showHUD(hud);
                        }
                        refreshMaterialHudTarget({ force: true });
                    }
                }
                window.openWorkflowMaterialHUD = openWorkflowMaterialHUD;

                function snapMaterialHudToSticker() {
                    const hud = document.getElementById('workflowMaterialHUD');
                    const wrapper = document.getElementById('canvasWrapper');
                    if (!hud || !wrapper) return;

                    const pad = 12;
                    const wrapperRect = wrapper.getBoundingClientRect();

                    let target = currentStickerForMaterial;
                    if (!target && typeof activeStickerIndex === 'number' && activeStickerIndex >= 0) {
                        target = stickers[activeStickerIndex];
                    }
                    if (!target && window.glbActiveSticker) {
                        target = window.glbActiveSticker;
                    }
                    if (!target) return;

                    hud.style.position = 'absolute';
                    hud.style.zIndex = 9999;

                    if (target.img && typeof target.x === 'number' && typeof target.y === 'number') {
                        const scale = typeof target.scale === 'number' ? target.scale : 1;
                        const centerY = target.y + (target.img.height * scale) / 2;
                        const stickerRect = getScreenCoords(target.x, centerY);
                        hud.style.left = (stickerRect.x - hud.offsetWidth - pad - wrapperRect.left) + 'px';
                        hud.style.top = (stickerRect.y - wrapperRect.top - hud.offsetHeight / 2) + 'px';
                    } else if (target.canvas instanceof HTMLCanvasElement) {
                        const rect = target.canvas.getBoundingClientRect();
                        const centerY = rect.top + rect.height / 2;
                        hud.style.left = (rect.left - hud.offsetWidth - pad - wrapperRect.left) + 'px';
                        hud.style.top = (centerY - hud.offsetHeight / 2 - wrapperRect.top) + 'px';
                    }
                }
                /* ---------- MATERIAL HUD Handler---------- */

                document.addEventListener('DOMContentLoaded', () => {
                    (function () {
                        // -------- DOM Cache --------
                        const valRow = document.getElementById('matValRow');        // light / neutral / dark
                        const satRow = document.getElementById('matSatRow');        // desaturated / neutral / saturated
                        const hueStrip = document.getElementById('matHueStrip');      // 12-color swatches
                        const matTypeSel = document.getElementById('matTypeSelect');    // material type <select>
                        const presetSel = document.getElementById('matPresetSelect');  // material preset <select>
                        const reflectSl = document.getElementById('matReflectSlider'); // 0 glassy → 1 matte (inverted)
                        const detailSl = document.getElementById('matDetailSlider');  // texture detail (maps to guidance)
                        const stepsSl = document.getElementById('matStepsSlider');   // steps
                        const workflowMaterialHUD = document.getElementById('workflowMaterialHUD');   // HUD root

                        // ——— Small helpers ————————————————————————
                        function showHUD(el) {
                            el.style.display = 'block';
                            // allow CSS transition to run
                            requestAnimationFrame(() => el.classList.add('open'));
                        }
                        function hideHUD(el) {
                            el.classList.remove('open');
                            // match your CSS transition duration (200–250ms)
                            setTimeout(() => { el.style.display = 'none'; }, 220);
                        }
                        // expose helpers so external functions (e.g. openWorkflowMaterialHUD)
                        // can access them when defined outside this closure
                        window.showHUD = showHUD;
                        window.hideHUD = hideHUD;

                        // Resolve which sticker is currently targeted for material operations
                        function getMaterialTargetSticker() {
                            if (currentStickerForMaterial) return currentStickerForMaterial;
                            if (typeof activeStickerIndex === 'number' && activeStickerIndex >= 0) {
                                return stickers[activeStickerIndex] || null;
                            }
                            if (selectedStickerIndices.size) {
                                const idx = selectedStickerIndices.values().next().value;
                                if (typeof idx === 'number' && idx >= 0) {
                                    return stickers[idx] || null;
                                }
                            }
                            if (window.glbActiveSticker) return window.glbActiveSticker;
                            return null;
                        }

                        // Build the 3‑tier color phrase from selected buttons
                        function getSelectedText(container) {
                            if (!container) return '';
                            const chosen = container.querySelector('[data-selected="true"]');
                            return chosen ? chosen.getAttribute('data-token') || chosen.textContent.trim() : '';
                        }
                        function buildColorPhrase() {
                            const v = getSelectedText(valRow);      // "light" | "neutral" | "dark" | ''
                            const s = getSelectedText(satRow);      // "desaturated" | "neutral" | "saturated" | ''
                            const h = getSelectedText(hueStrip);    // e.g. "blue" | "teal" | "magenta" | ''
                            // collapse "neutral" words if they’re the only thing picked
                            const parts = [v, s, h].filter(Boolean).filter(t => t !== 'neutral');
                            return parts.join(' ').trim();          // e.g. "light saturated blue" or "teal"
                        }

                        // color phrase builder from the 3 tiers
                        function getMatColorPhrase() {
                            const valBtn = document.querySelector('#matValRow .matToggle.active');
                            const satBtn = document.querySelector('#matSatRow .matToggle.active');
                            const hueSw = document.querySelector('#matHueStrip .active');
                            const satMap = { desat: 'desaturated', sat: 'saturated', neutral: 'neutral' };
                            const parts = [];
                            const v = valBtn?.dataset.value || 'neutral';
                            const s = satMap[satBtn?.dataset.sat || 'neutral'] || 'neutral';
                            const h = hueSw?.dataset.hue || '';
                            if (v !== 'neutral') parts.push(v);
                            if (s !== 'neutral') parts.push(s);
                            if (h) parts.push(h);
                            return parts.join(' ').trim();
                        }

                        // reflectivity (inverted scale handled server-side by prompt builder)
                        function getReflectivity() {
                            const el = document.getElementById('matReflectSlider');
                            const v = el ? Number(el.value) / 100 : 0.35;
                            return Math.max(0, Math.min(1, v));
                        }

                        // material types / presets
                        function getMaterialType() {
                            return document.getElementById('matTypeSelect')?.value || 'plastic';
                        }
                        function getMaterialPreset() {
                            return document.getElementById('matPresetSelect')?.value || '';
                        }

                        function getPromptText() {
                            return (document.getElementById('matPrompt')?.value || '').trim();
                        }

                        function getSeed() {
                            const lock = $('#matSeedLock');
                            const sel = $('#matSeedSelect');
                            if (!sel) return null;
                            const locked = lock?.classList?.contains('locked');
                            const v = (sel.value || '').trim();
                            if (!v || v === 'random') return locked ? 12345 : null;
                            const n = parseInt(v, 10);
                            return Number.isFinite(n) ? n : null;
                        }

                        // swatch & tier selection toggles (single-select per row)
                        function wireTiers() {
                            // value row
                            document.querySelectorAll('#tier-value button').forEach(btn => {
                                btn.onclick = () => {
                                    document.querySelectorAll('#tier-value button').forEach(b => b.classList.remove('active'));
                                    btn.classList.add('active');
                                };
                            });
                            // saturation row
                            document.querySelectorAll('#tier-sat button').forEach(btn => {
                                btn.onclick = () => {
                                    document.querySelectorAll('#tier-sat button').forEach(b => b.classList.remove('active'));
                                    btn.classList.add('active');
                                };
                            });
                            // hue strip (swatches)
                            document.querySelectorAll('#tier-hue .swatch').forEach(btn => {
                                btn.onclick = () => {
                                    document.querySelectorAll('#tier-hue .swatch').forEach(b => b.classList.remove('active'));
                                    btn.classList.add('active');
                                };
                            });
                        }

                        /////////////MAT HUD HELPERS-------------

                        const hud = document.getElementById('workflowMaterialHUD');
                        if (!hud || hud.dataset.bound === "1") return; // avoid double-binding
                        hud.dataset.bound = "1";

                        let matValue = 'neutral';
                        let matSat = 'neutral';
                        let matHue = ''; // optional until user clicks a swatch
                        let matType = 'plastic';
                        let matPreset = 'none';

                        // helpers

                        const $ = (s, r = document) => r.querySelector(s);
                        const $$ = (s, r = document) => Array.from(r.querySelectorAll(s));
                        const setActive = (btn, groupSel) => {
                            $$(groupSel + ' .active').forEach(b => b.classList.remove('active'));
                            btn.classList.add('active');
                        };
                        const rebuildColorPhrase = () => {
                            const parts = [];
                            if (matValue !== 'neutral') parts.push(matValue);
                            if (matSat !== 'neutral') parts.push(matSat);
                            if (matHue) parts.push(matHue);
                            const phrase = parts.join(' ');
                            const preview = $('#matColorPreview');
                            if (preview) preview.innerHTML = 'Current color phrase: <em>' + (phrase || '—') + '</em>';
                            return phrase;
                        };

                        // -------- Value / Saturation buttons --------
                        $$('#matValRow .matToggle').forEach(btn => {
                            btn.addEventListener('click', () => {
                                matValue = btn.dataset.value;
                                setActive(btn, '#matValRow');
                                rebuildColorPhrase();
                            });
                        });
                        $$('#matSatRow .matToggle').forEach(btn => {
                            btn.addEventListener('click', () => {
                                const satMap = { desat: 'desaturated', sat: 'saturated', neutral: 'neutral' };
                                matSat = satMap[btn.dataset.sat] || 'neutral';
                                setActive(btn, '#matSatRow');
                                rebuildColorPhrase();
                            });
                        });

                        // -------- Hue swatches (single row) --------
                        $$('#matHueStrip .sw').forEach(sw => {
                            sw.addEventListener('click', () => {
                                $$('#matHueStrip .active').forEach(x => x.classList.remove('active'));
                                sw.classList.add('active');
                                matHue = sw.dataset.hue;
                                rebuildColorPhrase();
                            });
                        });

                        const matTypeSelect = $('#matTypeSelect');
                        const matPresetSelect = $('#matPresetSelect');
                        if (matTypeSelect) matTypeSelect.addEventListener('change', () => { matType = matTypeSelect.value; });
                        if (matPresetSelect) matPresetSelect.addEventListener('change', () => { matPreset = matPresetSelect.value; });


                        // --- safe slider wiring (call this right after you open the HUD) ---
                        function wireMaterialHudSliders() {
                            // Reflectivity
                            const reflectEl = document.getElementById('matReflectSlider');
                            const reflectOut = document.getElementById('matReflectValue');
                            if (reflectEl && reflectOut) {
                                const sync = () => reflectOut.textContent = (reflectEl.value / 100).toFixed(2);
                                sync();
                                reflectEl.addEventListener('input', sync);
                            }

                            // Texture Detail
                            const detailEl = document.getElementById('matDetailSlider');
                            const detailOut = document.getElementById('matDetailValue');
                            if (detailEl && detailOut) {
                                const sync = () => detailOut.textContent = detailEl.value;
                                sync();
                                detailEl.addEventListener('input', sync);
                            }

                            // Steps (Advanced)
                            const stepsEl = document.getElementById('matStepsSlider');
                            const stepsOut = document.getElementById('matStepsValue');
                            if (stepsEl && stepsOut) {
                                const sync = () => stepsOut.textContent = stepsEl.value;
                                sync();
                                stepsEl.addEventListener('input', sync);
                            }
                        }
                        window.wireMaterialHudSliders = wireMaterialHudSliders;

                        // -------- Sliders + readouts --------
                        const reflectEl = $('#matReflectSlider'), reflectOut = $('#matReflectValue');
                        if (reflectEl && reflectOut) {
                            reflectOut.textContent = (reflectEl.value / 100).toFixed(2);
                            reflectEl.addEventListener('input', () => {
                                reflectOut.textContent = (reflectEl.value / 100).toFixed(2);
                            });
                        }
                        const detailEl = $('#matDetailSlider'), detailOut = $('#matDetailValue');
                        if (detailEl && detailOut) {
                            detailOut.textContent = detailEl.value;
                            detailEl.addEventListener('input', () => { detailOut.textContent = detailEl.value; });
                        }
                        const stepsEl = $('#matStepsSlider'), stepsOut = $('#matStepsValue');
                        if (stepsEl && stepsOut) {
                            stepsOut.textContent = stepsEl.value;
                            stepsEl.addEventListener('input', () => { stepsOut.textContent = stepsEl.value; });
                        }


                        // Advanced collapsible
                        // ---------- Seed lock ----------
                        const seedSelect = document.getElementById('matSeedSelect');
                        const seedLockBtn = document.getElementById('matSeedLock');
                        let seedLocked = false;

                        if (seedLockBtn && seedSelect) {
                            seedLockBtn.addEventListener('click', () => {
                                seedLocked = !seedLocked;
                                seedLockBtn.classList.toggle('locked', seedLocked);
                                seedLockBtn.setAttribute('aria-pressed', String(seedLocked));
                                seedLockBtn.textContent = seedLocked ? '🔒' : '🔓';
                                if (seedLocked && (seedSelect.value === 'random' || !seedSelect.value)) {
                                    const newSeed = String(Math.floor(Math.random() * 1e9));
                                    const opt = document.createElement('option');
                                    opt.value = newSeed;
                                    opt.textContent = newSeed;
                                    seedSelect.add(opt);
                                    seedSelect.value = newSeed;
                                }
                            });
                        }
                        // Keep your existing close button (no renaming)
                        const closeBtn = document.getElementById('closeMaterialHUDBtn');
                        if (closeBtn) {
                            closeBtn.onclick = () => {
                                // uses your existing close helper
                                if (typeof closeWorkflowHUD === 'function') {
                                    closeWorkflowHUD(hud);
                                } else {
                                    hud.style.display = 'none';
                                }
                            };
                        }

                        function buildMaterialPrompt({ colorPhrase, materialType, materialPreset, extra }) {
                            const parts = [];
                            if (colorPhrase) parts.push(colorPhrase);                 // e.g., "dark saturated blue"
                            if (materialType) parts.push(materialType);               // "plastic", "wood", etc.
                            if (materialPreset && materialPreset !== 'none') parts.push(materialPreset);
                            parts.push(
                                "update only the object's surface material, keep structure and silhouette, high detail, photo-real"
                            );
                            if (extra) parts.push(extra);
                            // Keep strongest tokens early; server trims to ~72 words if needed.
                            return parts.join(", ");
                        }

                        // Create a canvas containing only the active sticker with transparency
                        function buildStickerCanvasForMaterial() {
                            const st = getMaterialTargetSticker();
                            if (!st) throw new Error('No active sticker');

                            let source = null;
                            let srcWidth = 0;
                            let srcHeight = 0;

                            if (st.img instanceof HTMLImageElement) {
                                source = st.img;
                                srcWidth = st.img.width || st.img.naturalWidth || 0;
                                srcHeight = st.img.height || st.img.naturalHeight || 0;
                            } else if (st.canvas instanceof HTMLCanvasElement) {
                                source = st.canvas;
                                srcWidth = st.canvas.width || st.canvas.clientWidth || 0;
                                srcHeight = st.canvas.height || st.canvas.clientHeight || 0;
                            } else if (st.domElement instanceof HTMLImageElement) {
                                source = st.domElement;
                                srcWidth = st.domElement.width || st.domElement.naturalWidth || st.domElement.clientWidth || 0;
                                srcHeight = st.domElement.height || st.domElement.naturalHeight || st.domElement.clientHeight || 0;
                            }

                            srcWidth = Math.max(1, Math.floor(srcWidth));
                            srcHeight = Math.max(1, Math.floor(srcHeight));

                            if (!source || !srcWidth || !srcHeight) {
                                throw new Error('No active sticker');
                            }

                            const c = document.createElement('canvas');
                            c.width = srcWidth;
                            c.height = srcHeight;
                            const ctx = c.getContext('2d');
                            ctx.drawImage(source, 0, 0, srcWidth, srcHeight);
                            return c;
                        }

                        // Wire the Generate Material button
                        (function wireGenerateMaterialBtn() {
                            const genBtn = document.getElementById('generateMaterialBtn');
                            if (!genBtn) return;

                            genBtn.onclick = async () => {
                                try {
                                    // Snapshot current canvas for Before/After unless a view is locked
                                    if (beforeLockIndex === -1 && currentOutIndex === -1) {
                                        liveBGImage = backgroundImage;
                                        liveFGStickers = stickers.map(cloneSticker);
                                    }


                                    // 1) Gather HUD state
                                    const colorPhrase = (typeof rebuildColorPhrase === 'function')
                                        ? rebuildColorPhrase()
                                        : '';

                                    const materialType = document.getElementById('matTypeSelect')?.value || 'plastic';
                                    const materialPreset = document.getElementById('matPresetSelect')?.value || 'none';
                                    const reflectEl = document.getElementById('matReflectSlider');
                                    const detailEl = document.getElementById('matDetailSlider');
                                    const stepsEl = document.getElementById('matStepsSlider');
                                    const extra = (document.getElementById('matPrompt')?.value || '').trim();

                                    const reflectivity = reflectEl ? (Number(reflectEl.value) / 100) : 0.5;
                                    const guidance = Number(detailEl?.value || 3);
                                    const steps = parseInt(stepsEl?.value || '8', 10);

                                    // Seed handling via select
                                    const seedSelect = document.getElementById('matSeedSelect');
                                    const seedLock = document.getElementById('matSeedLock');
                                    let seed = seedSelect?.value || '';
                                    if (seedLock?.classList.contains('locked')) {
                                        if (!seed || seed === 'random') {
                                            seed = String(Math.floor(Math.random() * 1e9));
                                            if (seedSelect) {
                                                const opt = document.createElement('option');
                                                opt.value = seed;
                                                opt.textContent = seed;
                                                seedSelect.add(opt);
                                                seedSelect.value = seed;
                                            }
                                        }
                                    } else {
                                        seed = String(Math.floor(Math.random() * 1e9));
                                        if (seedSelect) {
                                            const opt = document.createElement('option');
                                            opt.value = seed;
                                            opt.textContent = seed;
                                            seedSelect.add(opt);
                                            seedSelect.value = seed;
                                        }
                                    }

                                    // 2) Compose full prompt for Kontext
                                    const reflectWords = (reflectivity <= 0.2) ? "very glossy, reflective"
                                        : (reflectivity <= 0.4) ? "glossy"
                                            : (reflectivity >= 0.8) ? "very matte, diffuse"
                                                : (reflectivity >= 0.6) ? "matte"
                                                    : "semi‑gloss";
                                    const prompt = buildMaterialPrompt({
                                        colorPhrase,
                                        materialType,
                                        materialPreset,
                                        extra: (reflectWords + (extra ? (", " + extra) : ""))
                                    });

                                    // 3) Render the target sticker to a canvas for the backend
                                    const offC = buildStickerCanvasForMaterial();
                                    const composite_b64 = offC.toDataURL('image/png');
                                    window.composite_b64 = composite_b64;

                                    // 4) POST to /flux-kontext-material
                                    const payload = {
                                        prompt,
                                        steps,
                                        guidance,
                                        guidance_scale: guidance,
                                        seed,
                                        composite_b64,
                                        width: offC.width,
                                        height: offC.height
                                    };

                                    if (typeof setActionText === 'function') setActionText("Kontext Material: Generating…");
                                    genBtn.classList.add("seafoam30Active", "processing");

                                    const res = await fetch(`/flux-kontext-material`, {
                                        method: "POST",
                                        headers: { "Content-Type": "application/json" },
                                        body: JSON.stringify(payload)
                                    });
                                    const result = await res.json();

                                    if (!res.ok) throw new Error(result.error || "Material route error");

                                    // Append the generated image to the sticker's flipbook and show it
                                    const st = getMaterialTargetSticker();
                                    if (st && result.image) {
                                        try {
                                            const newImg = await loadImageAsync(result.image);
                                            if (!st.flipBookImages || st.flipBookImages.length === 0) {
                                                st.flipBookImages = [st.img];
                                                st.flipBookIndex = 0;
                                            }
                                            st.flipBookImages.push(newImg);
                                            st.flipBookIndex = st.flipBookImages.length - 1;
                                            st.img = newImg;
                                            if (st.domElement) st.domElement.src = newImg.src;
                                            drawCanvas();
                                            setActionText?.("Kontext Material success ✔");
                                        } catch (imgErr) {
                                            console.error(imgErr);
                                            setActionText?.("Kontext Material: failed to load image");
                                        }
                                    }

                                } catch (err) {
                                    console.error(err);
                                    setActionText?.("Kontext Material failed: " + err.message);
                                } finally {
                                    genBtn.classList.remove("seafoam30Active", "processing");
                                }
                            };
                        })();

                        // Exported so other code (drawer) can call it
                        function wireDrawerMaterialButton(drawerEl, drawerMaterialBtn, sticker) {
                            if (!drawerMaterialBtn) return;
                            drawerMaterialBtn.onclick = (e) => {
                                e.stopPropagation();
                                // ensure this sticker is active so the HUD can dock correctly
                                activeStickerIndex = stickers.indexOf(sticker);
                                // close the drawer
                                if (drawerEl?.classList?.remove) drawerEl.classList.remove('open');
                                setTimeout(() => { if (drawerEl) drawerEl.style.display = 'none'; }, 210);
                                // open HUD
                                openWorkflowMaterialHUD(sticker);
                            };
                        }

                        // Bootstrapping for this module
                        function initMaterialHUD() {
                            wireTiers();
                            wireGenerate();
                        }

                        // Make available to the rest of the app
                        window.wireDrawerMaterialButton = wireDrawerMaterialButton;
                        window.initMaterialHUD = initMaterialHUD;
                    })();

                    (function makeMaterialHudDraggable() {
                        const hud = document.getElementById('workflowMaterialHUD');
                        const title = document.getElementById('workflowMaterialHUDTitle');
                        if (!hud || !title) return;
                        let dragging = false, offsetX = 0, offsetY = 0;

                        title.addEventListener('mousedown', function (e) {
                            dragging = true;
                            offsetX = e.clientX - hud.offsetLeft;
                            offsetY = e.clientY - hud.offsetTop;
                            hud.style.position = 'absolute';
                            hud.style.zIndex = 99999;
                            document.body.style.userSelect = 'none';
                            materialHudDocked = false;
                            detachWorkflowHUD(hud);
                            e.preventDefault();
                        });

                        document.addEventListener('mousemove', function (e) {
                            if (!dragging) return;
                            hud.style.left = (e.clientX - offsetX) + 'px';
                            hud.style.top = (e.clientY - offsetY) + 'px';
                        });

                        document.addEventListener('mouseup', function () {
                            dragging = false;
                            document.body.style.userSelect = '';
                        });
                    })();

                    document.addEventListener('DOMContentLoaded', () => {
                        if (window.initMaterialHUD) window.initMaterialHUD();
                    });

                    document.getElementById('closeMaterialHUDBtn').onclick = () => {
                        const hud = document.getElementById('workflowMaterialHUD');
                        closeWorkflowHUD(hud);
                        hud.style.left = '';
                        hud.style.top = '';
                        materialHudDocked = true; // Re-dock next open!
                        currentStickerForMaterial = null;
                        updateDrawerHighlight(wfMaterial, hud);
                    };

                    // --- Extra UI wiring (outside IIFE but after DOMContentLoaded) ---
                    document.querySelectorAll('#workflowMaterialHUD .hudSectionHeader')
                        .forEach(h => {
                            h.style.cursor = 'pointer';
                            h.addEventListener('click', () => {
                                const body = h.nextElementSibling;
                                body.classList.toggle('collapsed');
                                //h.querySelector('span').textContent =
                                //    body.classList.contains('collapsed')
                                //        ? 'Advanced Prompt ▾' : 'Advanced Prompt ▴';
                            });
                        });
                });


                function syncActionDrawerPosition() {
                    const drawer = document.getElementById('stickerActionDrawer');
                    if (!drawer || actionMenuOpenIndex === -1) return;
                    const st = stickers[actionMenuOpenIndex];
                    if (!st) return;

                    // Same logic as in openStickerActionDrawer:
                    const w = st.img.width * st.scale;
                    const h = st.img.height * st.scale;
                    const menuScreen = getScreenCoords(st.x + w / 2, st.y + h - 5);

                    const wrapperRect = document.getElementById('canvasWrapper').getBoundingClientRect();
                    const ws = wrapperScale;

                    // Position relative to canvasWrapper (account for scale)
                    drawer.style.left = ((menuScreen.x - wrapperRect.left) / ws - drawer.offsetWidth / 2) + "px";
                    drawer.style.top = ((menuScreen.y - wrapperRect.top) / ws + 10) + "px";
                }

                function openStickerActionDrawer(sticker) {
                    const drawer = document.getElementById('stickerActionDrawer');
                    if (!drawer) return;
                    drawer.innerHTML = `
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <div class="sticker-action-row">
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  <!-- Lighting (Lightbulb icon) -->
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <button class="sticker-action-btn" title="Lighting">
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  <svg width="30" height="30" viewBox="0 0 24 24" fill="none" stroke="#38ffe3" stroke-width="2.1" stroke-linecap="round" stroke-linejoin="round">
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <circle cx="12" cy="11" r="5.1" fill="#38ffe3" fill-opacity="0.08"/>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <path d="M9 18h6M10 21h4" stroke="#38ffe3" stroke-width="2"/>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <path d="M12 18v-2" />
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <path d="M8.5 15.5a6.5 6.5 0 1 1 7 0C14 16 14 18 12 18s-2 0-3.5-2.5z" fill="none"/>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  </svg>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                </button>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  <!-- Material (Glassy Orb) -->
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  <button class="sticker-action-btn" title="Material">
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <svg width="30" height="30" viewBox="0 0 24 24" fill="none">
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      <circle cx="12" cy="13" r="9" fill="url(#matOrb)" stroke="#84c9bf" stroke-width="0.9"/>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      <ellipse cx="13.5" cy="10" rx="3" ry="1.1" fill="#fff" fill-opacity="0.45"/>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      <defs>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <radialGradient id="matOrb" cx="60%" cy="30%" r="72%" fx="60%" fy="30%">
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          <stop offset="0%" stop-color="#d7f1ff"/>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          <stop offset="60%" stop-color="#41d6c2"/>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          <stop offset="90%" stop-color="#128285"/>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          <stop offset="100%" stop-color="#0b0f16"/>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </radialGradient>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      </defs>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    </svg>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  </button>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  <!-- Import FG -->
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  <button class="sticker-action-btn" title="Import FG">
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <svg width="30" height="30" viewBox="0 0 24 24" fill="none" stroke="#38ffe3" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round">
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      <rect x="4.5" y="4.5" width="15" height="15" rx="3.3" fill="#38ffe3" fill-opacity="0.08" />
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      <path d="M7 15l3.5-4.5 2.5 3 2.5-3.5 3 5.5" stroke="#38ffe3" stroke-width="2.1" fill="none"/>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      <circle cx="9" cy="9" r="1.2" fill="#38ffe3" fill-opacity="0.18" />
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    </svg>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  </button>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  <!-- Send Behind (Up Arrow) -->
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <button class="sticker-action-btn" title="Send Behind">
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  <svg width="35" height="35" viewBox="0 0 24 24" fill="none">
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <!-- Box outline: will turn white on hover -->
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <rect class="hudbox-stroke" x="5.2" y="6.0" width="13.6" height="13" rx="2.9"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          fill="#38ffe3" fill-opacity="0.06" stroke="#38ffe3" stroke-width="2.1"/>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <!-- Up arrow: stays seafoam -->
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <path class="hudbox-icon" d="M12 14.5V10M9.5 12.5L12 10l2.5 2.5"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          stroke="#38ffe3" stroke-width="2.1" stroke-linecap="round" stroke-linejoin="round"/>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  </svg>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                </button>

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  <!-- Delete -->
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  <button class="sticker-action-btn" title="Delete">
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  <svg width="35" height="35" viewBox="0 0 24 24" fill="none">
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <!-- Box outline: will turn white on hover -->
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <rect class="hudbox-stroke" x="5.8" y="5.8" width="12.4" height="12.4" rx="3.2"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          fill="#ff3861" fill-opacity="0.08" stroke="#38ffe3" stroke-width="2.1"/>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <!-- X: stays seafoam -->
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <path class="hudbox-icon" d="M9.5 9.5l5 5M14.5 9.5l-5 5"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          stroke="#38ffe3" stroke-width="2.1" stroke-linecap="round" stroke-linejoin="round"/>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  </svg>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                </button>`;

                    const actionBtns = drawer.querySelectorAll('.sticker-action-btn');
                    const [lightingBtn, materialBtn, importBtn, layerBtn, deleteBtn] = actionBtns;

                    // DELETE FG: set the selected sticker and call deleteActiveSticker
                    deleteBtn.onclick = (e) => {
                        e.stopPropagation();
                        // Set this sticker as active before deleting
                        activeStickerIndex = stickers.indexOf(sticker);
                        deleteActiveSticker();
                        // Hide the drawer as well
                        drawer.classList.remove('open');
                        setTimeout(() => drawer.style.display = 'none', 210);
                    };

                    layerBtn.onclick = (e) => {
                        e.stopPropagation();
                        const idx = stickers.indexOf(sticker);
                        if (idx > 0) {
                            // Swap positions with the one just below
                            [stickers[idx - 1], stickers[idx]] = [stickers[idx], stickers[idx - 1]];
                            // Update activeStickerIndex to new position
                            activeStickerIndex = idx - 1;
                            drawCanvas();
                            setActionText("Sticker sent backward");
                        } else {
                            setActionText("Already at bottom layer");
                        }
                        // Optionally close the drawer
                        drawer.classList.remove('open');
                        setTimeout(() => drawer.style.display = 'none', 210);
                    };

                    importBtn.onclick = (e) => {
                        e.stopPropagation();
                        // Set current sticker for contextual replacement
                        currentUploadSticker = sticker;
                        document.getElementById('fgImageInput').click();
                        // Optionally: drawer stays open, or close after click
                        drawer.classList.remove('open');
                        setTimeout(() => drawer.style.display = 'none', 210);
                    };


                    materialBtn.onclick = (e) => {
                        e.stopPropagation();
                        // set this sticker as active so the HUD docks immediately
                        activeStickerIndex = stickers.indexOf(sticker);
                        drawer.classList.remove('open');
                        setTimeout(() => drawer.style.display = 'none', 210);

                        openWorkflowMaterialHUD(sticker);
                        wireMaterialHudSliders();
                    };

                    // Optional tiny helper so external code can call it too (keeps your naming).
                    window.openStickerActionDrawer = openStickerActionDrawer;

                    lightingBtn.onclick = function () {
                        // Assume activeStickerIndex and stickers[activeStickerIndex] are valid
                        // Launch the LBM relight process for the selected sticker!
                        if (typeof runStickerRelight === "function") {
                            runStickerRelight(sticker);
                        } else {
                            alert("Relight function not available.");
                        }
                    };



                    // Menu button (≡) screen coordinates (same as drawStickerBoundingBox)
                    const w = sticker.img.width * sticker.scale;
                    const h = sticker.img.height * sticker.scale;
                    const menuScreen = getScreenCoords(sticker.x + w / 2, sticker.y + h - 5);

                    // Make sure drawer's parent is #canvasWrapper, not body
                    const wrapperRect = document.getElementById('canvasWrapper').getBoundingClientRect();
                    const ws = wrapperScale;

                    drawer.style.display = 'block';
                    void drawer.offsetWidth; // Force reflow so width is valid

                    // Position relative to the parent (canvasWrapper)
                    drawer.style.left = ((menuScreen.x - wrapperRect.left) / ws - drawer.offsetWidth / 2) + "px";
                    drawer.style.top = ((menuScreen.y - wrapperRect.top) / ws + 10) + "px";
                    syncActionDrawerPosition();
                    syncMaterialHudPosition();
                    drawer.classList.add('open');

                    setTimeout(() => {
                        document.addEventListener('mousedown', stickerActionDrawerClose, { once: true });
                    }, 0);

                    actionMenuOpenIndex = stickers.indexOf(sticker);

                    // instantly hide HUD
                    sticker.domFocus.style.display = "none";

                    drawCanvas();               // redraw without the outline
                }

                function stickerActionDrawerClose(e) {
                    const drawer = document.getElementById('stickerActionDrawer');
                    if (!drawer) return;
                    if (!drawer.contains(e.target)) {
                        drawer.classList.remove('open');
                        setTimeout(() => { drawer.style.display = 'none'; }, 210); // wait for transition
                        const idx = actionMenuOpenIndex;
                        actionMenuOpenIndex = -1;
                        if (idx !== -1 && stickers[idx]) layoutModeButton(stickers[idx], idx);

                        drawCanvas();           // outline & buttons come back
                    }
                }

                /* --- slide‑out toggle --- */
                const drawer = document.getElementById('promptParamDrawer');
                const toggleBt = document.getElementById('promptParamToggle');
                drawer.classList.remove('open');

                /* click = slide in / out */
                document.getElementById('promptParamToggle')
                    .addEventListener('click', () => drawer.classList.toggle('open'));

                /* --- close “×” hides the whole HUD --- */
                document.getElementById('promptCloseBtn')
                    .addEventListener('click', () => {
                        document.getElementById('homePromptContainer').style.display = 'none';
                        updateDrawerHighlight(wfPrompt, promptHud);
                    });

                /* --- vertical drag scrubbing for numbers --- */
                document.querySelectorAll('.paramInput').forEach(inp => {
                    let startY, startVal;
                    inp.addEventListener('pointerdown', e => {
                        startY = e.clientY; startVal = parseFloat(inp.value);
                        inp.setPointerCapture(e.pointerId);
                    });
                    inp.addEventListener('pointermove', e => {
                        if (startY === undefined) return;
                        const step = parseFloat(inp.step) || 1;
                        const raw = startVal + (startY - e.clientY) * (step / 8);
                        const quant = Math.round(raw / step) * step;       // snap to nearest step
                        const min = parseFloat(inp.min || "-1e9");
                        const max = parseFloat(inp.max || "1e9");
                        const val = Math.min(Math.max(quant, min), max); // clamp

                        inp.value = val.toFixed(step % 1 ? 1 : 0);
                    });
                    inp.addEventListener('pointerup', () => { startY = undefined; });
                });



                // UI references
                const homePromptInner = document.getElementById("homePromptInner");
                const promptTitleElem = homePromptInner.querySelector("h1");      // <h1> inside the HUD
                const homePromptCaption = document.getElementById("homePromptCaption");
                const homeImageContainer = document.getElementById("homeImageContainer");
                const homeImage = document.getElementById("homeImage");
                const canvasContainer = document.getElementById("canvasContainer");
                const homePromptContainer = document.getElementById("homePromptContainer");
                const canvasSpinnerOverlay = document.getElementById("canvasSpinnerOverlay");
                const mainHeader = document.getElementById("mainHeader");
                const actionText = document.getElementById("actionText");
                function setActionText(msg) {
                    actionText.textContent = msg || "";
                }
                const bgFilenameDiv = document.getElementById("bgFilename");
                const bgFilenameText = document.getElementById("bgFilenameText");
                const beforeAfterLabel = document.getElementById("beforeAfterLabel");
                const canvasBeforeLock = document.getElementById("canvasBeforeLock");
                //const captionBox = document.getElementById("captionBox");
                //const toggleOverlayBtn = document.getElementById("toggleOverlayBtn");
                const copyCaptionBtn = document.getElementById("copyCaptionBtn");
                const downloadCanvasBtn = document.getElementById("downloadCanvasBtn");
                const beforeAfterBtn = document.getElementById("beforeAfterBtn");
                const deleteFgBtn = document.getElementById("deleteFgBtn");
                const bgHoverArea = document.getElementById("bgHoverArea");

                function disableBgHoverArea() {
                    if (bgHoverArea) {
                        bgHoverArea.style.display = "none";
                        bgHoverArea.style.cursor = "default";
                    }
                }

                function updatePromptHudTitle() {
                    const titleH1 = document.querySelector('#homePromptInner h1');
                    if (!titleH1) return;                     // safety guard
                    // If the user already supplied a BG we’re in Img2Img mode
                    titleH1.textContent = userLoadedBg
                        ? 'Generate With Image2Image'
                        : 'Generate With Text2Image';
                }

                function hideHomePromptCaption() {
                    if (!firstPromptRun && homePromptCaption) {
                        homePromptCaption.style.display = "none";
                    }
                }

                function hideHomePromptHud() {
                    const hud = document.getElementById('homePromptContainer');
                    if (hud) hud.style.display = 'none';
                }

                function readPromptDrawer() {

                    const locked = document.getElementById('paramSeedLock').checked;
                    let seed;

                    if (locked) {
                        /* user chose a specific seed */
                        seed = parseInt(document.getElementById('paramSeed').value, 10) || 0;
                    } else {
                        /* unlocked → generate a new random each time and write it back */
                        seed = Math.floor(Math.random() * 99999999);
                        document.getElementById('paramSeed').value = seed;
                    }

                    return {
                        strength: parseFloat(document.getElementById('paramCreative').value),
                        guidance: parseFloat(document.getElementById('paramPrompt').value),
                        steps: parseInt(document.getElementById('paramSteps').value, 10),
                        seed
                    };
                }

                function clamp(v, min, max) { return Math.min(Math.max(v, min), max); }

                function refreshDrawerState() {
                    const creativeRow = document.getElementById('paramCreativeRow');
                    const resolutionRow = document.getElementById('paramResolutionRow');
                    const creativeInp = document.getElementById('paramCreative');
                    const stepsInp = document.getElementById('paramSteps');
                    const powerIcon = creativeRow.querySelector('i');     // magic‑wand or expand‑arrow
                    const promptIcon = document.querySelector('#paramPrompt').previousElementSibling;
                    const stepsIcon = document.querySelector('#paramSteps').previousElementSibling;
                    document.getElementById('homePromptModelSelect').style.display =
                        userLoadedBg ? 'inline-block' : 'none';

                    if (!userLoadedBg) {                     // ➜ Flux text‑to‑image
                        creativeRow.style.display = 'none';
                        resolutionRow.style.display = 'flex';     // show resolution picker
                        creativeInp.disabled = true;
                        powerIcon.dataset.tip = "Output Resolution";
                        promptIcon.dataset.tip = "Prompt Power";
                        stepsIcon.dataset.tip = "Sampling Steps";

                        if (+stepsInp.value < 1) stepsInp.value = 2;   // keep Flux defaults
                    } else {                                    // ➜ SD Img‑to‑Img
                        creativeRow.style.display = 'flex';
                        resolutionRow.style.display = 'none';
                        creativeInp.disabled = false;
                        powerIcon.dataset.tip = "Creative Power";
                        promptIcon.dataset.tip = "Prompt Power";
                        stepsIcon.dataset.tip = "Sampling Steps";

                        if (+stepsInp.value < 10) stepsInp.value = 20;  // SD default
                    }
                }

                const HOVER_BUFFER = 0;             // ← tweak to taste

                /* Attach once for every parent that has a .dropdownMenu */
                document.querySelectorAll('.navItem').forEach(parent => {
                    const menu = parent.querySelector('.dropdownMenu');
                    if (!menu) return;                  // skip stand‑alone buttons

                    let hideTimer;                      // shared by both elements

                    const show = () => {
                        clearTimeout(hideTimer);
                        menu.style.visibility = 'visible';
                        menu.style.opacity = '1';
                        menu.style.pointerEvents = 'auto';
                    };

                    const hide = () => {
                        hideTimer = setTimeout(() => {
                            menu.style.opacity = '0';
                            menu.style.pointerEvents = 'none';
                            /* let the fade finish before we make it un‑clickable */
                            setTimeout(() => (menu.style.visibility = 'hidden'), 250);
                        }, HOVER_BUFFER);
                    };

                    /* keep it open while either the parent _or_ the menu is hovered */
                    parent.addEventListener('mouseenter', show);
                    parent.addEventListener('mouseleave', hide);
                    menu.addEventListener('mouseenter', show);
                    menu.addEventListener('mouseleave', hide);
                });

                document.querySelectorAll('.navItem').forEach(item => {
                    if (item.id === 'imageAdjustmentsToggle') return;
                    item.addEventListener('mouseenter', () => closeImageAdjustments());
                });

                /* Same trick for every .dropdownItem that owns a .rightSubMenu */
                document.querySelectorAll('.dropdownItem').forEach(item => {
                    const sub = item.querySelector('.rightSubMenu');
                    if (!sub) return;

                    let hideTimer;
                    const show = () => { clearTimeout(hideTimer); sub.style.opacity = '1'; sub.style.visibility = 'visible'; };
                    const hide = () => { hideTimer = setTimeout(() => { sub.style.opacity = '0'; sub.style.visibility = 'hidden'; }, HOVER_BUFFER); };

                    item.addEventListener('mouseenter', show);
                    item.addEventListener('mouseleave', hide);
                    sub.addEventListener('mouseenter', show);
                    sub.addEventListener('mouseleave', hide);
                });

                function showCancelBtn() {
                    document.getElementById("cancelModelBtn").style.display = "inline-block";
                }
                function hideCancelBtn() {
                    document.getElementById("cancelModelBtn").style.display = "none";
                }
                // Some nav items
                const gpuBtn = document.getElementById("gpuBtn");
                const purgeCacheBtn = document.getElementById("purgeCacheBtn");
                const sendToPsBtn = document.getElementById("sendToPsBtn");
                const sendToUnrealBtn = document.getElementById("sendToUnrealBtn");
                const sendToMixamoBtn = document.getElementById("sendToMixamo");

                async function updateLBMIndicatorBtn() {
                    const btn = document.getElementById("lbmStatusIndicator");
                    if (!btn) return;
                    try {
                        const res = await fetch("/model-status");
                        const data = await res.json();
                        if (data.lbm) {
                            btn.classList.add("glow");
                            btn.title = "LBM Model Loaded";
                        } else {
                            btn.classList.remove("glow");
                            btn.title = "LBM Model Not Loaded";
                        }
                    } catch (e) {
                        btn.classList.remove("glow");
                        btn.title = "LBM Model Not Loaded";
                    }
                }
                let lbmIndicatorInterval = null;

                function showRelightPromptCentered() {
                    const prompt = document.getElementById("relightPrompt");
                    const wrapper = document.getElementById("canvasWrapper");
                    if (!wrapper || !prompt) return;

                    if (prompt.parentElement !== wrapper) {
                        wrapper.appendChild(prompt);
                        updateLBMIndicatorBtn();
                        syncModelFocusBtns();
                        clearInterval(lbmIndicatorInterval);
                        lbmIndicatorInterval = setInterval(updateLBMIndicatorBtn, 1200);
                    }

                    // Position absolutely inside the canvas wrapper
                    prompt.style.position = "absolute";
                    prompt.style.left = "0";
                    prompt.style.top = "0";
                    prompt.style.width = "100%";
                    prompt.style.height = "100%";
                    prompt.style.display = "flex";
                    prompt.style.alignItems = "center";
                    prompt.style.justifyContent = "center";
                }

                function hideRelightPrompt() {
                    document.getElementById("relightPrompt").style.display = "none";
                    clearInterval(lbmIndicatorInterval);
                    lbmIndicatorInterval = null;
                    console.log("Relight prompt closed, polling stopped.");
                }

                function importStickerFromDataUrl(dataUrl, x = null, y = null, w = null, h = null) {
                    const img = new Image();
                    img.onload = () => {
                        const hasX = typeof x === "number" && Number.isFinite(x);
                        const hasY = typeof y === "number" && Number.isFinite(y);
                        const st = {
                            img,
                            x: hasX ? x : 0,
                            y: hasY ? y : 0,
                            scale: 1.0,
                            rotation: 0,
                            flipX: false,
                            flipBookImages: [img],
                            flipBookIndex: 0,
                            mode: "edit",
                            domButton: null,
                            domElement: null
                        };

                        if (typeof w === "number" && Number.isFinite(w) && w > 0 && img.width) {
                            st.scale = Math.max(0.001, w / img.width);
                        } else if (typeof h === "number" && Number.isFinite(h) && h > 0 && img.height) {
                            st.scale = Math.max(0.001, h / img.height);
                        }

                        stickers.push(st);
                        activeStickerIndex = stickers.length - 1;
                        createStickerDOM(st);
                        createModeButton(st);
                        clampStickerToCanvas(st, {
                            centerX: !hasX,
                            centerY: !hasY
                        });
                        layoutModeButton(st, activeStickerIndex);
                        pushHistory();
                        drawCanvas();
                        setActionText("Foreground image added");
                    };
                    img.src = dataUrl;
                }

                // BG, FG file inputs
                const bgFromComputerBtn = document.getElementById("bgFromComputerBtn");
                const bgInput = document.getElementById("bgInput");
                const fgImageBtn = document.getElementById("fgImageBtn");
                const fgImageInput = document.getElementById("fgImageInput");
                const fgAssetBtn = document.getElementById("fgAssetBtn");
                const fgAssetInput = document.getElementById("fgAssetInput");
                const fgFlipBookBtn = document.getElementById("fgFlipBookBtn");
                const fgFlipBookInput = document.getElementById("fgFlipBookInput");

                // SAMPLES
                const bgSamplesBtn = document.getElementById("bgSamplesBtn");
                const samplesOverlay = document.getElementById("samplesOverlay");
                const closeSamplesBtn = document.getElementById("closeSamplesBtn");
                const samplesImage = document.getElementById("samplesImage");
                const samplesArrowLeft = document.getElementById("samplesArrowLeft");
                const samplesArrowRight = document.getElementById("samplesArrowRight");
                const useSampleBtn = document.getElementById("useSampleBtn");
                let sampleImages = [];
                let currentSampleIndex = 0;

                // GALLERY
                const galleryBtn = document.getElementById("galleryBtn");
                const galleryOverlay = document.getElementById("galleryOverlay");
                const closeGalleryBtn = document.getElementById("closeGalleryBtn");
                const galleryGrid = document.getElementById("galleryGrid");
                const galleryHeader = document.getElementById("galleryHeader");
                const gallerySizeSlider = document.getElementById("gallerySizeSlider");
                const galleryCollectionsToggle = document.getElementById("galleryCollectionsToggle");
                let galleryScale = 1;
                let galleryFilenames = [];
                const galleryCollections = new Set();
                let galleryShowingCollections = false;

                function setGalleryCollectionsToggleState() {
                    if (!galleryCollectionsToggle) return;
                    if (galleryShowingCollections) {
                        galleryCollectionsToggle.textContent = "To Gallery";
                        galleryCollectionsToggle.classList.add("active");
                    } else {
                        galleryCollectionsToggle.textContent = "Collections";
                        galleryCollectionsToggle.classList.remove("active");
                    }
                }

                function adjustGalleryGrid() {
                    const items = galleryGrid.querySelectorAll(".galleryItem").length;
                    if (!items) return;

                    const gap = 12;
                    const availableWidth = galleryOverlay.clientWidth - 40; // overlay padding L+R
                    const availableHeight = galleryOverlay.clientHeight - 80 - galleryHeader.offsetHeight - 20;

                    let bestWidth = 260;
                    let bestCols = Math.max(1, Math.floor((availableWidth + gap) / (260 + gap)));

                    for (let cols = 1; cols <= items; cols++) {
                        const rows = Math.ceil(items / cols);
                        const widthByWidth = (availableWidth - gap * (cols - 1)) / cols;
                        const heightPerRow = (availableHeight - gap * (rows - 1)) / rows;
                        const widthByHeight = heightPerRow * 16 / 9;
                        const width = Math.min(widthByWidth, widthByHeight);
                        if (width > bestWidth) {
                            bestWidth = width;
                            bestCols = cols;
                        }
                    }

                    bestWidth *= galleryScale;
                    bestCols = Math.max(1, Math.floor((availableWidth + gap) / (bestWidth + gap)));

                    if (bestWidth > 260 * galleryScale) {
                        galleryGrid.style.gridTemplateColumns = `repeat(${bestCols}, ${bestWidth}px)`;
                    } else {
                        galleryGrid.style.gridTemplateColumns = `repeat(auto-fill, minmax(${260 * galleryScale}px,1fr))`;
                    }
                }

                function renderGalleryItems(filenames) {
                    galleryGrid.innerHTML = "";

                    if (!Array.isArray(filenames) || filenames.length === 0) {
                        const emptyDiv = document.createElement("div");
                        emptyDiv.className = "galleryEmptyMessage";
                        emptyDiv.textContent = galleryShowingCollections
                            ? "No images have been added to Collections yet."
                            : "No gallery images available.";
                        galleryGrid.appendChild(emptyDiv);
                        return;
                    }

                    filenames.forEach(filename => {
                        const itemDiv = document.createElement("div");
                        itemDiv.className = "galleryItem";

                        const imgEl = document.createElement("img");
                        imgEl.className = "galleryImg";
                        imgEl.src = `${API_BASE}/gallery/${filename}?t=${Date.now()}`;
                        imgEl.alt = filename;
                        itemDiv.appendChild(imgEl);

                        const addBtn = document.createElement("button");
                        addBtn.type = "button";
                        addBtn.className = "galleryAddBtn";
                        const addIcon = document.createElement("i");
                        addIcon.className = "fa-solid fa-plus";
                        addBtn.appendChild(addIcon);
                        addBtn.title = "Add to Collections";
                        itemDiv.appendChild(addBtn);

                        const updateAddState = () => {
                            if (galleryCollections.has(filename)) {
                                addBtn.classList.add("active");
                                addIcon.className = "fa-solid fa-check";
                                addBtn.title = "Remove from Collections";
                            } else {
                                addBtn.classList.remove("active");
                                addIcon.className = "fa-solid fa-plus";
                                addBtn.title = "Add to Collections";
                            }
                        };

                        updateAddState();

                        addBtn.addEventListener("click", (evt) => {
                            evt.stopPropagation();
                            if (galleryCollections.has(filename)) {
                                galleryCollections.delete(filename);
                            } else {
                                galleryCollections.add(filename);
                            }
                            updateAddState();
                            if (galleryShowingCollections) {
                                renderGalleryItems(Array.from(galleryCollections));
                                requestAnimationFrame(adjustGalleryGrid);
                            }
                        });

                        itemDiv.addEventListener("click", () => {
                            galleryOverlay.style.display = "none";
                            loadNewBackgroundImage(imgEl.src);

                            document.getElementById("homePromptContainer").style.display = "none";

                            const bigImg = new Image();
                            bigImg.crossOrigin = "Anonymous";
                            bigImg.onload = () => {
                                backgroundImage = bigImg;
                                computeBgLayout(bigImg);
                                depthImage = null;
                                imgGenImage = null;
                                segmentationMask = null;
                                refinedMaskImage = null;

                                homeImageContainer.style.display = "none";
                                canvasContainer.style.display = "block";
                                updateCanvasCursorState();
                                mainHeader.style.display = "block";
                                drawCanvas();
                                updateHistoryThumbs();

                                bgFilenameDiv.style.display = "block";
                                bgFilenameText.textContent = filename;
                                setActionText("Gallery => BG loaded");
                                syncCaption();
                            };
                            bigImg.src = imgEl.src;
                        });

                        galleryGrid.appendChild(itemDiv);
                    });
                }

                // FlipBook
                const flipBookOverlay = document.getElementById("flipBookOverlay");
                const flipBookImagesWrapper = document.getElementById("flipBookImagesWrapper");
                const flipBookArrowUp = document.getElementById("flipBookArrowUp");
                const flipBookArrowDown = document.getElementById("flipBookArrowDown");
                const closeFlipBookBtn = document.getElementById("closeFlipBookBtn");

                // Recents
                const recentOverlay = document.getElementById('recentOverlay');
                const closeRecentBtn = document.getElementById('closeRecentBtn');
                const recentImagesWrapper = document.getElementById('recentImagesWrapper');
                const recentArrowUp = document.getElementById('recentArrowUp');
                const recentArrowDown = document.getElementById('recentArrowDown');

                // Settings
                const settingsBtn = document.getElementById("settingsBtn");
                const settingsOverlay = document.getElementById("settingsOverlay");
                const closeSettingsBtn = document.getElementById("closeSettingsBtn");
                const saveSettingsBtn = document.getElementById("saveSettingsBtn");
                const cancelSettingsBtn = document.getElementById("cancelSettingsBtn");
                const restoreDefaultsBtn = document.getElementById("restoreDefaultsBtn");

                // SAM
                const samModelSelect = document.getElementById("samModelSelect");

                // Refine Mask Sliders
                const maskOpacitySlider = document.getElementById("maskOpacitySlider");
                const maskDilationSlider = document.getElementById("maskDilationSlider");
                const maskBlurSlider = document.getElementById("maskBlurSlider");
                const maskOpacityVal = document.getElementById("maskOpacityVal");
                const maskDilationVal = document.getElementById("maskDilationVal");
                const maskBlurVal = document.getElementById("maskBlurVal");
                const applyRefineBtn = document.getElementById("applyRefineBtn");
                const clearMaskBtn = document.getElementById("clearMaskBtn");

                // Depth
                const computeDepthBtn = document.getElementById("computeDepthBtn");

                // Grab the small “value” <span> elements so we can update text

                // Image 2 Image Gen
                //const imgGenBtn = document.getElementById("imgGenBtn");

                const sdDepth2ImgBtn = document.getElementById("sdDepth2ImgBtn");
                const sdImg2ImgHudBtn = document.getElementById("sdImg2ImgHudBtn");
                const sdImg2ImgBtn = document.getElementById("sdImg2ImgBtn");
                const sdDepth2ImgHudBtn = document.getElementById("sdDepth2ImgHudBtn");

                // Enhance
                const enhanceBtn = document.getElementById("enhanceBtn");
                const enhanceLaunchIcon = document.getElementById("enhanceLaunchIcon");
                const enhanceStrengthSlider = document.getElementById("enhanceStrengthSlider");
                const enhanceStrengthLabel = document.getElementById("enhanceStrengthLabel");
                // Caption
                const imgCaptionBtn = document.getElementById("imgCaptionBtn");

                function setCaption(newCaption) {
                    const bar = document.getElementById("captionBarContainer");
                    const text = document.getElementById("captionText");
                    const copyBtn = document.getElementById("captionCopyBtn");
                    if (!bar || !text || !copyBtn) {
                        console.warn("Caption bar or elements not found!");
                        return;
                    }

                    if (!newCaption || newCaption.trim() === "") {
                        bar.style.display = "none";
                        copyBtn.style.display = "none";
                        text.textContent = "";
                    } else {
                        bar.style.display = "flex";
                        text.textContent = newCaption;
                        copyBtn.style.display = "inline-block";
                    }
                }


                // 3D
                const threeDGenLaunchIcon = document.getElementById("threeDGenLaunchIcon");
                const threedGenBtn = document.getElementById("threedGenBtn");

                // Additional items
                const img2PoseBtn = document.getElementById("img2PoseBtn");
                //const img2VideoBtn = document.getElementById("img2VideoBtn");

                // Workflow HUD references
                const workflowImageBtn = document.getElementById("workflowImageBtn");
                const workflowLightingBtn = document.getElementById("workflowLightingBtn");
                const workflowMaterialBtn = document.getElementById("workflowMaterialBtn");
                const workflowTimeBtn = document.getElementById("workflowTimeBtn");
                const workflowStylizeBtn = document.getElementById("workflowStylizeBtn");
                const workflow3DBtn = document.getElementById("workflow3DBtn");
                const workflowVideoBtn = document.getElementById("workflowVideoBtn");

                const workflowImageHUD = document.getElementById("workflowImageHUD");
                const workflowLightingHUD = document.getElementById('workflowLightingHUD');
                const workflowMaterialHUD = document.getElementById('workflowMaterialHUD');
                const workflowTimeHUD = document.getElementById('workflowTimeOfDayHUD');
                const workflowStylizeHUD = document.getElementById('workflowStylizeHUD');
                const workflow3DHUD = document.getElementById("workflow3DHUD");
                const workflowVideoHUD = document.getElementById("workflowVideoHUD");
                const closeImageHUD = document.getElementById("closeImageHUD");
                const closeLightingHUD = document.getElementById('closeLightingHUD');
                const closeTimeHUD = document.getElementById('closeTimeOfDayHUD');
                const closeStylizeHUD = document.getElementById('closeStylizeHUD');
                const close3DHUD = document.getElementById("close3DHUD");
                const closeVideoHUD = document.getElementById("closeVideoHUD");
                const workflowImageHUDTitle = document.getElementById("workflowImageHUDTitle");
                const workflowTimeHUDTitle = document.getElementById("workflowTimeOfDayHUDTitle");
                const workflowStylizeHUDTitle = document.getElementById("workflowStylizeHUDTitle");
                const workflow3DHUDTitle = document.getElementById("workflow3DHUDTitle");
                const workflowVideoHUDTitle = document.getElementById("workflowVideoHUDTitle");

                // --- DOM refs (add alongside the existing ones) ---
                const workflowCameraBtn = document.getElementById('workflowCameraBtn');
                const workflowCameraHUD = document.getElementById('workflowCameraHUD');
                const workflowCameraHUDTitle = document.getElementById('workflowCameraHUDTitle');
                const closeCameraHUD = document.getElementById('closeCameraHUD');

                // Drawer button (add next to wfImg, wfLighting, etc.)
                const wfCamera = document.getElementById('workflowDrawerCameraBtn');

                // --- Drawer → dropdown bridge (mirror the existing pattern) ---
                if (wfCamera) {
                    wfCamera.onclick = () => {
                        document.getElementById('workflowCameraBtn').click();
                        updateDrawerHighlight(wfCamera, workflowCameraHUD);
                        document.getElementById('workflowsDrawer').classList.remove('open');
                    };
                }

                // --- Dropdown item → open/close HUD (mirrors your other handlers) ---
                if (workflowCameraBtn) {
                    workflowCameraBtn.addEventListener('click', () => {
                        if (workflowCameraHUD.style.display !== 'none') {
                            closeWorkflowHUD(workflowCameraHUD);
                            setActionText('Camera Workflow HUD => closed');
                        } else {
                            openWorkflowHUD(workflowCameraHUD);
                            setActionText('Camera Workflow HUD => opened');
                        }
                        if (wfCamera) updateDrawerHighlight(wfCamera, workflowCameraHUD);
                    });
                }

                // CAMERA PAD v2: behavior
                (() => {
                    const container = document.querySelector('#workflowCameraHUD .camHUD-padSurface');
                    if (!container) return;

                    const repeat = { timer: null, action: null, speed: 1 };

                    const startRepeat = (action, btn, e) => {
                        // visual feedback (momentary)
                        btn.classList.add('is-active');

                        // speed modifiers
                        const isFine = e.shiftKey;
                        const isCoarse = e.altKey || e.metaKey;
                        repeat.speed = isFine ? 0.25 : isCoarse ? 2 : 1;

                        // first nudge
                        sendCameraCommand(action, repeat.speed);

                        // then continuous
                        repeat.action = () => sendCameraCommand(action, repeat.speed);
                        repeat.timer = setInterval(repeat.action, 60); // ~16fps smoothness
                    };

                    const stopRepeat = () => {
                        if (repeat.timer) clearInterval(repeat.timer);
                        repeat.timer = null;
                        repeat.action = null;
                        container.querySelectorAll('.is-active').forEach(b => b.classList.remove('is-active'));
                    };

                    container.addEventListener('pointerdown', (e) => {
                        const btn = e.target.closest('button.camActionBtn[data-action]');
                        if (!btn) return;
                        btn.setPointerCapture?.(e.pointerId);
                        startRepeat(btn.dataset.action, btn, e);
                    });

                    container.addEventListener('pointerup', stopRepeat);
                    container.addEventListener('pointercancel', stopRepeat);
                    container.addEventListener('pointerleave', stopRepeat);
                    window.addEventListener('blur', stopRepeat);

                    // Keyboard mappings
                    window.addEventListener('keydown', (e) => {
                        const map = {
                            ArrowUp: 'tilt_up',
                            ArrowDown: 'tilt_down',
                            ArrowLeft: 'pan_left',
                            ArrowRight: 'pan_right',
                            '+': 'zoom_in',
                            '=': 'zoom_in',
                            '-': 'zoom_out',
                            '_': 'zoom_out',
                            '[': 'roll_left',
                            ']': 'roll_right',
                            r: 'recenter', R: 'recenter'
                        };
                        const action = map[e.key];
                        if (!action) return;
                        e.preventDefault();
                        sendCameraCommand(action, e.shiftKey ? 0.25 : e.altKey || e.metaKey ? 2 : 1);
                    });

                    // Replace with your real camera handler
                    function sendCameraCommand(action, speed = 1) {
                        // Example: hook into your control bus / state
                        // camera.move({ action, speed });
                        console.debug('[camera]', action, 'speed:', speed);
                    }
                })();


                // --- Close button ---
                if (closeCameraHUD) {
                    closeCameraHUD.addEventListener('click', () => {
                        closeWorkflowHUD(workflowCameraHUD);
                        if (wfCamera) updateDrawerHighlight(wfCamera, workflowCameraHUD);
                    });
                }

                // --- Make HUD draggable like the others ---
                if (typeof makeDraggable === 'function' && workflowCameraHUD && workflowCameraHUDTitle) {
                    makeDraggable(workflowCameraHUD, workflowCameraHUDTitle);
                }

                document.querySelector('#workflowCameraHUD .cameraGrid')
                    ?.addEventListener('click', (e) => {
                        const btn = e.target.closest('.buttonHudIcon');
                        if (!btn) return;

                        // visual state
                        document.querySelectorAll('#workflowCameraHUD .buttonHudIcon').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        // label
                        const labelMap = {
                            'tilt-up': 'Tilt Up', 'tilt-down': 'Tilt Down', 'pan-left': 'Pan Left', 'pan-right': 'Pan Right',
                            'zoom-in': 'Zoom In', 'zoom-out': 'Zoom Out', 'dolly-in': 'Dolly In', 'truck-left': 'Truck Left',
                            'truck-right': 'Truck Right', 'roll-left': 'Roll Left', 'roll-right': 'Roll Right', 'orbit': 'Orbit',
                            'center': 'Center Subject', 'undo': 'Undo', 'redo': 'Redo'
                        };
                        const action = btn.dataset.cam || '';
                        document.getElementById('cameraActionLabel').textContent = labelMap[action] || 'Camera';
                    });

                // show the live slider value
                const amt = document.getElementById('camAmount');
                const amtVal = document.getElementById('camAmountVal');
                amt?.addEventListener('input', () => amtVal.textContent = amt.value);


                function scheduleHudSnap() {
                    if (needsHudSnap) return;          // already queued this frame
                    needsHudSnap = true;
                    requestAnimationFrame(() => {
                        needsHudSnap = false;
                        snapAllWorkflowHUDs();         // ← your existing lay-out fn
                        if (homePromptContainer.style.display !== 'none' &&
                            homePromptContainer.classList.contains('promptHudMode')) {
                            snapPromptBelowCanvas(homePromptContainer);
                        }
                        syncActionDrawerPosition();
                        syncMaterialHudPosition();
                    });
                }
                // Snap to left
                function snapHudLeftOfCanvas(hud) {
                    const wrap = document.getElementById('canvasWrapper');
                    const rect = wrap.getBoundingClientRect();
                    const margin = 20;

                    // Measure width even if HUD is hidden
                    const wasHidden = hud.style.display === 'none';
                    if (wasHidden) {
                        hud.style.visibility = 'hidden';
                        hud.style.display = 'block';
                    }

                    hud.style.position = 'absolute';
                    hud.style.top = rect.top + 'px';
                    hud.style.left = (rect.left - hud.offsetWidth - margin) + 'px';
                    if (parseInt(hud.style.left, 10) < margin) hud.style.left = margin + 'px';

                    if (wasHidden) {
                        hud.style.display = 'none';
                        hud.style.visibility = '';
                    }

                    leftHudOpen = hud;
                }

                // Snap to right
                function snapHudRightOfCanvas(hud) {
                    const wrap = document.getElementById('canvasWrapper').getBoundingClientRect();
                    const margin = 20;

                    hud.style.position = 'absolute';
                    hud.style.top = wrap.top + 'px';
                    hud.style.left = (wrap.right + margin) + 'px';
                }

                // Stack below right
                function snapHudBelowRight(hud, aboveHud) {
                    const margin = 5;
                    const aboveRect = aboveHud.getBoundingClientRect();
                    hud.style.position = 'absolute';
                    hud.style.top = (aboveRect.bottom + margin) + 'px';
                    hud.style.left = aboveHud.style.left;
                }

                function snapAllWorkflowHUDs() {
                    // Re-snap left
                    if (leftHudOpen && leftHudOpen.style.display !== 'none') {
                        snapHudLeftOfCanvas(leftHudOpen);
                    }
                    // Re-snap right and all stacked below
                    if (rightHudOpen && rightHudOpen.style.display !== 'none') {
                        snapHudRightOfCanvas(rightHudOpen);
                        let last = rightHudOpen;
                        belowHudStack.forEach(hud => {
                            if (hud.style.display !== 'none') {
                                snapHudBelowRight(hud, last);
                                last = hud;
                            }
                        });
                    }
                    // Also re-snap the Prompt HUD if active
                    if (homePromptContainer &&
                        homePromptContainer.style.display !== 'none' &&
                        homePromptContainer.classList.contains('promptHudMode')) {
                        snapPromptBelowCanvas(homePromptContainer);
                    }
                }

                // Improved open function: refills left/right if spots open
                function openWorkflowHUD(hud) {
                    // Already open? bring to front
                    if (hud.style.display !== 'none') return;

                    // Clean up: remove from stack if somehow orphaned
                    belowHudStack = belowHudStack.filter(h => h !== hud);

                    if (!leftHudOpen || leftHudOpen.style.display === 'none') {
                        snapHudLeftOfCanvas(hud);
                        leftHudOpen = hud;
                    } else if (!rightHudOpen || rightHudOpen.style.display === 'none') {
                        snapHudRightOfCanvas(hud);
                        rightHudOpen = hud;
                    } else {
                        // Only stack if not already stacked
                        if (!belowHudStack.includes(hud)) belowHudStack.push(hud);
                        let last = rightHudOpen;
                        belowHudStack.forEach(stackHud => {
                            snapHudBelowRight(stackHud, last);
                            last = stackHud;
                        });
                    }
                    hud.style.display = 'block';
                    snapAllWorkflowHUDs();
                }

                // Improved close: shift up any below HUDs if left/right closes
                function closeWorkflowHUD(hud) {
                    if (hud === leftHudOpen) {
                        leftHudOpen = null;
                        hud.style.display = 'none';

                        // Shift up: If rightHudOpen exists, move it to left
                        if (rightHudOpen && rightHudOpen.style.display !== 'none') {
                            leftHudOpen = rightHudOpen;
                            snapHudLeftOfCanvas(leftHudOpen);
                            rightHudOpen = null;

                            // If there are HUDs below, move first to right
                            if (belowHudStack.length > 0) {
                                rightHudOpen = belowHudStack.shift();
                                snapHudRightOfCanvas(rightHudOpen);
                            }
                        }
                    } else if (hud === rightHudOpen) {
                        rightHudOpen = null;
                        hud.style.display = 'none';

                        // Shift up: If there are HUDs below, move first up to right
                        if (belowHudStack.length > 0) {
                            rightHudOpen = belowHudStack.shift();
                            snapHudRightOfCanvas(rightHudOpen);
                        }
                    } else {
                        // If HUD is stacked below, just remove from stack
                        belowHudStack = belowHudStack.filter(h => h !== hud);
                        hud.style.display = 'none';
                    }
                    snapAllWorkflowHUDs();
                }

                function detachWorkflowHUD(hud) {
                    if (!hud) return;

                    let layoutChanged = false;

                    if (leftHudOpen === hud) {
                        leftHudOpen = null;
                        layoutChanged = true;
                    }

                    if (rightHudOpen === hud) {
                        rightHudOpen = null;
                        layoutChanged = true;
                        if (belowHudStack.length > 0) {
                            rightHudOpen = belowHudStack.shift();
                            if (rightHudOpen) snapHudRightOfCanvas(rightHudOpen);
                        }
                    }

                    const filteredStack = belowHudStack.filter(h => h !== hud);
                    if (filteredStack.length !== belowHudStack.length) {
                        belowHudStack = filteredStack;
                        layoutChanged = true;
                    }

                    if (layoutChanged) snapAllWorkflowHUDs();
                }

                function showWorkflowHUD(target) {
                    const hud = typeof target === 'string'
                        ? document.getElementById(target)
                        : target;
                    if (!hud) return;
                    openWorkflowHUD(hud);
                }

                function hideWorkflowHUD(target) {
                    const hud = typeof target === 'string'
                        ? document.getElementById(target)
                        : target;
                    if (!hud) return;
                    closeWorkflowHUD(hud);
                }

                window.showWorkflowHUD = showWorkflowHUD;
                window.hideWorkflowHUD = hideWorkflowHUD;

                // Responsive
                window.addEventListener('resize', scheduleHudSnap);

                // Hook up buttons

                closeImageHUD.onclick = () => closeWorkflowHUD(workflowImageHUD);
                closeLightingHUD.onclick = () => closeWorkflowHUD(workflowLightingHUD);
                closeStylizeHUD.onclick = () => closeWorkflowHUD(workflowStylizeHUD);
                close3DHUD.onclick = () => closeWorkflowHUD(workflow3DHUD);
                closeVideoHUD.onclick = () => closeWorkflowHUD(workflowVideoHUD);

                // ------- 3D HUD Notched Sliders -------
                const qualityLabels = ["128", "256", "384", "512", "768"];
                const smoothingLabels = ["1", "2", "3", "4", "5"];
                const defaultQualityIdx = 1; // "256"
                const defaultSmoothIdx = 0; // 1 iteration

                function makeNotchedSlider(parentId, count, labels, onChange, initialIdx) {
                    const container = document.getElementById(parentId);
                    container.innerHTML = ""; // Clear old
                    for (let i = 0; i < count; ++i) {
                        const notch = document.createElement("div");
                        notch.className = "notch";
                        notch.dataset.tip = labels[i];
                        notch.title = labels[i];
                        if (i === initialIdx) notch.classList.add("selected");
                        notch.addEventListener("mouseenter", () => {
                            container.querySelectorAll('.notch').forEach(n => n.classList.remove('hovered'));
                            notch.classList.add('hovered');
                        });
                        notch.addEventListener("mouseleave", () => {
                            notch.classList.remove('hovered');
                        });
                        notch.addEventListener("click", () => {
                            container.querySelectorAll('.notch').forEach(n => n.classList.remove('selected'));
                            notch.classList.add("selected");
                            onChange(i, labels[i]);
                        });
                        container.appendChild(notch);
                    }
                }

                // Mount both sliders with state
                let qualityIdx = defaultQualityIdx;
                let smoothIdx = defaultSmoothIdx;

                function updateShapeQuality(idx, label) {
                    qualityIdx = idx;
                    document.getElementById("shapeQualityLabel").textContent = `Resolution: ${label}px`;
                }
                function updateSmoothing(idx, label) {
                    smoothIdx = idx;
                    document.getElementById("smoothingLabel").textContent = `Smoothing: ${label}`;
                }

                // On page load:
                makeNotchedSlider("shapeQualitySlider", 5, qualityLabels, updateShapeQuality, defaultQualityIdx);
                makeNotchedSlider("smoothingSlider", 5, smoothingLabels, updateSmoothing, defaultSmoothIdx);
                updateShapeQuality(defaultQualityIdx, qualityLabels[defaultQualityIdx]);
                updateSmoothing(defaultSmoothIdx, smoothingLabels[defaultSmoothIdx]);

                // Additional 3D pipeline shape
                const shapeOnlyBtn = document.getElementById("shapeOnlyBtn");
                const shapeAndTexBtn = document.getElementById("shapeAndTexBtn");

                [{ btn: shapeOnlyBtn, label: "3D Shape Only… starting" },
                { btn: shapeAndTexBtn, label: "3D Shape + Texture… starting" }]
                    .forEach(({ btn, label }) => {
                        if (!btn) return;                     // skip if markup missing
                        btn.addEventListener("click", () => {
                            setActionText(label);
                            btn.classList.add("seafoam30Active", "processing");
                            setTimeout(() => {
                                btn.classList.remove("seafoam30Active", "processing");
                            }, 2300);                         // same 2.3-s cycle
                        });
                    });

                // Prompt Workflow HUD
                document.addEventListener("DOMContentLoaded", () => {
                    const homePromptContainer = document.getElementById("homePromptContainer");

                    // 1a) Append it to body (or a top-level container) so it’s absolutely centered
                    document.body.appendChild(homePromptContainer);

                    // 1b) Add the homeCenterMode class to center it
                    homePromptContainer.classList.add("homeCenterMode");

                    // 1c) Show it
                    homePromptContainer.style.display = "block";
                    updatePromptHudTitle();

                    // 2) Initially, you might hide the model dropdown if no BG is loaded
                    if (bgHoverArea) {
                        //bgHoverArea.style.cursor = imageCursorBulb;
                        bgHoverArea.style.cursor = "pointer";
                        bgHoverArea.addEventListener("click", () => bgFromComputerBtn.click());
                        bgHoverArea.addEventListener("mouseenter", () => {
                            if (homeImage) homeImage.src = "/lumify_import.png";
                        });
                        bgHoverArea.addEventListener("mouseleave", () => {
                            if (homeImage) homeImage.src = "/lumify.png";
                        });
                    }
                    if (homeImage) {
                        // ensure default image when not hovering
                        homeImage.src = "/lumify.png";
                    }
                    document.getElementById("homePromptModelSelect").style.display = "none";
                });

                const historyPanel = document.getElementById('historyPanel');
                const historyPanelToggle = document.getElementById('historyPanelToggle');
                const closeHistoryPanel = document.getElementById('closeHistoryPanel');
                const clearHistoryBtn = document.getElementById('clearHistoryBtn');
                const historyModeToggle = document.getElementById('historyModeToggle');
                const workflowsTab = document.getElementById('workflowsTab');
                const workflowsDrawer = document.getElementById('workflowsDrawer');
                const wfImg = document.getElementById('workflowDrawerImageBtn');
                const wfPrompt = document.getElementById('workflowDrawerPromptBtn');
                const wf3D = document.getElementById('workflowDrawer3DBtn');
                const wfVideo = document.getElementById('workflowDrawerVideoBtn');
                const wfStylize = document.getElementById('workflowDrawerStylizeBtn');
                const wfRecent = document.getElementById('workflowDrawerRecentBtn');
                const promptHud = document.getElementById('homePromptContainer');
                const wfLighting = document.getElementById('workflowDrawerLightingBtn');
                const wfMaterial = document.getElementById('workflowDrawerMaterialBtn');
                const wfTime = document.getElementById('workflowDrawerTimeBtn');

                // Allow pasting prompt/parameters into Prompt HUD when hovered
                let promptHudHovered = false;
                promptHud.addEventListener('mouseenter', () => { promptHudHovered = true; });
                promptHud.addEventListener('mouseleave', () => { promptHudHovered = false; });

                document.addEventListener('paste', (e) => {
                    if (!promptHudHovered) return;
                    const text = e.clipboardData?.getData('text') || '';
                    if (!text) return;
                    e.preventDefault();

                    const lines = text.split(/\r?\n/);
                    lines.forEach(line => {
                        const idx = line.indexOf(':');
                        if (idx === -1) return;
                        const key = line.slice(0, idx).trim().toLowerCase();
                        const val = line.slice(idx + 1).trim();
                        switch (key) {
                            case 'prompt': {
                                const el = document.getElementById('homePromptInput');
                                if (el) {
                                    el.value = val;
                                    el.dispatchEvent(new Event('input', { bubbles: true }));
                                }
                                break;
                            }
                            case 'negative': {
                                const neg = document.getElementById('i2iNegativePromptInput');
                                if (neg) {
                                    neg.value = val;
                                    neg.dispatchEvent(new Event('input', { bubbles: true }));
                                }
                                break;
                            }
                            case 'guidance': {
                                const g = document.getElementById('paramPrompt');
                                if (g) {
                                    g.value = val;
                                    g.dispatchEvent(new Event('input', { bubbles: true }));
                                }
                                break;
                            }
                            case 'steps': {
                                const s = document.getElementById('paramSteps');
                                if (s) {
                                    s.value = val;
                                    s.dispatchEvent(new Event('input', { bubbles: true }));
                                }
                                break;
                            }
                            case 'seed': {
                                const sd = document.getElementById('paramSeed');
                                if (sd) {
                                    sd.value = val;
                                    sd.dispatchEvent(new Event('input', { bubbles: true }));
                                }
                                break;
                            }
                            case 'strength':
                            case 'creative': {
                                const c = document.getElementById('paramCreative');
                                if (c) {
                                    c.value = val;
                                    c.dispatchEvent(new Event('input', { bubbles: true }));
                                }
                                break;
                            }
                            case 'resolution': {
                                const r = document.getElementById('paramResolution');
                                if (r) {
                                    r.value = val;
                                    r.dispatchEvent(new Event('change', { bubbles: true }));
                                }
                                break;
                            }
                            default:
                                break;
                        }
                    });

                    if (typeof setActionText === 'function') {
                        setActionText('Prompt parameters pasted');
                    }
                });

                function updateDrawerHighlight(btn, hud) {
                    btn.classList.toggle('seafoam30Active', hud.style.display !== 'none');
                }
                historyPanel.addEventListener('mouseleave', endHistoryPreview);

                // Toggle history panel open/closed when tab clicked
                historyPanelToggle.onclick = () => {
                    const isOpen = historyPanel.classList.contains('open');
                    if (isOpen) {
                        historyPanel.classList.remove('open');
                        historyPanel.classList.add('closed');
                    } else {
                        historyPanel.classList.add('open');
                        historyPanel.classList.remove('closed');
                        requestAnimationFrame(refreshHistoryScrollControls);
                    }
                };

                historyModeToggle.addEventListener('click', async () => {
                    historyMode = historyMode === 'images' ? 'videos' : 'images';
                    historyModeToggle.innerHTML = historyMode === 'images'
                        ? '<i class="fas fa-video"></i>'
                        : '<i class="fas fa-image"></i>';
                    historyModeToggle.setAttribute('data-tip', historyMode === 'images' ? 'Show video history' : 'Show image history');
                    if (historyMode === 'videos') {
                        await loadVideoHistory();
                    }
                    updateHistoryThumbs();
                });

                workflowsTab.onclick = () => {
                    workflowsDrawer.classList.toggle('open');
                };

                wfImg.onclick = () => {
                    document.getElementById('workflowImageBtn').click();
                    updateDrawerHighlight(wfImg, workflowImageHUD);
                    workflowsDrawer.classList.remove('open');
                };
                wfLighting.onclick = () => {
                    document.getElementById('workflowLightingBtn').click();
                    updateDrawerHighlight(wfLighting, workflowLightingHUD);
                    workflowsDrawer.classList.remove('open');
                };
                wfMaterial.onclick = () => {
                    document.getElementById('workflowMaterialBtn').click();
                    updateDrawerHighlight(wfMaterial, workflowMaterialHUD);
                    workflowsDrawer.classList.remove('open');
                };
                wfTime.onclick = () => {
                    document.getElementById('workflowTimeBtn').click();
                    updateDrawerHighlight(wfTime, workflowTimeHUD);
                    workflowsDrawer.classList.remove('open');
                };
                wfStylize.onclick = () => {
                    document.getElementById('workflowStylizeBtn').click();
                    updateDrawerHighlight(wfStylize, workflowStylizeHUD);
                    workflowsDrawer.classList.remove('open');
                };
                wfPrompt.onclick = () => {
                    document.getElementById('workflowPromptBtn').click();
                    updateDrawerHighlight(wfPrompt, promptHud);
                    workflowsDrawer.classList.remove('open');
                };
                wf3D.onclick = () => {
                    document.getElementById('workflow3DBtn').click();
                    updateDrawerHighlight(wf3D, workflow3DHUD);
                    workflowsDrawer.classList.remove('open');
                };
                wfVideo.onclick = () => {
                    document.getElementById('workflowVideoBtn').click();
                    updateDrawerHighlight(wfVideo, workflowVideoHUD);
                    workflowsDrawer.classList.remove('open');
                };
                wfRecent.onclick = () => {
                    if (recentOverlay.style.display === 'block') {
                        recentOverlay.style.display = 'none';
                    } else {
                        populateRecentOverlay();
                        recentOverlay.style.display = 'block';
                    }
                    workflowsDrawer.classList.remove('open');
                };

                // Close panel with X button
                closeHistoryPanel.onclick = () => {
                    historyPanel.classList.remove('open');
                    historyPanel.classList.add('closed');
                    //setTimeout(() => {
                    //    historyPanelToggle.style.display = "flex";
                    //}, 250);
                };

                clearHistoryBtn.onclick = () => {
                    // Ensure any active preview/lock state is cleared so the canvas
                    // reflects the true "current" image after history removal.
                    endHistoryPreview();
                    resetBeforeAfterState();

                    if (beforeLockIndex !== -1) {
                        const locked = sessionOutputs[beforeLockIndex];
                        sessionOutputs = [locked];
                        beforeLockIndex = 0;
                        currentOutIndex = 0;
                        selectedHistoryIndex = 0;
                        backgroundImage = locked.img;
                    } else {
                        sessionOutputs = [];
                        currentOutIndex = -1;
                        selectedHistoryIndex = -1;
                        beforeLockIndex = -1;
                        backgroundImage = liveBGImage;
                    }
                    stickers = liveFGStickers.map(cloneSticker);
                    depthImage = null;
                    isOverlayVisible = false;

                    computeBgLayout(backgroundImage);
                    updateFgStickerVisibility();
                    drawCanvas();
                    updateHistoryThumbs();
                };


                // Optional: Always keep the toggle vertically aligned with canvas
                //function positionHistoryToggle() {
                //    const wrapper = document.getElementById("canvasWrapper");
                //    const tab = document.getElementById("historyPanelToggle");
                //    if (!wrapper || !tab) return;
                //    const rect = wrapper.getBoundingClientRect();
                //    tab.style.right = (rect.right - tab.offsetWidth - 40) + "px";
                //}
                //window.addEventListener("resize", positionHistoryToggle);
                //setTimeout(positionHistoryToggle, 100);

                function cloneSticker(st) {
                    return {
                        ...st,
                        img: st.img,
                        flipBookImages: st.flipBookImages ? st.flipBookImages.slice() : undefined,
                        flipBookIndex: st.flipBookIndex ?? 0,
                        x: st.x,
                        y: st.y,
                        scale: st.scale,
                        flipX: st.flipX,
                        hidden: st.hidden,
                        domButton: null,
                        domElement: null,
                        domFocus: null,
                    };
                }

                // 2) When the user loads a BG image, do something like:
                function onBackgroundImageLoaded() {
                    // We can display the model dropdown now:
                    document.getElementById("homePromptModelSelect").style.display = "inline-block";
                    // And if you like, also hide the home screen container or do something else
                    // ...
                }

                function snapPromptBelowCanvas(hud) {
                    const wrap = document.getElementById('canvasWrapper').getBoundingClientRect();
                    const gap = 8;   // px below canvas
                    const margin = 6;   // keep away from viewport edge

                    hud.style.position = 'absolute';
                    hud.style.top = `${wrap.bottom + gap}px`;
                    hud.style.left = `${wrap.left + (wrap.width - hud.offsetWidth) / 2}px`;

                    if (parseInt(hud.style.left, 10) < margin) hud.style.left = `${margin}px`;
                }

                const promptBox = document.getElementById("homePromptInput");
                promptBox.addEventListener("input", () => {
                    promptBox.style.height = "auto";              // shrink if needed
                    promptBox.style.height = promptBox.scrollHeight + "px";
                });

                // 3) “Prompt Workflow” button -> place container below the caption bar
                workflowPromptBtn.addEventListener("click", () => {
                    const hud = document.getElementById("homePromptContainer");
                    if (hud.style.display !== "none") {
                        hud.style.display = "none";
                        setActionText("Prompt HUD closed");
                    } else {
                        hud.classList.remove("homeCenterMode", "promptHudMode");
                        hud.style.position = "";
                        hud.style.top = "";   // reset any previous manual pos
                        hud.style.left = "";
                        hud.style.transform = "";
                        hud.style.display = "block";
                        hud.classList.add("promptHudMode");
                        openWorkflowHUD(promptHud);
                        // Important: Snap after a forced reflow so offsetWidth is correct
                        requestAnimationFrame(() => snapPromptBelowCanvas(homePromptContainer));
                        makeDraggable(hud, homePromptInner, ".noDrag");

                        setActionText("Prompt HUD opened");
                    }
                    updateDrawerHighlight(wfPrompt, promptHud);
                });

                // Responsive repositioning, only if in workflow mode
                window.addEventListener('resize', () => {
                    snapAllWorkflowHUDs();
                    if (homePromptContainer.style.display !== 'none' && homePromptContainer.classList.contains('promptHudMode')) {
                        snapPromptBelowCanvas(homePromptContainer);
                    }
                });

                updatePromptHudTitle();              // choose correct heading
                refreshDrawerState();
                hideHomePromptCaption();                  // keep caption hidden after first use
                setActionText("Prompt HUD opened");

                // Import FG on empty canvas unless SAM Click Mode is active
                //document.getElementById("canvas").addEventListener("click", (e) => {
                //    if (isCanvasClean() && !isClickMode) {
                //        document.getElementById("fgImageBtn").click();
                //    }
                //});
                document.addEventListener("DOMContentLoaded", () => {
                    updateCanvasCursorState();
                });

                function isCanvasClean() {
                    return document.querySelectorAll(".stickerDom").length === 0;
                }

                function updateCanvasCursorState() {
                    //const isClean = isCanvasClean();
                    const tip = document.getElementById("floatingCanvasTip");

                    //if (isClean) {
                    //    canvas.classList.add("clickable");
                    //    canvas.style.cursor = imageCursor;
                    //} else {
                    //    canvas.classList.remove("clickable");
                    //    canvas.style.cursor = "default";
                    //}
                    canvas.classList.remove("clickable");
                    canvas.style.cursor = "default";

                    tip.classList.remove("visible");
                }

                function showCanvasHoverTip(e) {
                    const tip = document.getElementById("floatingCanvasTip");

                    if (canvas.classList.contains("clickable")) {
                        const offset = 20;
                        tip.style.left = `${e.clientX}px`;
                        tip.style.top = `${e.clientY + offset}px`;
                        tip.style.transform = "translate(-50%, 0)";
                        tip.classList.add("visible");
                    } else {
                        tip.classList.remove("visible");
                    }
                }

                function showCanvasHoverTip(e) {
                    const tip = document.getElementById("floatingCanvasTip");

                    if (isCanvasClean()) {
                        const offset = 20;
                        tip.style.left = `${e.clientX}px`;
                        tip.style.top = `${e.clientY + offset}px`;
                        tip.style.transform = "translate(-50%, 0)";
                        tip.classList.add("visible");
                    } else {
                        tip.classList.remove("visible");
                    }
                }


                // Flux Settings Listener
                document.addEventListener("DOMContentLoaded", () => {
                    toggleBt.style.display = 'flex';
                    refreshDrawerState();
                    /* Text‑to‑Image sliders */
                    const txt2ImgGuidance = document.getElementById("txt2ImgGuidance");
                    const txt2ImgGuidanceVal = document.getElementById("txt2ImgGuidanceVal");
                    const txt2ImgSteps = document.getElementById("txt2ImgSteps");
                    const txt2ImgStepsVal = document.getElementById("txt2ImgStepsVal");

                    const updateTxt2ImgLabels = () => {
                        txt2ImgGuidanceVal.textContent = txt2ImgGuidance.value;
                        txt2ImgStepsVal.textContent = txt2ImgSteps.value;
                    };

                    /* initialise and keep in sync */
                    updateTxt2ImgLabels();
                    [txt2ImgGuidance, txt2ImgSteps].forEach(sl =>
                        sl.addEventListener("input", updateTxt2ImgLabels)
                    );
                });
                // Video Processing
                function pulseComfyDot() {
                    const dot = document.getElementById("comfyDot");
                    dot.classList.add("glow");
                    setTimeout(() => dot.classList.remove("glow"), 900);
                }

                function getI2VFields() {
                    // already in your file; keep your original if present
                    const hudPrompt = document.getElementById("videoPromptHud");
                    const hudStyle = document.getElementById("videoStyleSelectHud");
                    const setPrompt = document.getElementById("img2VideoPrompt");
                    const setStyle = document.getElementById("img2VideoStyle");
                    return {
                        prompt: hudPrompt?.value || setPrompt?.value || "",
                        style: hudStyle?.value || setStyle?.value || ""
                    };
                }

                function kickOffComfyJob(mode /* 'img' | 'seq' */) {
                    if (!comfyLink.enabled || !comfyLink.connected) {
                        setActionText("Comfy is offline — click “Send → Comfy UI” to connect.");
                        return;
                    }

                    pulseComfyDot();
                    setActionText(`${mode === 'seq' ? 'Seq' : 'Image'} → Video: queuing on Comfy…`);

                    // 1) Indeterminate progress for “queue”
                    startProcessBar();                // no jobId => sweeping bar
                    setTimeout(async () => {
                        stopProcessBar();               // switch over to real progress

                        // 2) Prepare payload and post with synced progress
                        const dataUrl = canvas.toDataURL("image/png");
                        const { prompt, style } = getI2VFields();
                        const payload = { dataUrl, prompt, style, fps: 24, seconds: 4, mode };

                        postWithProgress("/comfy/send-i2v", payload, ({ job_id }) => {
                            // 3) Poll lightweight job endpoint for stage + video path
                            const poll = setInterval(async () => {
                                const info = await fetchJsonSafe(`${API_BASE}/comfy/job/${job_id}`);
                                if (info?.stage) setActionText(`WAN ${mode}2v: ${info.stage}`);
                                if (info?.status === "done" && info.video) {
                                    clearInterval(poll);
                                    const src = `${API_BASE}/${info.video}?t=${Date.now()}`;
                                    setActionText("Preview ready.");
                                    showWanPreview(src);
                                }
                            }, 600);                      // a bit slower polling reads as “more real”
                        });
                    }, 1300);                         // slow queue delay
                }
                document.addEventListener("DOMContentLoaded", () => {
                    const img2VideoBtn = document.getElementById("img2VideoBtn");
                    const frames2VideoBtn = document.getElementById("frames2VideoBtn");

                    img2VideoBtn?.addEventListener("click", () => kickOffComfyJob('img'));
                    frames2VideoBtn?.addEventListener("click", () => kickOffComfyJob('seq'));
                });

                // ENHANCE PREVIEW
                const enhancePreviewOverlay = document.getElementById("enhancePreviewOverlay");
                const enhancePreviewBox = document.getElementById("enhancePreviewBox");
                const closeEnhancePreviewBtn = document.getElementById("closeEnhancePreviewBtn");
                const fullscreenEnhancePreviewBtn = document.getElementById("fullscreenEnhancePreviewBtn");
                const downloadEnhancePreviewBtn = document.getElementById("downloadEnhancePreviewBtn");
                const enhancePreviewImg = document.getElementById("enhancePreviewImg");

                // Additional dynamic buttons for toggle/magnify Enhanced
                const toggleEnhanceBtn = document.createElement("div");
                toggleEnhanceBtn.id = "toggleEnhanceBtn";
                toggleEnhanceBtn.title = "Toggle Enhanced Image";
                toggleEnhanceBtn.style.display = "none";
                toggleEnhanceBtn.style.cursor = "pointer";
                toggleEnhanceBtn.style.fontSize = "18px";
                toggleEnhanceBtn.style.background = "#2b2f35";
                toggleEnhanceBtn.style.borderRadius = "4px";
                toggleEnhanceBtn.style.padding = "6px 8px";
                toggleEnhanceBtn.style.border = "1px solid #444";
                toggleEnhanceBtn.innerHTML = `<i class="fas fa-wand-magic-sparkles"></i>`;

                const magnifyEnhanceBtn = document.createElement("div");
                magnifyEnhanceBtn.id = "magnifyEnhanceBtn";
                magnifyEnhanceBtn.title = "View Enhanced Image Full Size";
                magnifyEnhanceBtn.style.display = "none";
                magnifyEnhanceBtn.style.cursor = "pointer";
                magnifyEnhanceBtn.style.fontSize = "18px";
                magnifyEnhanceBtn.style.background = "#2b2f35";
                magnifyEnhanceBtn.style.borderRadius = "4px";
                magnifyEnhanceBtn.style.padding = "6px 8px";
                magnifyEnhanceBtn.style.border = "1px solid #444";
                magnifyEnhanceBtn.innerHTML = `<i class="fas fa-search-plus"></i>`;

                document.getElementById("captionBarContainer").appendChild(toggleEnhanceBtn);
                document.getElementById("captionBarContainer").appendChild(magnifyEnhanceBtn);

                // Slider Grads
                function setSliderGradient(slider, accent = "rgba(22,191,167,0.25)", bg = "#23292d") {
                    // Calculate filled percent
                    const min = parseFloat(slider.min);
                    const max = parseFloat(slider.max);
                    const val = parseFloat(slider.value);
                    const percent = 100 * (val - min) / (max - min);

                    // Set background gradient (before thumb = accent, after = bg)
                    slider.style.background =
                        `linear-gradient(90deg, ${accent} ${percent}%, ${bg} ${percent}%)`;
                }

                // Initialize and update all stealthSliders
                document.querySelectorAll('input[type=range]').forEach(slider => {
                    setSliderGradient(slider);
                    slider.addEventListener('input', function () {
                        setSliderGradient(slider);
                    });
                });

                function activateHudSection(sectionId) {
                    // Remove .active from all section headers
                    document.querySelectorAll('.hudSectionHeader').forEach(h => h.classList.remove('active'));
                    // Add .active to the target section
                    document.getElementById(sectionId).classList.add('active');
                }
                // Focus Button Workflow HUD
                document.querySelectorAll(".hudSection .sectionFocusBtn").forEach(focusDot => {
                    focusDot.addEventListener("click", () => {
                        const thisSection = focusDot.closest(".hudSection");
                        const thisBody = thisSection.querySelector(".hudSectionBody");
                        const isActivating = !focusDot.classList.contains("active");

                        // step 1 – clear every dot / body
                        document.querySelectorAll(".sectionFocusBtn").forEach(dot => dot.classList.remove("active"));
                        document.querySelectorAll(".hudSectionBody").forEach(b => b.classList.add("collapsed"));

                        if (isActivating) {
                            // vanilla single-section focus
                            thisBody.classList.remove("collapsed");
                            focusDot.classList.add("active");
                        } else {
                            // toggled off ⇒ restore everything
                            document.querySelectorAll(".hudSectionBody").forEach(b => b.classList.remove("collapsed"));
                        }
                    });
                });

                // HUD SectionHeader accents
                document.addEventListener("DOMContentLoaded", function () {
                    document.querySelectorAll('.hudScrollArea').forEach(scrollArea => {
                        const sections = Array.from(scrollArea.querySelectorAll('.hudSection'));
                        const sectionHeaders = [];
                        const sectionBodies = [];
                        const bodyToHeader = new Map();

                        sections.forEach(sec => {
                            const header = sec.querySelector('.hudSectionHeader');
                            const body = sec.querySelector('.hudSectionBody');
                            if (body) {
                                sectionBodies.push(body);
                                bodyToHeader.set(body, header);
                            }
                            if (header) sectionHeaders.push(header);
                        });

                        if (!sectionBodies.length) return;

                        let lastActiveHeader = null;

                        const observer = new IntersectionObserver((entries) => {
                            let activeHeader = null;
                            let maxRatio = 0;

                            entries.forEach(entry => {
                                if (entry.intersectionRatio > maxRatio && entry.isIntersecting) {
                                    const header = bodyToHeader.get(entry.target);
                                    if (header) {
                                        maxRatio = entry.intersectionRatio;
                                        activeHeader = header;
                                    }
                                }
                            });

                            sectionHeaders.forEach(h => h.classList.remove('active'));
                            if (activeHeader) activeHeader.classList.add('active');
                            lastActiveHeader = activeHeader;
                        }, {
                            root: scrollArea,
                            threshold: [0.20]
                        });

                        sectionBodies.forEach(body => observer.observe(body));

                        scrollArea.querySelectorAll('.sectionFocusBtn').forEach(btn => {
                            btn.addEventListener("click", function (e) {
                                e.stopPropagation();
                                sectionHeaders.forEach(h => h.classList.remove('active'));
                                let header = btn.closest('.hudSectionHeader');
                                if (header) header.classList.add('active');
                                lastActiveHeader = header;
                            });
                        });

                        sectionHeaders.forEach(header => {
                            header.addEventListener('mouseenter', function () {
                                sectionHeaders.forEach(h => h.classList.remove('active'));
                                header.classList.add('active');
                                lastActiveHeader = header;
                            });
                            header.addEventListener('mouseleave', function () {
                                sectionHeaders.forEach(h => h.classList.remove('active'));
                                if (lastActiveHeader) lastActiveHeader.classList.add('active');
                            });
                        });
                    });
                });

                let fakeBarRAF = null;

                function fakeProcessBar(duration = 10000) { // 8 seconds by default
                    stopProcessBar(); // Clear any previous bar
                    barFill.style.width = '0%';
                    barWrap.style.display = 'block';
                    const start = Date.now();

                    function animate() {
                        if (!barWrap.style.display || barWrap.style.display === 'none') return;
                        const elapsed = Date.now() - start;
                        const pct = Math.min(elapsed / duration, 1);
                        barFill.style.width = (pct * 100) + '%';

                        if (pct < 1) {
                            fakeBarRAF = requestAnimationFrame(animate);
                        }
                    }
                    fakeBarRAF = requestAnimationFrame(animate);
                }

                function stopFakeProcessBar() {
                    barWrap.style.display = 'none';
                    if (fakeBarRAF) cancelAnimationFrame(fakeBarRAF);
                    fakeBarRAF = null;
                }

                // DropDown Button grace period timer
                const navImport = document.getElementById("navImport");
                const importMenu = document.getElementById("importMenu");

                let hideMenuTimer = null;

                // When the mouse enters the main nav item or the submenu, clear any pending "hide" timer
                navImport.addEventListener("mouseenter", () => {
                    clearTimeout(hideMenuTimer);
                    importMenu.style.visibility = "visible";
                    importMenu.style.opacity = 1;
                });
                importMenu.addEventListener("mouseenter", () => {
                    clearTimeout(hideMenuTimer);
                });

                // When the mouse leaves, start a short timer. If the user moves back in quickly, we cancel it.
                navImport.addEventListener("mouseleave", () => {
                    hoverWX = hoverWY = null;
                    importMenu.style.opacity = 0;             // fade (or no-fade) now
                    hideMenuTimer = setTimeout(() => {
                        importMenu.style.visibility = "hidden";
                    }, 20);
                });

                /* ------- slim progress bar helpers v3 ------- */
                function lerp(a, b, t) { return a + (b - a) * t; }

                function glide() {
                    _curr = lerp(_curr, _target, 0.18);            // ease-out
                    barFill.style.width = _curr.toFixed(1) + '%';
                    if (Math.abs(_target - _curr) > 0.2) _raf = requestAnimationFrame(glide);
                    else { cancelAnimationFrame(_raf); _raf = null; }
                }

                function startProcessBar(jobId = null) {
                    cancelAnimationFrame(_raf || 0);
                    clearInterval(_pollTimer || 0);
                    clearInterval(barFill._loop || 0);

                    _curr = _target = 0;
                    barFill.style.width = '0%';
                    barWrap.style.display = 'block';

                    /* 1️⃣  backend sync (preferred) */
                    if (jobId) {                       // ⇢ synced mode
                        _pollTimer = setInterval(async () => {
                            try {
                                const { progress } =
                                    await (await fetch(`${API_BASE}/progress?job=${jobId}`)).json();
                                if (progress != null) {
                                    _target = Math.min(Math.max(progress, 0), 1) * 100;
                                    if (!_raf) _raf = requestAnimationFrame(glide);
                                }
                            } catch (_) { }
                        }, 300);                         // faster tick = smoother bar
                    } else {                           // ⇢ indeterminate sweep
                        let pct = 0;
                        barFill._loop = setInterval(() => {
                            pct = (pct + 2) % 102;
                            barFill.style.width = pct + '%';
                        }, 90);
                    }
                }

                function stopProcessBar() {
                    cancelAnimationFrame(_raf || 0);
                    clearInterval(_pollTimer || 0);
                    clearInterval(barFill._loop || 0);
                    _pollTimer = barFill._loop = _raf = null;
                    barWrap.style.display = 'none';
                }

                function uuid() { return crypto.randomUUID(); }

                async function fetchJsonSafe(url, options) {
                    const resp = await fetch(url, options);
                    const text = await resp.text();
                    if (!resp.ok) {
                        return { error: text || resp.statusText };
                    }
                    try {
                        return JSON.parse(text);
                    } catch (err) {
                        console.error('fetchJsonSafe => bad JSON:', text);
                        return { error: 'Invalid JSON' };
                    }
                }

                async function postWithProgress(endpoint, payload, onDone) {
                    payload.job_id = payload.job_id || uuid();
                    startProcessBar(payload.job_id);

                    try {
                        const res = await fetch(`${API_BASE}${endpoint}`, {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify(payload)
                        });
                        const json = await res.json();
                        if (json.error) {
                            setActionText(`${endpoint} ⇒ ${json.error}`);
                            return;
                        }
                        if (json.error && json.error.includes("busy")) {
                            setActionText("Model is busy – please wait for the running job to finish.");
                            stopProcessBar();
                            return;
                        }

                        // Wait a bit before stopping to allow progress to reach 100%
                        setTimeout(() => stopProcessBar(), 400);  // delay synced with backend flush
                        onDone(json);
                    } catch (e) {
                        setActionText(`${endpoint} ⇒ ${e.message}`);
                        stopProcessBar();
                    }
                }

                /******************************************************
                * Spinner Overlay
                ******************************************************/
                function loadNewBackgroundImage(url, skipAction = false) {
                    canvasSpinnerOverlay.style.display = "flex";

                    const bigImg = new Image();
                    bigImg.crossOrigin = "Anonymous";
                    bigImg.onload = () => {
                        canvasSpinnerOverlay.style.display = "none";
                        backgroundImage = bigImg;
                        userLoadedBg = true;
                        disableBgHoverArea();
                        computeBgLayout(bigImg);
                        depthImage = null;
                        imgGenImage = null;
                        segmentationMask = null;
                        refinedMaskImage = null;
                        //isOverlayVisible = false;
                        //toggleOverlayBtn.style.display = "none";

                        homeImageContainer.style.display = "none";
                        canvasContainer.style.display = "block";
                        updateCanvasCursorState();
                        mainHeader.style.display = "block";
                        drawCanvas();
                        bgFilenameDiv.style.display = "block";

                        if (!skipAction) {
                            setActionText("New BG loaded");
                            syncCaption();
                        }
                        updatePromptHudTitle();
                        refreshDrawerState();
                        const clean = url.split('?')[0];
                        //if (!recentImports.includes(clean)) {
                        //    recentImports.push(clean);
                        //    if (recentOverlay.style.display !== 'none') {
                        //        populateRecentOverlay();
                        //    }
                        //}
                        /*hideHomePromptHud();              // <‑‑ add this*/
                    };
                    bigImg.src = url;
                }

                /******************************************************
                 * INIT => fallback
                 ******************************************************/
                const placeholder = new Image();
                placeholder.onload = () => {
                    backgroundImage = placeholder;
                    computeBgLayout(placeholder);
                    drawCanvas();
                };
                placeholder.onerror = () => {
                    placeholder.src = FALLBACK_PLACEHOLDER_BASE64;
                };
                placeholder.src = "/lumify.png";

                /******************************************************
                 * computeBgLayout + drawCanvas
                 ******************************************************/
                let bgW = 0, bgH = 0; // track background layout
                function computeBgLayout(img) {

                    let w = img.naturalWidth;
                    let h = img.naturalHeight;
                    if (w > MAX_CANVAS_W || h > MAX_CANVAS_H) {
                        const ratio = Math.min(MAX_CANVAS_W / w, MAX_CANVAS_H / h);
                        w = Math.floor(w * ratio);
                        h = Math.floor(h * ratio);
                    }
                    canvas.width = overlayCanvas.width = w;
                    canvas.height = overlayCanvas.height = h;

                    baseW = canvas.width;
                    bgW = w;
                    bgH = h;
                    bgX = 0;
                    bgY = 0;
                    syncCaption();                  //  bar stays centred
                }
                function drawCanvas() {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.save();
                    ctx.translate(camOffsetX, camOffsetY);
                    ctx.scale(camScale, camScale);

                    // 1) Draw background if you have one
                    //console.log("DRAWING BG", backgroundImage && backgroundImage.src);
                    if (backgroundImage) {
                        if (todBlendOriginal && todBlendRatio < 1) {
                            ctx.drawImage(todBlendOriginal, 0, 0, bgW, bgH);
                            ctx.globalAlpha = todBlendRatio;
                            ctx.drawImage(backgroundImage, 0, 0, bgW, bgH);
                            ctx.globalAlpha = 1;
                        } else {
                            ctx.drawImage(backgroundImage, 0, 0, bgW, bgH);
                        }
                    }

                    // 2) Draw stickers
                    for (let i = 0; i < stickers.length; i++) {
                        const st = stickers[i];
                        if (!st.domElement) createStickerDOM(st);
                        if (!st.domFocus) createModeButton(st);

                        if (st.domElement?.style.visibility !== "hidden") {
                            if (isForegroundMode || !segmentationMask) drawStickerNoMask(st);
                            else drawStickerWithMask(st);
                        }
                        drawStickerBoundingBox(st, i);

                        updateStickerDOM(st);
                        layoutModeButton(st, i);
                    }

                    if (isOverlayVisible) {
                        if (depthImage) ctx.drawImage(depthImage, 0, 0, canvas.width, canvas.height);
                        if (imgGenImage) ctx.drawImage(imgGenImage, 0, 0, canvas.width, canvas.height);
                        if (isEnhanceVisible && enhanceImage) {
                            ctx.drawImage(enhanceImage, 0, 0, canvas.width, canvas.height);
                        }
                    }
                    if (
                        isGlbStamped &&
                        window.glbStickers && window.glbStickers.length &&
                        is3DActive &&
                        window.isGlbReady
                    ) {
                        const wrap = document.getElementById("canvasWrapper").getBoundingClientRect();
                        window.glbStickers.forEach(st => {
                            if (st.canvas.style.display === "none") return;
                            const rect = st.canvas.getBoundingClientRect();
                            const x = (rect.left - wrap.left - camOffsetX) / camScale;
                            const y = (rect.top - wrap.top - camOffsetY) / camScale;
                            const w = rect.width / camScale;
                            const h = rect.height / camScale;
                            ctx.drawImage(st.canvas, x, y, w, h);
                        });
                        updateGlbPreviewImage();
                        if (typeof syncHud === "function") syncHud();
                    }

                    if (typeof __glbSyncHud === 'function') __glbSyncHud();
                    ctx.restore();
                    applyImageAdjustmentsToCanvas(canvas, ctx);
                    syncActionDrawerPosition();
                    syncMaterialHudPosition();
                    refreshMaterialHudTarget();
                }

                function syncMaterialHudPosition() {
                    const hud = document.getElementById('workflowMaterialHUD');
                    if (!hud || hud.style.display === 'none') return;
                    if (materialHudDocked) snapMaterialHudToSticker();
                }
                // Call this at the end of drawCanvas(), or whenever stickers move
                syncMaterialHudPosition();


                //function handleNewBG(url) {
                //    const img = new Image();
                //    img.crossOrigin = "Anonymous";
                //    img.onload = function () {
                //        backgroundImage = img;
                //        computeBgLayout(img);
                //        drawCanvas();
                //    };
                //    img.src = url;
                //}

                /* ---------- SMART-REDRAW  WRAPPER  ------------------------- */
                /* keep a reference to today’s “full” drawCanvas               */
                const _drawCanvasNow = drawCanvas;      // original implementation
                let drawPending = false;           // has a frame already been queued?

                /* replace drawCanvas with a scheduler */
                drawCanvas = function () {
                    if (drawPending) return;            // another call already queued
                    drawPending = true;
                    requestAnimationFrame(() => {
                        drawPending = false;
                        _drawCanvasNow();               // do the actual paint once
                    });
                };


                /******************************************************
                * drawStickerNoMask
                ******************************************************/
                function drawStickerNoMask(st) {
                    if (!st || !st.img || !st.img.complete || st.img.naturalWidth === 0) return;
                    ctx.save();
                    const w = st.img.width * st.scale;
                    const h = st.img.height * st.scale;
                    ctx.translate(st.x + w / 2, st.y + h / 2);
                    if (st.flipX) ctx.scale(-1, 1);
                    ctx.rotate(st.rotation || 0);
                    ctx.scale(st.scale, st.scale);
                    ctx.drawImage(st.img, -st.img.width / 2, -st.img.height / 2);
                    ctx.restore();
                }
                /******************************************************
                * drawStickerWithMask
                *   draw sticker and punch a hole where the SAM object is
                ******************************************************/
                function drawStickerWithMask(st) {
                    const mask = refinedMaskImage || segmentationMask;
                    if (!mask) { drawStickerNoMask(st); return; }

                    // 1) sticker → off‑screen
                    const sCan = document.createElement('canvas');
                    sCan.width = canvas.width;
                    sCan.height = canvas.height;
                    const sCtx = sCan.getContext('2d');

                    sCtx.save();
                    const w = st.img.width * st.scale;
                    const h = st.img.height * st.scale;
                    sCtx.translate(st.x + w / 2, st.y + h / 2);
                    if (st.flipX) sCtx.scale(-1, 1);
                    sCtx.rotate(st.rotation || 0);
                    sCtx.scale(st.scale, st.scale);
                    sCtx.drawImage(st.img, -st.img.width / 2, -st.img.height / 2);
                    sCtx.restore();

                    // 2) binary alpha mask
                    const mCan = document.createElement('canvas');
                    mCan.width = canvas.width;
                    mCan.height = canvas.height;
                    const mCtx = mCan.getContext('2d');
                    mCtx.drawImage(mask, 0, 0, canvas.width, canvas.height);
                    const img = mCtx.getImageData(0, 0, canvas.width, canvas.height);
                    const d = img.data;
                    for (let i = 0; i < d.length; i += 4) {
                        const gray = (d[i] + d[i + 1] + d[i + 2]) / 3;   // white = object
                        d[i + 3] = gray > 127 ? 255 : 0;
                    }
                    mCtx.putImageData(img, 0, 0);

                    // 3) compose
                    sCtx.globalCompositeOperation = isForegroundMode ? 'destination-in' : 'destination-out';
                    sCtx.drawImage(mCan, 0, 0);
                    sCtx.globalCompositeOperation = 'source-over';

                    // 4) back to main canvas
                    ctx.drawImage(sCan, 0, 0);
                }
                /******************************************************
                /* ---------- STICKER  OUTLINE  +  CORNER  PINS ---------- */
                function animateSpin(st) {
                    if (!st.spinAnim || !st.spinAnim.isSpinning) return;
                    drawCanvas();
                    if (st.spinAnim.isSpinning) {
                        requestAnimationFrame(() => animateSpin(st));
                    } else {
                        // Optionally, after spin, open the drawer or fade the icon, etc.
                    }
                }
                function drawStickerBoundingBox(st, idx) {
                    const w = st.img.width * st.scale;
                    const h = st.img.height * st.scale;
                    if (actionMenuOpenIndex === idx || ctrlDown || isRotatingSticker) return;

                    const isHovered = idx === hoveredStickerIndex;
                    const isSelected = selectedStickerIndices.has(idx);

                    /* — blue glow when selected — */
                    if (isSelected) {
                        ctx.save();
                        ctx.strokeStyle = "#549dd1";      // blue highlight
                        ctx.lineWidth = 2;
                        ctx.shadowColor = "#549dd1";
                        ctx.shadowBlur = 6; // subtle glow
                        ctx.strokeRect(st.x, st.y, w, h);
                        ctx.restore();
                    }

                    /* — corner pins (per-mode) — */
                    if (st.mode === "edit" && (isHovered || isSelected)) {
                        const pins = [
                            { cx: st.x, cy: st.y },
                            { cx: st.x + w, cy: st.y },
                            { cx: st.x, cy: st.y + h },
                            { cx: st.x + w, cy: st.y + h }
                        ];
                        pins.forEach(({ cx, cy }, pinIdx) => {
                            ctx.save();
                            ctx.beginPath();
                            ctx.arc(cx, cy, PIN_DRAW_R, 0, Math.PI * 2);

                            // Animate pop effect on hover
                            let radius = PIN_DRAW_R;
                            if (pinIdx === hoveredCornerIndex) {
                                radius += 1.5 + 0.5 * Math.sin(performance.now() / 250); // subtle pulse
                            }
                            ctx.arc(cx, cy, radius, 0, Math.PI * 2);

                            // Pin fill color: blue by default, seafoam when dragging
                            if (isResizingCorner && pinIdx === hoveredCornerIndex) {
                                ctx.fillStyle = "#22ffd3"; // seafoam green
                            } else if (pinIdx === hoveredCornerIndex) {
                                ctx.fillStyle = "#6dc2ed"; // bright blue
                            } else {
                                ctx.fillStyle = "#549dd1"; // base blue
                            }
                            ctx.globalAlpha = 0.92;
                            ctx.shadowColor = "#22aaff";
                            ctx.shadowBlur = (pinIdx === hoveredCornerIndex) ? 9 : 3;
                            ctx.fill();
                            ctx.restore();

                            // Optionally: draw a white or blue outline
                            ctx.save();
                            ctx.beginPath();
                            ctx.arc(cx, cy, radius, 0, Math.PI * 2);
                            ctx.lineWidth = 1.2;
                            ctx.strokeStyle = "#e1f0fd";
                            ctx.stroke();
                            ctx.restore();
                        });
                    }

                    //if (isHovered && flipButtonSide) {
                    //    const w = st.img.width * st.scale;
                    //    const h = st.img.height * st.scale;
                    //    const flipSize = 30;
                    //    const cy = st.y + h / 2;
                    //    const t = performance.now() / 320;
                    //    const pulse = 1.0 + 0.09 * Math.sin(t * 2);
                    //    ctx.save();
                    //    ctx.beginPath();
                    //    let cx = flipButtonSide === "left"
                    //        ? st.x + Math.floor(flipSize * 0.51)
                    //        : st.x + w - Math.floor(flipSize * 0.51);
                    //    ctx.arc(cx, cy, flipSize / 2 * pulse, 0, 2 * Math.PI);
                    //    ctx.fillStyle = "#101a25cc";
                    //    ctx.globalAlpha = 0.88;
                    //    ctx.shadowColor = "#2be0a5";
                    //    ctx.shadowBlur = 9;
                    //    ctx.fill();
                    //    ctx.restore();

                    //    ctx.save();
                    //    ctx.font = `bold ${flipSize * 0.7}px Inter, sans-serif`;
                    //    ctx.fillStyle = "#2be0a5";
                    //    ctx.textAlign = "center";
                    //    ctx.textBaseline = "middle";
                    //    ctx.fillText("⟷", cx, cy);
                    //    ctx.restore();
                    //}

                    // 1. Only show arrows if this sticker has an array of images (more than 1)
                    if (st.flipBookImages && st.flipBookImages.length > 1) {
                        if (isHovered) {
                            // Where to place arrows (inside top left and top right)
                            const w = st.img.width * st.scale;
                            const h = st.img.height * st.scale;
                            const arrowSize = 45;
                            const pad = 7;

                            // Pulse logic for subtle animation
                            const t = performance.now() / 340;
                            const pulse = 1.0 + 0.10 * Math.sin(t * 2); // 10% scale pop

                            // Draw Left Arrow (Prev)
                            // Centered spacing for arrows
                            const midX = st.x + w / 2;
                            const arrowGap = 55; // horizontal gap between centers (increase for more spacing)

                            // Example drawing loop inside drawStickerBoundingBox or similar
                            const leftArrowHovered = (st.arrowHover === "left");
                            const rightArrowHovered = (st.arrowHover === "right");

                            // Arrow color logic:
                            const arrowDefaultColor = "#eee";
                            const arrowHoverColor = "#31e9b1";

                            // Left arrow
                            ctx.save();
                            ctx.font = `bold ${arrowSize * 1.0}px Inter, sans-serif`;
                            ctx.fillStyle = leftArrowHovered ? arrowHoverColor : arrowDefaultColor;
                            ctx.textAlign = "center";
                            ctx.textBaseline = "middle";
                            ctx.shadowColor = leftArrowHovered ? "#31e9b1" : "#111";
                            ctx.shadowBlur = leftArrowHovered ? 10 : 4;
                            ctx.fillText("<", midX - arrowGap, st.y + 22);
                            ctx.restore();

                            // Right arrow
                            ctx.save();
                            ctx.font = `bold ${arrowSize * 1.0}px Inter, sans-serif`;
                            ctx.fillStyle = rightArrowHovered ? arrowHoverColor : arrowDefaultColor;
                            ctx.textAlign = "center";
                            ctx.textBaseline = "middle";
                            ctx.shadowColor = rightArrowHovered ? "#31e9b1" : "#111";
                            ctx.shadowBlur = rightArrowHovered ? 10 : 4;
                            ctx.fillText(">", midX + arrowGap, st.y + 22);
                            ctx.restore();

                            // Delete button at top center for non-original frames
                            if (st.flipBookIndex > 0) {
                                const delSize = 32;
                                ctx.save();
                                ctx.font = `bold ${delSize * 0.8}px Inter, sans-serif`;
                                ctx.textAlign = "center";
                                ctx.textBaseline = "middle";
                                ctx.fillStyle = st.deleteHover ? "#ff8a8a" : "rgba(255,80,80,0.9)";
                                ctx.shadowColor = st.deleteHover ? "#ff8a8a" : "#111";
                                ctx.shadowBlur = st.deleteHover ? 10 : 4;
                                ctx.fillText("✕", midX, st.y + 22);
                                ctx.restore();
                            }
                        }
                    }
                    if (isHovered) {
                        const w = st.img.width * st.scale;
                        const h = st.img.height * st.scale;
                        const actionY = st.y + h - 5; // Try -5 or even -7 for just inside the border
                        const actionX = st.x + w / 2;
                        const actionSize = 35;
                        const t = performance.now() / 320;
                        const pulse = 1.0 + 0.06 * Math.sin(t * 2);
                        const flipSize = 35;

                        // Left center side (vertical middle, near left edge)
                        if (flipButtonSide === "left") {
                            const flipPad = 15; // larger = closer, adjust as needed
                            const cx = st.x + flipSize / 2 - flipPad;
                            const cy = st.y + h / 2;
                            ctx.save();
                            ctx.font = `bold ${flipSize * 0.7}px Inter, sans-serif`;
                            ctx.fillStyle = "#2be0a5";
                            ctx.textAlign = "center";
                            ctx.textBaseline = "middle";
                            ctx.shadowColor = "#1fffd4";
                            ctx.shadowBlur = 7;
                            ctx.fillText("⟷", cx, cy);
                            ctx.restore();
                        }

                        // Right center side (vertical middle, near right edge)
                        if (flipButtonSide === "right") {
                            const flipPad = 15; // same pad as above
                            const cx = st.x + w - flipSize / 2 + flipPad;
                            const cy = st.y + h / 2;
                            ctx.save();
                            ctx.font = `bold ${flipSize * 0.7}px Inter, sans-serif`;
                            ctx.fillStyle = "#2be0a5";
                            ctx.textAlign = "center";
                            ctx.textBaseline = "middle";
                            ctx.shadowColor = "#1fffd4";
                            ctx.shadowBlur = 7;
                            ctx.fillText("⟷", cx, cy);
                            ctx.restore();
                        }

                        let highlight = (actionMenuHoverIndex === idx);
                        const showButton = (idx === actionMenuHoverIndex)      // pointer is on the target
                            || (idx === actionMenuOpenIndex);      // drawer is already open
                        if (showButton) {
                            ctx.save();
                            const barWidth = 21
                            const barHeight = 3.25
                            const barSpacing = 10
                            const cx = actionX;
                            const cy = actionY + 5 // slight vertical offset
                            let angle = 0;
                            if (st.spinAnim && st.spinAnim.isSpinning) {
                                // Calculate progress (0.0 to 1.0 over 200ms)
                                let t = Math.min((performance.now() - st.spinAnim.start) / 200, 1);
                                angle = t * (Math.PI / 2); // 0 → 90deg
                                if (t >= 1) st.spinAnim.isSpinning = false; // Animation done
                            }
                            ctx.translate(cx, cy);
                            ctx.rotate(angle);
                            ctx.translate(-cx, -cy);

                            for (let i = -1; i <= 1; i++) {
                                // --- White outline ---
                                ctx.beginPath();
                                ctx.lineWidth = 0.4  //tches corner pin outline
                                ctx.strokeStyle = "#151617";
                                ctx.rect(
                                    cx - barWidth / 2 - 1.2, // expand a little for stroke
                                    cy + i * barSpacing - barHeight / 2 - 1.2,
                                    barWidth + 2.4,
                                    barHeight + 2.4
                                );
                                ctx.stroke();

                                // --- Bar fill ---
                                ctx.beginPath();
                                ctx.fillStyle = highlight ? "#2be0a5" : "#232c29";
                                ctx.rect(
                                    cx - barWidth / 2,
                                    cy + i * barSpacing - barHeight / 2,
                                    barWidth,
                                    barHeight
                                );
                                ctx.fill();
                            }
                            ctx.restore();
                        }
                    }
                    ctx.restore();
                }

                const toggleHideFgBtn = document.getElementById("toggleHideFgBtn");
                toggleHideFgBtn.onclick = function () {
                    areFgStickersHidden = !areFgStickersHidden;
                    updateFgStickerVisibility();
                    stickers.forEach(st => {
                        st.domElement.style.visibility = areFgStickersHidden ? "hidden" : "visible";
                        st.hidden = areFgStickersHidden;
                        if (st.domFocus) st.domFocus.classList.toggle("active", !areFgStickersHidden);
                    });
                    liveFGStickers.forEach(st => { st.hidden = areFgStickersHidden; });
                    if (window.glbStickers && window.glbStickers.length) {
                        if (areFgStickersHidden) {
                            window._prevGlbVisible = window.isGlbVisible;
                            hide3DOverlay();
                            is3DActive = false;
                        } else if (window._prevGlbVisible) {
                            is3DActive = true;
                            restore3DOverlay();
                        }
                    }
                    drawCanvas();
                    updateFgToggleBtnVisual();
                    this.blur(); // Hide tooltip after click
                };

                function updateFgToggleBtnVisual() {
                    if (!toggleHideFgBtn) return;
                    if (areFgStickersHidden) {
                        toggleHideFgBtn.classList.add("toggled");
                        toggleHideFgBtn.innerHTML = '<i class="fas fa-eye-slash"></i>';
                        toggleHideFgBtn.setAttribute("data-tip", "Toggle FG Visibility");
                    } else {
                        toggleHideFgBtn.classList.remove("toggled");
                        toggleHideFgBtn.innerHTML = '<i class="fas fa-eye"></i>';
                        toggleHideFgBtn.setAttribute("data-tip", "Toggle FG Visibility");
                    }
                }

                // Always update toggle visual after any sticker/canvas show/hide (manual or programmatic)
                function syncFgToggleWithCanvas() {
                    // If any visible, treat as "on"
                    areFgStickersHidden = stickers.every(st => st.hidden);
                    updateFgToggleBtnVisual();
                }
                /******************************************************
                 * getWorldCoords => transform screen coords to world
                 ******************************************************/
                function getWorldCoords(screenX, screenY) {
                    /* screen → canvas space (but canvas is CSS‑scaled by wrapperScale) */
                    const rect = canvas.getBoundingClientRect();
                    let canvasX = (screenX - rect.left) / wrapperScale;
                    let canvasY = (screenY - rect.top) / wrapperScale;

                    /* then undo camera pan / zoom */
                    const worldX = (canvasX - camOffsetX) / camScale;
                    const worldY = (canvasY - camOffsetY) / camScale;
                    return { x: worldX, y: worldY };
                }
                /* convert world coords to screen space */
                function getScreenCoords(worldX, worldY) {
                    const wrap = canvasWrapper.getBoundingClientRect();
                    const x = (worldX * camScale + camOffsetX) * wrapperScale;
                    const y = (worldY * camScale + camOffsetY) * wrapperScale;
                    return { x: wrap.left + x, y: wrap.top + y };
                }

                function getViewportMetrics() {
                    const center = getWorldCoords(canvas.width / 2, canvas.height / 2);
                    return {
                        centerX: center.x,
                        centerY: center.y,
                        canvasWidth: canvas.width,
                        canvasHeight: canvas.height
                    };
                }
                window.__lumGetViewportMetrics = getViewportMetrics;

                function showRotateHint(st) {
                    const w = st.img.width * st.scale;
                    const h = st.img.height * st.scale;
                    const center = getScreenCoords(st.x + w / 2, st.y + h / 2);
                    rotateHint.style.left = (center.x - 24) + 'px';
                    rotateHint.style.top = (center.y - 24) + 'px';
                    rotateHint.style.display = 'block';
                    clearTimeout(rotateHintTimer);
                    rotateHintTimer = setTimeout(() => rotateHint.style.display = 'none', 2500);
                }

                function hideRotateHint() {
                    rotateHint.style.display = 'none';
                    clearTimeout(rotateHintTimer);
                }

                // ─── 1) CAMERA / ZOOM SETUP ─────────────────────────────────────────────

                // state for enabling/disabling wheel-zoom
                let wheelEnabled = true;
                const canvasWrapper = document.getElementById('canvasWrapper');


                // any primary‐button down anywhere on the wrapper ⇒ disable zoom
                canvasWrapper.addEventListener('pointerdown', e => {
                    if (e.button === 0) wheelEnabled = false;
                });
                // lift pointer ⇒ always re-enable zoom (whether drag ended on wrapper or sticker)
                document.addEventListener('pointerup', () => {
                    wheelEnabled = true;
                });

                // extra safety: if user mouses down on the canvas to start dragging a sticker…
                canvas.addEventListener('mousedown', e => {
                    if (e.button === 0 && activeStickerIndex !== -1) {
                        wheelEnabled = false;
                    }
                });
                // …and of course re-enable on mouseup
                document.addEventListener('mouseup', () => {
                    wheelEnabled = true;
                });

                // ─── 2) THE SINGLE WHEEL HANDLER ─────────────────────────────────────────

                function onCanvasWheel(e) {
                    // skip zoom if:
                    //   • zoom is globally disabled (wheelEnabled===false)
                    //   • any button is still down
                    //   • user is dragging a sticker / resizing a corner / panning
                    if (
                        !wheelEnabled ||
                        e.buttons !== 0 ||
                        isDraggingSticker ||
                        isResizingCorner ||
                        isPanning
                    ) {
                        return;
                    }

                    e.preventDefault();

                    // compute zoom about cursor
                    const dir = e.deltaY < 0 ? 1 : -1;
                    const factor = dir > 0 ? ZOOM_FACTOR_STEP : 1 / ZOOM_FACTOR_STEP;

                    const before = getWorldCoords(e.clientX, e.clientY);
                    camScale = Math.min(5, Math.max(0.1, camScale * factor));
                    const after = getWorldCoords(e.clientX, e.clientY);

                    camOffsetX += (after.x - before.x) * camScale;
                    camOffsetY += (after.y - before.y) * camScale;

                    scheduleRedraw();  // debounced draw + HUD snap
                }

                // bind exactly once
                canvasWrapper.removeEventListener('wheel', onCanvasWheel);
                canvasWrapper.addEventListener('wheel', onCanvasWheel, { passive: false });

                // ─── 3) DEBOUNCED DRAW + HUD SNAP ────────────────────────────────────────

                let rafID = 0;
                function scheduleRedraw() {
                    if (rafID) return;               // already queued
                    rafID = requestAnimationFrame(() => {
                        rafID = 0;
                        drawCanvas();
                        scheduleHudSnap();              // your unified HUD‐snap function
                    });
                }

                function placeAtViewportCentre(st) {
                    const { x: wcx, y: wcy } = getWorldCoords(
                        canvas.width / 2,
                        canvas.height / 2
                    );                            //  <- converts to world-space
                    st.x = wcx - (st.img.width * st.scale) / 2;
                    st.y = wcy - (st.img.height * st.scale) / 2;
                }

                function clampStickerToCanvas(st, options = {}) {
                    if (!st || !st.img) return false;

                    const { center = false } = options;
                    const centerX = options.centerX !== undefined ? options.centerX : center;
                    const centerY = options.centerY !== undefined ? options.centerY : center;

                    const imgW = st.img?.naturalWidth || st.img?.width || 0;
                    const imgH = st.img?.naturalHeight || st.img?.height || 0;
                    if (!imgW || !imgH) return false;

                    const baseW = canvas?.width || backgroundImage?.width || imgW;
                    const baseH = canvas?.height || backgroundImage?.height || imgH;

                    const currentScale = st.scale ?? 1;
                    const widthFactor = baseW / (imgW * currentScale);
                    const heightFactor = baseH / (imgH * currentScale);
                    const clampFactor = Math.min(widthFactor, heightFactor, 1);
                    let changed = false;

                    if (Number.isFinite(clampFactor) && clampFactor > 0 && clampFactor < 1) {
                        st.scale = currentScale * clampFactor;
                        changed = true;
                    } else if (!Number.isFinite(st.scale) || st.scale <= 0) {
                        st.scale = 1;
                        changed = true;
                    }

                    const finalW = imgW * st.scale;
                    const finalH = imgH * st.scale;

                    let newX = st.x ?? 0;
                    let newY = st.y ?? 0;

                    if (centerX) {
                        newX = (baseW - finalW) / 2;
                    } else {
                        const maxX = baseW - finalW;
                        newX = Math.min(Math.max(newX, 0), maxX);
                    }

                    if (centerY) {
                        newY = (baseH - finalH) / 2;
                    } else {
                        const maxY = baseH - finalH;
                        newY = Math.min(Math.max(newY, 0), maxY);
                    }

                    if (!Number.isFinite(newX)) newX = 0;
                    if (!Number.isFinite(newY)) newY = 0;

                    if (Math.abs((st.x ?? 0) - newX) > 0.1 || Math.abs((st.y ?? 0) - newY) > 0.1) {
                        st.x = newX;
                        st.y = newY;
                        changed = true;
                    }

                    return changed;
                }

                /**************************************************
                *  Mode-switching helpers
                **************************************************/
                function updateStickerDOM(st) {
                    if (!st.domElement) return;

                    const screen = getScreenCoords(st.x, st.y);
                    const scale = st.scale * camScale * wrapperScale;
                    const sX = st.flipX ? -scale : scale;

                    st.domElement.style.transform =
                        `translate(${screen.x}px,${screen.y}px) scale(${sX},${scale})`;
                    st.domElement.style.transformOrigin = "top left";

                    const btnPos = getScreenCoords(st.x + (st.img.width * st.scale) / 2, st.y);
                    st.domFocus.style.left = `${btnPos.x - 12 * wrapperScale * camScale}px`;
                    st.domFocus.style.top = `${btnPos.y - 28 * wrapperScale * camScale}px`;

                    if (st.domScaleGui) {
                        const center = getScreenCoords(
                            st.x + (st.img.width * st.scale) / 2,
                            st.y + (st.img.height * st.scale) / 2
                        );
                        st.domScaleGui.style.left = `${center.x - 32 * wrapperScale * camScale / 2}px`;
                        st.domScaleGui.style.top = `${center.y - 16 * wrapperScale * camScale}px`;
                    }

                    // Add toggle button if both images exist
                    if (st.originalImage && st.relightedImage && !st.domElement.querySelector(".toggleBtn")) {
                        const toggleBtn = document.createElement("div");
                        toggleBtn.className = "toggleBtn";
                        toggleBtn.innerHTML = '<i class="fas fa-eye"></i>';
                        toggleBtn.title = "Toggle Before/After";

                        toggleBtn.onclick = (e) => {
                            e.stopPropagation();
                            const isRelight = st.img === st.relightedImage;
                            st.img = isRelight ? st.originalImage : st.relightedImage;
                            drawCanvas();
                        };

                        st.domElement.appendChild(toggleBtn);
                    }
                }
                function scaleStickerToFit(st) {
                    const worldW = canvas.width / camScale;
                    const worldH = canvas.height / camScale;
                    const currW = st.img.width * st.scale;
                    const currH = st.img.height * st.scale;
                    if (currW <= worldW && currH <= worldH) return;

                    const ratio = Math.min(worldW / currW, worldH / currH);
                    st.scale *= ratio;
                    const cx = st.x + currW / 2;
                    const cy = st.y + currH / 2;
                    st.x = cx - (st.img.width * st.scale) / 2;
                    st.y = cy - (st.img.height * st.scale) / 2;
                    drawCanvas();
                    pushHistory();
                }
                function createStickerDOM(st) {
                    // Prevent duplicate DOM elements
                    if (st.domElement && document.body.contains(st.domElement)) {
                        console.warn("[UNDO] Skipping duplicate sticker DOM");
                        return;
                    }

                    // Create the sticker image
                    const el = document.createElement("img");
                    el.src = st.img.src;
                    el.className = "stickerDom";
                    document.body.appendChild(el);
                    st.domElement = el;

                    // Create the focus button
                    const foc = document.createElement("div");
                    foc.className = "stFocusBtn active";
                    document.body.appendChild(foc);
                    st.domFocus = foc;

                    // Create scale/move GUI
                    const gui = document.createElement("div");
                    gui.className = "stScaleGui";
                    gui.innerHTML = `
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <div class="moveBtn"><i class="fas fa-up-down-left-right"></i></div>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            <div class="fitBtn"><i class="fas fa-compress"></i></div>`;
                    document.body.appendChild(gui);
                    st.domScaleGui = gui;

                    // Drag using move button
                    const moveBtn = gui.querySelector('.moveBtn');
                    moveBtn.addEventListener('mousedown', e => {
                        e.preventDefault();
                        e.stopPropagation();
                        activeStickerIndex = stickers.indexOf(st);
                        const { x, y } = getWorldCoords(e.clientX, e.clientY);
                        dragOffsetX = x - st.x;
                        dragOffsetY = y - st.y;
                        isDraggingSticker = true;
                    });

                    // Scale-to-fit button
                    const fitBtn = gui.querySelector('.fitBtn');
                    fitBtn.addEventListener('click', e => {
                        e.stopPropagation();
                        scaleStickerToFit(st);
                    });

                    // Focus button click toggle
                    foc.addEventListener("click", e => {
                        e.stopPropagation();
                        st.hidden = !st.hidden;
                        st.domElement.style.visibility = st.hidden ? "hidden" : "visible";
                        foc.classList.toggle("active", !st.hidden);
                        drawCanvas();
                        pushHistory();
                        viewModeClicks = 0;
                    });

                    const exportOnContext = e => {
                        e.preventDefault();
                        e.stopPropagation();
                        exportStickerImage(st);
                    };
                    el.addEventListener('contextmenu', exportOnContext);
                    foc.addEventListener('contextmenu', exportOnContext);
                    gui.addEventListener('contextmenu', exportOnContext);


                    // ✅ Safe hover logic (now that el exists in DOM)
                    el.addEventListener("mouseenter", () => {
                        if (!st.hidden && activeStickerIndex === -1) {
                            st.domFocus.style.display = "flex";
                            st.domFocus.style.opacity = 1;
                            st.domScaleGui.style.display = "flex";
                        }
                    });

                    el.addEventListener("mouseleave", () => {
                        if (!st.hidden && activeStickerIndex === -1) {
                            st.domFocus.style.display = "none";
                            st.domScaleGui.style.display = "none";
                        }
                    });

                    gui.addEventListener('mouseenter', () => {
                        if (!st.hidden && activeStickerIndex === -1) {
                            st.domScaleGui.style.display = 'flex';
                        }
                    });

                    gui.addEventListener('mouseleave', () => {
                        if (!st.hidden && activeStickerIndex === -1) {
                            st.domScaleGui.style.display = 'none';
                        }
                    });

                    updateStickerDOM(st);
                }

                /* --------------------------------------------------------------------
                 *  restore3DOverlay  – re-enable HUD + GLB after backend finishes
                 * -------------------------------------------------------------------- */
                function restore3DOverlay() {
                    if (!window.glbStickers || window.glbStickers.length === 0) return;
                    window.glbStickers.forEach(st => {
                        st.canvas.style.display = 'block';
                        st.outline.style.opacity = 1;
                        st.focusBtn.style.display = 'flex';
                        st.focusBtn.classList.add('active');
                        if (typeof st.syncHud === 'function') st.syncHud();
                        if (!st.renderLoopId && typeof st._startRenderLoop === 'function') st._startRenderLoop();
                    });
                    window.isGlbVisible = true;
                    window._prevGlbVisible = false;
                    if (typeof __glbSyncHud === 'function') __glbSyncHud();
                }

                function hide3DOverlay() {
                    if (!window.glbStickers || window.glbStickers.length === 0) return;
                    if (window.isGlbVisible) window._prevGlbVisible = true;
                    window.glbStickers.forEach(st => {
                        st.canvas.style.display = 'none';
                        st.outline.style.opacity = 0;
                        st.focusBtn.classList.remove('active');
                    });
                    window.isGlbVisible = false;
                }

                function ensureGlbSnapshot() {
                    if (!window.glbStickers || window.glbStickers.length === 0) return;
                    const hidden = [];
                    window.glbStickers.forEach(st => {
                        if (st.canvas.style.display === 'none') {
                            st.canvas.style.display = 'block';
                            hidden.push(st);
                        }
                    });
                    window.updateGlbPreviewImage(true);
                    hidden.forEach(st => { st.canvas.style.display = 'none'; });
                }

                /* ===== UNDO / REDO ===== */
                const MAX_HISTORY = 30;
                let undoStack = [];
                let redoStack = [];
                let currentUploadSticker = null;

                /* take a lightweight serialisable picture of the current stickers[] */
                function pushHistory() {
                    // Only push history if we have at least one sticker
                    if (stickers.length > 0) {
                        const currentState = stickers.map(st => ({
                            x: st.x,
                            y: st.y,
                            scale: st.scale,
                            rotation: st.rotation || 0,
                            flipX: st.flipX,
                            hidden: st.hidden,
                            paths: st.flipBookImages.map(im => im.src),  // Store the image paths directly
                            idx: st.flipBookIndex
                        }));

                        undoStack.push(currentState);
                        redoStack.length = 0;  // Clear redo stack on new action
                    }
                }

                /* rebuild stickers[] from a saved state */
                function restoreHistory(state) {
                    // Remove old DOM elements
                    stickers.forEach(st => {
                        st.domElement?.remove();
                        st.domFocus?.remove();
                    });

                    stickers.length = 0;

                    state.forEach(item => {
                        const imgs = item.paths.map(src => {
                            const im = new Image();
                            im.src = src;
                            return im;
                        });

                        const st = {
                            img: imgs[item.idx],
                            flipBookImages: imgs,
                            flipBookIndex: item.idx,
                            x: item.x,
                            y: item.y,
                            scale: item.scale,
                            flipX: item.flipX,
                            rotation: item.rotation || 0,
                            mode: "edit",  // Default mode
                            hidden: item.hidden
                        };

                        stickers.push(st);

                        createStickerDOM(st);
                        createModeButton(st);
                        st.domElement.style.visibility = st.hidden ? "hidden" : "visible";
                        st.domFocus.classList.toggle("active", !st.hidden);
                        layoutModeButton(st, stickers.length - 1);
                        drawCanvas();
                        updateLiveSnapshotIfCurrent();
                        updateHistoryThumbs();
                        if (window.glbStickers && window.glbStickers.some(gs => gs.canvas.style.display === "block")) {
                            window.glbStickers.forEach(gs => gs.outline.style.opacity = 1);
                        }
                    });
                }

                /* keyboard hooks (keep your existing ones if you like) */
                window.addEventListener("keydown", e => {
                    if (e.ctrlKey && e.key === "z" && !e.shiftKey && undoStack.length > 1) {
                        e.preventDefault();
                        const curr = undoStack.pop();  // Pop current state
                        redoStack.push(curr);          // Push to redo stack
                        const prev = undoStack[undoStack.length - 1]; // Get previous valid state
                        restoreHistory(prev);  // Restore state from previous snapshot
                    }

                    if (e.ctrlKey && e.key === "y" && redoStack.length > 0) {
                        e.preventDefault();
                        const next = redoStack.pop();  // Pop from redo stack
                        undoStack.push(next);          // Push back to undo stack
                        restoreHistory(next);          // Restore next state
                    }
                });

                document.addEventListener('keydown', e => {
                    if (e.key === 'Control') {
                        ctrlDown = true;
                        if (hoveredStickerIndex !== -1 && !isRotatingSticker) {
                            showRotateHint(stickers[hoveredStickerIndex]);
                        }
                        drawCanvas();
                    } else if (e.key === 'Delete' || e.key === 'Backspace') {
                        const tag = e.target.tagName?.toLowerCase();
                        if (tag === 'input' || tag === 'textarea' || e.target.isContentEditable) return;
                        if (activeStickerIndex !== -1) {
                            e.preventDefault();
                            deleteActiveSticker();
                        }
                    }
                });

                document.addEventListener('keyup', e => {
                    if (e.key === 'Control') {
                        ctrlDown = false;
                        hideRotateHint();
                        drawCanvas();
                    }
                    if (e.key === 'Shift') {
                        dragLockAxis = null;
                        panLockAxis = null;
                    }
                });

                const MODES = ["edit", "relight"];
                const MODE_ICONS = {
                    //scale: "fa-expand-arrows-alt",
                    //move: "fa-arrows-alt",
                    edit: "fa-up-down-left-right",
                    relight: "fa-lightbulb",
                    upload: "fa-image"                 // replace bitmap
                };
                const MODE_TIPS = {
                    edit: "Edit (Drag + Scale)",
                    relight: "Relight FG Image",
                    upload: "Replace Image"
                };



                /* create the DOM element once per sticker */
                function createModeButton(st) {

                    ///* — focus / visibility toggle — */
                    const foc = document.createElement("div");
                    foc.className = "stFocusBtn";
                    foc.dataset.tip = "Toggle Visibility / Right Click Download";
                    foc.classList.add("active");
                    foc.addEventListener("click", e => {
                        e.stopPropagation();
                        st.hidden = !st.hidden;
                        st.domElement.style.visibility = st.hidden ? "hidden" : "visible";
                        foc.classList.toggle("active", !st.hidden);
                        drawCanvas();
                        pushHistory();
                        syncFgToggleWithCanvas();
                    });
                    foc.addEventListener('contextmenu', e => {
                        e.preventDefault();
                        e.stopPropagation();
                        exportStickerImage(st);
                    });
                    document.body.appendChild(foc);
                    st.domFocus = foc;
                }

                /* keep the button glued to its sticker each frame */
                function layoutModeButton(st, idx) {
                    if (!st || !st.domFocus) return;
                    if (ctrlDown || isRotatingSticker || idx === actionMenuOpenIndex) {
                        st.domFocus.style.display = "none";
                        return;
                    }
                    st.domFocus.style.display = (idx === activeStickerIndex) ? "flex" : "none";
                    st.domFocus.style.opacity = (idx === activeStickerIndex) ? 1 : 0;
                    const center = getScreenCoords(st.x + (st.img.width * st.scale) / 2, st.y);
                    st.domFocus.style.left = (center.x - 16 * wrapperScale * camScale) + "px";
                    st.domFocus.style.top = (center.y - 5 * wrapperScale * camScale) + "px"; // adjust -24 for higher placement
                }

                function deleteActiveSticker() {
                    if (activeStickerIndex === -1) return;
                    const st = stickers[activeStickerIndex];

                    /* remove any DOM overlays we created for this sticker */
                    st.domElement?.remove();       // if you kept the img overlay
                    st.domFocus?.remove();

                    stickers.splice(activeStickerIndex, 1);
                    activeStickerIndex = -1;
                    hoveredStickerIndex = -1;
                    pushHistory();
                    drawCanvas();
                    updateLiveSnapshotIfCurrent();
                    updateHistoryThumbs();
                    setActionText("Foreground sticker deleted");
                }

                function arrowBoxHit(st, px, py) {
                    if (!st.flipBookImages || st.flipBookImages.length < 2) return null;

                    const w = st.img.width * st.scale;
                    const midX = st.x + w / 2;
                    const arrowGap = 46;
                    const arrowSize = 35;
                    const y = st.y + 22;

                    // Left arrow
                    if ((px - (midX - arrowGap)) ** 2 + (py - y) ** 2 < (arrowSize / 2) ** 2) return "prev";
                    // Right arrow
                    if ((px - (midX + arrowGap)) ** 2 + (py - y) ** 2 < (arrowSize / 2) ** 2) return "next";
                    return null;
                }

                function deleteButtonHit(st, px, py) {
                    if (!st.flipBookImages || st.flipBookImages.length < 2 || st.flipBookIndex === 0) return false;
                    const w = st.img.width * st.scale;
                    const midX = st.x + w / 2;
                    const size = 32;
                    const y = st.y + 22;
                    return ((px - midX) ** 2 + (py - y) ** 2 < (size / 2) ** 2);
                }

                function flipButtonHit(st, px, py) {
                    const w = st.img.width * st.scale;
                    const h = st.img.height * st.scale;
                    const flipSize = 36;
                    const cx = st.x - 20;
                    const cy = st.y + h / 2;
                    // Return true if inside the flip button circle
                    return ((px - cx) ** 2 + (py - cy) ** 2 < (flipSize / 2) ** 2);
                }

                function stepFlipbook(st, dir) {
                    const len = st.flipBookImages.length;
                    if (len < 2) return;

                    st.flipBookIndex = (st.flipBookIndex + dir + len) % len;
                    st.img = st.flipBookImages[st.flipBookIndex];
                }

                function deleteCurrentFlipbookImage(st) {
                    if (!st.flipBookImages || st.flipBookImages.length <= 1 || st.flipBookIndex === 0) return;
                    st.flipBookImages.splice(st.flipBookIndex, 1);
                    if (st.flipBookIndex >= st.flipBookImages.length) {
                        st.flipBookIndex = st.flipBookImages.length - 1;
                    }
                    st.img = st.flipBookImages[st.flipBookIndex];
                    if (st.domElement) st.domElement.src = st.img.src;
                }

                function hitTestSticker(px, py) {
                    for (let i = stickers.length - 1; i >= 0; i--) {
                        const st = stickers[i];
                        const w = st.img.width * st.scale;
                        const h = st.img.height * st.scale;
                        if (px >= st.x && px <= st.x + w && py >= st.y && py <= st.y + h)
                            return i;            // first (top-most) hit
                    }
                    return -1;
                }

                function hitCornerHandle(st, x, y) {
                    // Dynamic: forgiving but not excessive
                    const PIN_HIT_R = Math.max(40, Math.min(90, Math.min(st.img.width, st.img.height) * st.scale * 0.21));
                    const PIN_HIT_R2 = PIN_HIT_R * PIN_HIT_R;
                    const pts = [
                        [st.x, st.y],
                        [st.x + st.img.width * st.scale, st.y],
                        [st.x, st.y + st.img.height * st.scale],
                        [st.x + st.img.width * st.scale, st.y + st.img.height * st.scale]
                    ];
                    return pts.findIndex(([cx, cy]) =>
                        (x - cx) ** 2 + (y - cy) ** 2 <= PIN_HIT_R2
                    );
                }


                /* Kick off live-scaling; returns true if a handle was actually hit */
                function beginScaling(st, startX, startY) {
                    const handle = hitCornerHandle(st, startX, startY);
                    if (handle === -1) return false;      // user missed the handles

                    isResizingCorner = true;
                    resizeCornerIndex = handle;

                    const w = st.img.width * st.scale;
                    const h = st.img.height * st.scale;
                    stickerCenterX = st.x + w / 2;
                    stickerCenterY = st.y + h / 2;
                    scaleStartDist = Math.hypot(startX - stickerCenterX, startY - stickerCenterY);
                    originalScale = st.scale;

                    const onMove = e => {
                        const { x, y } = getWorldCoords(e.clientX, e.clientY);
                        const ratio = Math.hypot(x - stickerCenterX, y - stickerCenterY) / scaleStartDist;
                        st.scale = Math.max(0.05, originalScale * ratio);
                        st.x = stickerCenterX - (st.img.width * st.scale) / 2;
                        st.y = stickerCenterY - (st.img.height * st.scale) / 2;
                        drawCanvas();
                    };
                    const onUp = () => {
                        document.removeEventListener('mousemove', onMove);
                        document.removeEventListener('mouseup', onUp);
                        isResizingCorner = false;
                    };
                    document.addEventListener('mousemove', onMove);
                    document.addEventListener('mouseup', onUp);
                    return true;
                }

                function beginRotation(st, startX, startY) {
                    const handle = hitCornerHandle(st, startX, startY);
                    if (handle === -1) return false;
                    isRotatingSticker = true;
                    canvas.style.cursor = 'grabbing';
                    const w = st.img.width * st.scale;
                    const h = st.img.height * st.scale;
                    rotationCenterX = st.x + w / 2;
                    rotationCenterY = st.y + h / 2;
                    rotationStartAngle = Math.atan2(startY - rotationCenterY, startX - rotationCenterX) - (st.rotation || 0);
                    hideRotateHint();
                    const onMove = e => {
                        const { x, y } = getWorldCoords(e.clientX, e.clientY);
                        let angle = Math.atan2(y - rotationCenterY, x - rotationCenterX) - rotationStartAngle;
                        if (e.shiftKey) {
                            const step = Math.PI / 12;
                            angle = Math.round(angle / step) * step;
                        }
                        st.rotation = angle;
                        drawCanvas();
                    };
                    const onUp = () => {
                        document.removeEventListener('mousemove', onMove);
                        document.removeEventListener('mouseup', onUp);
                        isRotatingSticker = false;
                        canvas.style.cursor = ctrlDown ? 'grab' : 'default';
                        hideRotateHint();
                        pushHistory();
                    };
                    document.addEventListener('mousemove', onMove);
                    document.addEventListener('mouseup', onUp);
                    return true;
                }

                /* ===== CURSOR HELPER ===== */
                function updateCursor(px, py) {
                    const i = hitTestSticker(px, py);
                    if (i === -1) { canvas.style.cursor = "default"; return; }

                    const st = stickers[i];
                    if (st.mode === "edit") {
                        const c = hitCornerHandle(st, px, py);
                        if (c !== -1) {
                            canvas.style.cursor = (c === 0 || c === 3)
                                ? "nwse-resize"
                                : "nesw-resize";
                            return;
                        }
                        canvas.style.cursor = isDraggingSticker ? "grabbing" : "grab";
                    } else {
                        canvas.style.cursor = isDraggingSticker ? "grabbing" : "grab";
                    }
                }

                function duplicateSticker(src) {
                    return {
                        img: src.img,                         // keep same <img>
                        x: src.x + 12,                      // offset so it’s visible
                        y: src.y + 12,
                        scale: src.scale,
                        flipX: src.flipX,
                        rotation: src.rotation || 0,
                        flipBookImages: src.flipBookImages ? [...src.flipBookImages] : undefined,
                        flipBookIndex: src.flipBookIndex ?? 0,
                        mode: "edit",
                        domButton: null
                    };
                }

                function ensureHudForSticker(st) {
                    if (!st) return;
                    if (!st.domElement) createStickerDOM(st);
                    if (!st.domFocus) createModeButton(st);

                    /* sync ring state to current visibility */
                    const nowHidden = st.domElement.style.visibility === "hidden";
                    st.domFocus.classList.toggle("active", !nowHidden);

                    /* make sure it’s shown if this sticker is active */
                    const idx = stickers.indexOf(st);
                    const isActive = idx === activeStickerIndex;
                    // ⚠ Do not force show. Respect whatever the current display state is.
                    if (!st.hidden && isActive && viewModeClicks === 0) {
                        st.domFocus.style.display = "flex";
                        st.domFocus.style.opacity = 1;
                    }

                    /* place it */
                    layoutModeButton(st, idx);
                }

                function hideAllStickerHud() {
                    const cache = [];
                    stickers.forEach(st => {
                        ["domFocus", "domScaleGui", "domButton"].forEach(k => {
                            const el = st[k];
                            if (el) {
                                cache.push({ el, display: el.style.display });
                                el.style.display = "none";
                            }
                        });
                    });
                    return () => cache.forEach(({ el, display }) => { el.style.display = display; });
                }

                function updateLiveSnapshotIfCurrent() {
                    if (!isHistoryPreviewActive) {
                        // Always track latest FG placements
                        liveFGStickers = stickers.map(cloneSticker);
                        // Only replace the stored BG when viewing the live canvas
                        if (currentOutIndex === -1) {
                            liveBGImage = backgroundImage;
                        }
                    }
                }

                function startHistoryPreview(img, hideFg = true, orig = null, blendVal = 1) {
                    if (!hoverPreviewState || isBeforeAfterPreview) {
                        hoverPreviewState = {
                            bg: backgroundImage,
                            overlay: isOverlayVisible,
                            blendOrig: todBlendOriginal,
                            blendRatio: todBlendRatio,
                            glbVisible: window.isGlbVisible,
                            beforeAfter: isBeforeAfterPreview
                        };
                    }
                    isBeforeAfterPreview = false;
                    backgroundImage = img;
                    todBlendOriginal = orig;
                    todBlendRatio = blendVal;
                    isOverlayVisible = false;
                    isHistoryPreviewActive = hideFg;
                    isLiveHistoryPreview = !hideFg && img === liveBGImage;
                    computeBgLayout(backgroundImage);
                    updateFgStickerVisibility();
                    drawCanvas();
                    if (hideFg && window.isGlbReady) hide3DOverlay();
                    updateBeforeAfterButton();
                }

                function endHistoryPreview() {
                    isHistoryPreviewActive = false;
                    isLiveHistoryPreview = false;
                    if (!hoverPreviewState) return;
                    backgroundImage = hoverPreviewState.bg;
                    isOverlayVisible = hoverPreviewState.overlay;
                    todBlendOriginal = hoverPreviewState.blendOrig;
                    todBlendRatio = hoverPreviewState.blendRatio;
                    isBeforeAfterPreview = !!hoverPreviewState.beforeAfter;
                    const wasVisible = hoverPreviewState.glbVisible;
                    hoverPreviewState = null;
                    computeBgLayout(backgroundImage);
                    updateFgStickerVisibility();
                    drawCanvas();
                    updateBeforeAfterButton();
                    if (wasVisible && window.isGlbReady) restore3DOverlay();
                }

                function resetBeforeAfterState() {
                    isHistoryPreviewActive = false;
                    isLiveHistoryPreview = false;
                    isBeforeAfterPreview = false;
                    beforeAfterState = null;
                    hoverPreviewState = null;
                    updateFgStickerVisibility();
                }

                function getBeforeImage() {
                    if (beforeLockIndex !== -1) {
                        return sessionOutputs[beforeLockIndex]?.img || liveBGImage;
                    }
                    return liveBGImage;
                }

                function getCurrentCanvasThumb() {
                    const thumbCanvas = document.createElement('canvas');
                    thumbCanvas.width = canvas.width;
                    thumbCanvas.height = canvas.height;
                    const thumbCtx = thumbCanvas.getContext('2d');
                    // Draw the snapshotted live BG
                    if (liveBGImage && liveBGImage.naturalWidth) {
                        thumbCtx.drawImage(liveBGImage, 0, 0, canvas.width, canvas.height);
                    }
                    // Draw stickers as per liveFGStickers snapshot
                    liveFGStickers.forEach(st => {
                        if (st.img && !st.hidden) {
                            thumbCtx.save();
                            const w = st.img.width * st.scale;
                            const h = st.img.height * st.scale;
                            thumbCtx.translate(st.x + w / 2, st.y + h / 2);
                            if (st.flipX) thumbCtx.scale(-1, 1);
                            thumbCtx.rotate(st.rotation || 0);
                            thumbCtx.scale(st.scale, st.scale);
                            thumbCtx.drawImage(st.img, -st.img.width / 2, -st.img.height / 2);
                            thumbCtx.restore();
                        }
                    });
                    if (window.updateGlbPreviewImage) window.updateGlbPreviewImage();
                    if (window.glbPreviewImage && window.glbPreviewImage.complete) {
                        thumbCtx.drawImage(window.glbPreviewImage, 0, 0, canvas.width, canvas.height);
                    }
                    const thumbImg = new Image();
                    thumbImg.src = thumbCanvas.toDataURL('image/png');
                    return thumbImg;
                }

                // History When a new image is processed...
                function addSessionOutput(imageObj) {
                    sessionOutputs.push(imageObj);
                    currentOutIndex = sessionOutputs.length - 1;
                    beforeAfterFresh = true;
                    isBeforeAfterPreview = false;
                    beforeAfterState = null;
                    // Only snapshot original state ONCE, before the first output
                    if (sessionOutputs.length === 1) {
                        showHistoryPanel();
                    }
                    updateHistoryThumbs();
                }

                async function loadVideoHistory() {
                    try {
                        const resp = await fetch(`${API_BASE}/wan-video-list`);
                        videoHistory = await resp.json();
                    } catch (e) {
                        console.error('Failed to load video list', e);
                        videoHistory = [];
                    }
                }

                function truncatePromptLine(info, maxLen = 100) {
                    const [firstLine, ...rest] = info.split('\n');
                    const prefix = 'Prompt: ';
                    let promptLine = firstLine || '';
                    if (promptLine.toLowerCase().startsWith(prefix.toLowerCase())) {
                        const promptText = promptLine.slice(prefix.length);
                        if (promptText.length > maxLen) {
                            promptLine = prefix + promptText.slice(0, maxLen) + '...';
                        }
                    } else if (promptLine.length > maxLen) {
                        promptLine = promptLine.slice(0, maxLen) + '...';
                    }
                    return [promptLine, ...rest].join('\n');
                }

                const historyThumbsEl = document.getElementById('historyThumbs');
                const historyScrollControls = document.getElementById('historyScrollControls');
                const historyScrollUp = document.getElementById('historyScrollUp');
                const historyScrollDown = document.getElementById('historyScrollDown');
                let historyScrollAnimation = null;
                let historyScrollDirection = 0;
                let historyScrollLastTs = 0;
                let historyScrollStartTime = 0;
                let historyScrollPointerId = null;
                let activeHistoryArrowDirection = 0;
                const HISTORY_SCROLL_SPEED_PX_PER_MS = 0.45;
                const HISTORY_SCROLL_HOLD_THRESHOLD = 180;
                const HISTORY_SCROLL_STEP = 220;

                function historyWheelDeltaToPixels(delta, deltaMode) {
                    if (deltaMode === 1) {
                        return delta * 16;
                    }
                    if (deltaMode === 2 && historyThumbsEl) {
                        return delta * historyThumbsEl.clientHeight;
                    }
                    return delta;
                }

                function refreshHistoryScrollControls() {
                    if (!historyScrollControls || !historyThumbsEl) return;
                    const scrollable = historyThumbsEl.scrollHeight - historyThumbsEl.clientHeight > 1;
                    historyScrollControls.classList.toggle('visible', scrollable);
                    historyScrollControls.setAttribute('aria-hidden', scrollable ? 'false' : 'true');
                    if (!scrollable) return;
                    const atTop = historyThumbsEl.scrollTop <= 1;
                    const atBottom = (historyThumbsEl.scrollTop + historyThumbsEl.clientHeight) >= (historyThumbsEl.scrollHeight - 1);
                    if (historyScrollUp) historyScrollUp.classList.toggle('disabled', atTop);
                    if (historyScrollDown) historyScrollDown.classList.toggle('disabled', atBottom);
                }

                function stopHistoryArrowHold() {
                    if (historyScrollAnimation) {
                        cancelAnimationFrame(historyScrollAnimation);
                        historyScrollAnimation = null;
                    }
                    historyScrollDirection = 0;
                    historyScrollLastTs = 0;
                }

                function startHistoryArrowHold(direction) {
                    if (!historyThumbsEl) return;
                    stopHistoryArrowHold();
                    historyScrollDirection = direction;
                    const step = (ts) => {
                        if (!historyThumbsEl || historyScrollDirection === 0) return;
                        if (historyScrollLastTs === 0) historyScrollLastTs = ts;
                        const delta = ts - historyScrollLastTs;
                        historyScrollLastTs = ts;
                        historyThumbsEl.scrollTop += direction * delta * HISTORY_SCROLL_SPEED_PX_PER_MS;
                        refreshHistoryScrollControls();
                        historyScrollAnimation = requestAnimationFrame(step);
                    };
                    historyScrollAnimation = requestAnimationFrame(step);
                }

                function handleHistoryArrowPointerUp(event) {
                    if (!historyThumbsEl) return;
                    if (event.pointerId !== historyScrollPointerId) return;
                    const direction = activeHistoryArrowDirection;
                    stopHistoryArrowHold();
                    const elapsed = performance.now() - historyScrollStartTime;
                    if (elapsed < HISTORY_SCROLL_HOLD_THRESHOLD && direction !== 0) {
                        historyThumbsEl.scrollBy({ top: direction * HISTORY_SCROLL_STEP, behavior: 'smooth' });
                    }
                    activeHistoryArrowDirection = 0;
                    historyScrollPointerId = null;
                    refreshHistoryScrollControls();
                    window.removeEventListener('pointerup', handleHistoryArrowPointerUp);
                    window.removeEventListener('pointercancel', handleHistoryArrowPointerUp);
                }

                function handleHistoryArrowPointerDown(direction, event) {
                    if (!historyThumbsEl) return;
                    event.preventDefault();
                    activeHistoryArrowDirection = direction;
                    historyScrollPointerId = event.pointerId;
                    historyScrollStartTime = performance.now();
                    startHistoryArrowHold(direction);
                    window.addEventListener('pointerup', handleHistoryArrowPointerUp);
                    window.addEventListener('pointercancel', handleHistoryArrowPointerUp);
                }

                if (historyScrollUp) {
                    historyScrollUp.addEventListener('pointerdown', e => handleHistoryArrowPointerDown(-1, e));
                    historyScrollUp.addEventListener('click', e => {
                        if (!historyThumbsEl || e.detail !== 0) return;
                        historyThumbsEl.scrollBy({ top: -HISTORY_SCROLL_STEP, behavior: 'smooth' });
                        refreshHistoryScrollControls();
                    });
                }
                if (historyScrollDown) {
                    historyScrollDown.addEventListener('pointerdown', e => handleHistoryArrowPointerDown(1, e));
                    historyScrollDown.addEventListener('click', e => {
                        if (!historyThumbsEl || e.detail !== 0) return;
                        historyThumbsEl.scrollBy({ top: HISTORY_SCROLL_STEP, behavior: 'smooth' });
                        refreshHistoryScrollControls();
                    });
                }

                if (historyScrollControls) {
                    historyScrollControls.addEventListener('wheel', event => {
                        if (!historyThumbsEl) return;
                        if (historyThumbsEl.scrollHeight - historyThumbsEl.clientHeight <= 1) return;
                        event.preventDefault();
                        const delta = historyWheelDeltaToPixels(event.deltaY, event.deltaMode);
                        historyThumbsEl.scrollBy({ top: delta, behavior: 'auto' });
                        refreshHistoryScrollControls();
                    }, { passive: false });
                }
                if (historyThumbsEl) {
                    historyThumbsEl.addEventListener('scroll', refreshHistoryScrollControls);
                }
                if (historyPanel) {
                    historyPanel.addEventListener('wheel', event => {
                        if (event.defaultPrevented) return;
                        if (!historyThumbsEl) return;
                        if (historyThumbsEl.scrollHeight - historyThumbsEl.clientHeight <= 1) return;
                        if (historyThumbsEl.contains(event.target)) return;
                        event.preventDefault();
                        const delta = historyWheelDeltaToPixels(event.deltaY, event.deltaMode);
                        historyThumbsEl.scrollBy({ top: delta, behavior: 'auto' });
                        refreshHistoryScrollControls();
                    }, { passive: false });
                }
                window.addEventListener('resize', refreshHistoryScrollControls);
                refreshHistoryScrollControls();

                function updateHistoryThumbs() {
                    if (historyMode === 'videos') {
                        endHistoryPreview();
                        const thumbs = document.getElementById('historyThumbs');
                        const prevScrollTop = thumbs.scrollTop;
                        thumbs.innerHTML = '';
                        videoHistory.forEach(item => {
                            const div = document.createElement('div');
                            div.className = 'historyThumb';
                            const vid = document.createElement('video');
                            vid.src = `${API_BASE}/wan-video/${encodeURIComponent(item.file)}?t=${Date.now()}`;
                            vid.muted = true;
                            vid.preload = 'metadata';
                            vid.addEventListener('loadeddata', () => { vid.pause(); });
                            div.appendChild(vid);
                            div.onclick = () => showWanPreview(vid.src);

                            const lab = document.createElement('div');
                            lab.className = 'historyModelLabel';
                            lab.textContent = 'WAN';
                            div.appendChild(lab);

                            if (item.prompt || item.style) {
                                const info = `Prompt: ${item.prompt || ''}\nStyle: ${item.style || ''}`;
                                const infoIcon = document.createElement('i');
                                infoIcon.className = 'fas fa-info-circle historyInfoIcon';
                                const truncated = truncatePromptLine(info);
                                const tooltip = document.createElement('div');
                                tooltip.className = 'historyInfoTooltip';
                                tooltip.textContent = truncated;
                                infoIcon.addEventListener('click', e => {
                                    e.stopPropagation();
                                    navigator.clipboard.writeText(info);
                                });
                                div.appendChild(infoIcon);
                                div.appendChild(tooltip);
                            }

                            const delIcon = document.createElement('i');
                            delIcon.className = 'fas fa-trash-alt historyDeleteIcon';
                            delIcon.addEventListener('click', e => {
                                e.stopPropagation();
                                fetch(`${API_BASE}/wan-video/${encodeURIComponent(item.file)}`, { method: 'DELETE' })
                                    .then(() => {
                                        videoHistory = videoHistory.filter(v => v.file !== item.file);
                                        updateHistoryThumbs();
                                    })
                                    .catch(err => console.error('Failed to delete video', err));
                            });
                            div.appendChild(delIcon);

                            thumbs.appendChild(div);
                        });
                        clearHistoryBtn.style.display = 'none';
                        requestAnimationFrame(() => {
                            const maxScroll = Math.max(0, thumbs.scrollHeight - thumbs.clientHeight);
                            thumbs.scrollTop = Math.min(prevScrollTop, maxScroll);
                            refreshHistoryScrollControls();
                        });
                        return;
                    }

                    const newOutputAdded = sessionOutputs.length > lastSessionOutputCount;
                    const latestImg = newOutputAdded ? sessionOutputs[currentOutIndex]?.img : null;

                    endHistoryPreview();
                    if (beforeLockIndex >= sessionOutputs.length) {
                        beforeLockIndex = -1;
                    }
                    if (newOutputAdded) {
                        beforeAfterFresh = true;
                        isBeforeAfterPreview = false;
                        beforeAfterState = null;
                        if (latestImg) {
                            backgroundImage = latestImg;
                            computeBgLayout(backgroundImage);
                            drawCanvas();
                        }
                    } else {
                        beforeAfterFresh = beforeAfterFresh && currentOutIndex === sessionOutputs.length - 1;
                    }
                    lastSessionOutputCount = sessionOutputs.length;

                    //function truncatePromptLine(info, maxLen = 100) {
                    //    const [firstLine, ...rest] = info.split('\n');
                    //    const prefix = 'Prompt: ';
                    //    let promptLine = firstLine || '';
                    //    if (promptLine.toLowerCase().startsWith(prefix.toLowerCase())) {
                    //        const promptText = promptLine.slice(prefix.length);
                    //        if (promptText.length > maxLen) {
                    //            promptLine = prefix + promptText.slice(0, maxLen) + '...';
                    //        }
                    //    } else if (promptLine.length > maxLen) {
                    //        promptLine = promptLine.slice(0, maxLen) + '...';
                    //    }
                    //    return [promptLine, ...rest].join('\n');
                    //}

                    const thumbs = document.getElementById('historyThumbs');
                    const prevScrollTop = thumbs.scrollTop;
                    thumbs.innerHTML = '';
                    clearHistoryBtn.style.display = '';

                    // --- Current Canvas thumb always first ---
                    const currDiv = document.createElement('div');
                    currDiv.className = 'historyThumb currentCanvasThumb' + (currentOutIndex === -1 ? ' selected' : '');
                    currDiv.title = 'Current Canvas (click to restore live)';
                    currDiv.appendChild(getCurrentCanvasThumb());
                    currDiv.onclick = () => {
                        if (currentOutIndex !== -1) {
                            isHistoryPreviewActive = false;
                            hoverPreviewState = null;
                            currentOutIndex = -1;
                            selectedHistoryIndex = -1;
                            if (liveBGImage && liveFGStickers.length) {
                                backgroundImage = liveBGImage;
                                // Remove all leftover DOM overlays
                                stickers.forEach(st => {
                                    st.domElement?.remove();
                                    st.domFocus?.remove();
                                });
                                stickers = liveFGStickers.map(cloneSticker);

                                // CLEAR DEPTH OVERLAY:
                                depthImage = null;
                                isOverlayVisible = false;
                                resetBeforeAfterState();

                                computeBgLayout(backgroundImage);
                                areFgStickersHidden = false;
                                todBlendOriginal = null;
                                todBlendRatio = 1;
                                updateFgStickerVisibility();
                                updateFgToggleBtnVisual();
                                updateHistoryThumbs();
                                if (window._prevGlbVisible && window.isGlbReady) restore3DOverlay();
                            }
                        }
                    };
                    currDiv.onmouseenter = () => {
                        if (liveBGImage) {
                            startHistoryPreview(liveBGImage, false, todBlendOriginal, todBlendRatio);
                        }
                    };
                    // preview should end when exiting the history panel
                    thumbs.appendChild(currDiv);

                    // --- Session outputs (history images) ---
                    sessionOutputs.forEach((item, idx) => {
                        const div = document.createElement('div');
                        div.className = 'historyThumb' +
                            (idx === currentOutIndex ? ' selected' : '') +
                            (idx === beforeLockIndex ? ' lockedBefore' : '');
                        const img = document.createElement('img');
                        img.src = item.img.src || item.img;
                        div.appendChild(img);

                        let origImg = null;
                        let blendSlider = null;
                        if (item.model === 'TIME OF DAY' && item.orig) {
                            origImg = document.createElement('img');
                            origImg.src = item.orig.src || item.orig;
                            origImg.className = 'thumbBlendOrig';
                            const bVal = typeof item.blend === 'number' ? item.blend : 1;
                            origImg.style.opacity = 1 - bVal;
                            div.appendChild(origImg);

                            blendSlider = document.createElement('input');
                            blendSlider.type = 'range';
                            blendSlider.min = '0';
                            blendSlider.max = '1';
                            blendSlider.step = '0.01';
                            blendSlider.value = bVal;
                            blendSlider.className = 'stealthSlider thumbBlendSlider';
                            blendSlider.title = 'Blend with original';
                            blendSlider.addEventListener('click', e => e.stopPropagation());
                            blendSlider.addEventListener('mousedown', e => e.stopPropagation());
                            blendSlider.addEventListener('input', () => {
                                const v = parseFloat(blendSlider.value);
                                item.blend = v;
                                if (origImg) origImg.style.opacity = 1 - v;
                                if ((currentOutIndex === idx) || (isHistoryPreviewActive && backgroundImage === item.img)) {
                                    todBlendOriginal = item.orig;
                                    todBlendRatio = v;
                                    drawCanvas();
                                }
                                setSliderGradient(blendSlider);
                            });
                            div.appendChild(blendSlider);
                            setSliderGradient(blendSlider);
                        }

                        if (item.model) {
                            const lab = document.createElement('div');
                            lab.className = 'historyModelLabel';
                            lab.textContent = item.model;
                            div.appendChild(lab);
                        }

                        if (item.info) {
                            const infoIcon = document.createElement('i');
                            infoIcon.className = 'fas fa-info-circle historyInfoIcon';
                            const truncated = truncatePromptLine(item.info);
                            const tooltip = document.createElement('div');
                            tooltip.className = 'historyInfoTooltip';
                            tooltip.textContent = truncated;
                            //infoIcon.setAttribute('data-tip', truncated.replace(/"/g, '&quot;'));
                            infoIcon.addEventListener('click', e => {
                                e.stopPropagation();
                                navigator.clipboard.writeText(item.info);
                            });
                            div.appendChild(infoIcon);
                            div.appendChild(tooltip);
                        }

                        const focusIcon = document.createElement('i');
                        focusIcon.className = 'fas fa-crosshairs historyFocusIcon';
                        focusIcon.addEventListener('click', e => {
                            e.stopPropagation();
                            beforeLockIndex = beforeLockIndex === idx ? -1 : idx;
                            endHistoryPreview();
                            updateHistoryThumbs();
                        });
                        div.appendChild(focusIcon);

                        const delIcon = document.createElement('i');
                        delIcon.className = 'fas fa-trash-alt historyDeleteIcon';
                        delIcon.addEventListener('click', e => {
                            e.stopPropagation();
                            // Clear any active preview state to avoid swapped thumbnails
                            endHistoryPreview();
                            resetBeforeAfterState();
                            sessionOutputs.splice(idx, 1);
                            if (currentOutIndex === idx) {
                                currentOutIndex = -1;
                                backgroundImage = liveBGImage;
                                computeBgLayout(backgroundImage);
                                drawCanvas();
                                updateFgStickerVisibility();
                            } else if (currentOutIndex > idx) {
                                currentOutIndex--;
                            }
                            if (beforeLockIndex === idx) {
                                beforeLockIndex = -1;
                            } else if (beforeLockIndex > idx) {
                                beforeLockIndex--;
                            }
                            if (selectedHistoryIndex === idx) {
                                selectedHistoryIndex = -1;
                            } else if (selectedHistoryIndex > idx) {
                                selectedHistoryIndex--;
                            }
                            updateHistoryThumbs();
                        });
                        div.appendChild(delIcon);

                        div.onclick = () => {
                            // snapshot and immediately hide FG to keep thumbnail translations live
                            liveFGStickers = stickers.map(cloneSticker);
                            areFgStickersHidden = true;
                            updateFgStickerVisibility();

                            isHistoryPreviewActive = false;
                            hoverPreviewState = null; // lock selected history image
                            currentOutIndex = idx;
                            selectedHistoryIndex = idx;
                            backgroundImage = item.img;
                            isOverlayVisible = false; // <-- Add this line
                            if (item.model === 'ENHANCE' && item.fullSrc) {
                                enhanceImage = new Image();
                                enhanceImage.crossOrigin = 'Anonymous';
                                enhanceImage.src = item.fullSrc;
                                enhancePreviewImg.src = item.fullSrc;
                                enhancePreviewOverlay.style.display = 'flex';
                                setActionText('Showing enhanced image full size');
                            }
                            resetBeforeAfterState();
                            computeBgLayout(backgroundImage);
                            if (item.model === 'TIME OF DAY' && item.orig) {
                                todBlendOriginal = item.orig;
                                todBlendRatio = typeof item.blend === 'number' ? item.blend : 1;
                            } else {
                                todBlendOriginal = null;
                                todBlendRatio = 1;
                            }
                            //areFgStickersHidden = true;
                            updateFgStickerVisibility();
                            updateFgToggleBtnVisual();
                            updateHistoryThumbs();
                            if (window.isGlbReady) hide3DOverlay();
                        };
                        if (item.model === 'TIME OF DAY' && item.orig) {
                            div.addEventListener('mouseenter', () => {
                                if (blendSlider) {
                                    blendSlider.style.opacity = '1';
                                    blendSlider.style.pointerEvents = 'auto';
                                }
                                startHistoryPreview(item.img, true, item.orig, typeof item.blend === 'number' ? item.blend : 1);
                            });
                            div.addEventListener('mouseleave', () => {
                                if (blendSlider) {
                                    blendSlider.style.opacity = '0';
                                    blendSlider.style.pointerEvents = 'none';
                                }
                                // keep preview active when moving between thumbnails; it will
                                // end only when exiting the history panel
                            });
                        } else {
                            div.addEventListener('mouseenter', () => startHistoryPreview(item.img));
                            // intentionally no mouseleave handler so preview persists between thumbs
                        }
                        // preview should end when exiting the history panel
                        thumbs.appendChild(div);
                    });
                    updateBeforeAfterButton();
                    requestAnimationFrame(() => {
                        const maxScroll = Math.max(0, thumbs.scrollHeight - thumbs.clientHeight);
                        thumbs.scrollTop = Math.min(prevScrollTop, maxScroll);
                        refreshHistoryScrollControls();
                    });
                }

                function updateBeforeAfterButton() {
                    if (!beforeAfterBtn) return;
                    const beforeImg = getBeforeImage();
                    if (beforeImg && liveBGImage && (currentOutIndex !== -1 || beforeLockIndex !== -1)) {
                        beforeAfterBtn.style.display = 'inline-flex';
                        beforeAfterBtn.title = isBeforeAfterPreview ? 'Show After' : 'Show Before';
                        beforeAfterBtn.classList.toggle('fresh', beforeAfterFresh && !isBeforeAfterPreview);
                        beforeAfterLabel.style.display = 'inline-block';
                        beforeAfterLabel.textContent = isBeforeAfterPreview ? 'BEFORE' : 'AFTER';
                        beforeAfterLabel.classList.toggle('before', isBeforeAfterPreview);
                        beforeAfterLabel.classList.toggle('after', !isBeforeAfterPreview);
                        if (canvasBeforeLock) {
                            canvasBeforeLock.style.display = 'inline-block';
                            const idxToCompare = isBeforeAfterPreview
                                ? (beforeLockIndex === -1 ? currentOutIndex - 1 : beforeLockIndex)
                                : currentOutIndex;
                            canvasBeforeLock.classList.toggle('locked', beforeLockIndex !== -1 && beforeLockIndex === idxToCompare);
                        }
                    } else {
                        beforeAfterBtn.style.display = 'none';
                        beforeAfterLabel.style.display = 'none';
                        if (canvasBeforeLock) canvasBeforeLock.style.display = 'none';
                    }
                }

                function updateFgStickerVisibility() {
                    if (isHistoryPreviewActive || areFgStickersHidden) {
                        stickers.forEach(st => {
                            if (!st.domElement) return;
                            st.domElement.style.visibility = "hidden";
                            st.hidden = true;
                            if (st.domFocus) st.domFocus.classList.remove("active");
                        });
                        liveFGStickers.forEach(st => { st.hidden = true; });
                        if (window.isGlbReady) hide3DOverlay();
                        drawCanvas();
                        return;
                    }
                    const shouldShowFg = isBeforeAfterPreview ||
                        //(
                        //    !areFgStickersHidden &&
                        //    (
                        //        isLiveHistoryPreview ||
                        //        (selectedHistoryIndex === -1 && currentOutIndex === -1) ||
                        //        (selectedHistoryIndex === currentOutIndex)
                        //    )
                        //);
                        isLiveHistoryPreview ||
                        (selectedHistoryIndex === -1 && currentOutIndex === -1) ||
                        (selectedHistoryIndex === currentOutIndex);
                    stickers.forEach(st => {
                        if (!st.domElement) return;
                        st.domElement.style.visibility = shouldShowFg ? "visible" : "hidden";
                        st.hidden = !shouldShowFg;
                        if (st.domFocus) st.domFocus.classList.toggle("active", shouldShowFg);
                    });
                    liveFGStickers.forEach(st => { st.hidden = !shouldShowFg; });
                    if (window.isGlbReady) {
                        if (shouldShowFg) {
                            restore3DOverlay();
                        } else {
                            hide3DOverlay();
                        }
                    }
                    drawCanvas();
                }


                /******************************************************
                * MOUSE EVENTS
                ******************************************************/
                canvas.addEventListener('mousedown', e => {
                    if (isClickMode) return;


                    if (hoveredStickerIndex !== -1) {
                        const st = stickers[hoveredStickerIndex];
                        const w = st.img.width * st.scale;
                        const h = st.img.height * st.scale;
                        const actionY = st.y + h - 5;
                        const actionX = st.x + w / 2;
                        const actionSize = 32;
                        const { x, y } = getWorldCoords(e.clientX, e.clientY);

                        if (
                            (x - actionX) ** 2 + (y - actionY) ** 2 < (actionSize / 2 + 6) ** 2
                        ) {
                            const st = stickers[hoveredStickerIndex];
                            if (!st || (st.spinAnim && st.spinAnim.isSpinning)) return; // Already spinning

                            st.spinAnim = { start: performance.now(), isSpinning: true };
                            animateSpin(st);

                            const menuSticker = st;
                            setTimeout(() => {
                                if (!menuSticker) return;
                                actionMenuOpenIndex = stickers.indexOf(menuSticker);
                                openStickerActionDrawer(menuSticker);
                                drawCanvas();
                            }, 210);
                            drawCanvas();
                            return;
                        }
                    }
                    /* 2️⃣  Convert to world coords & pick sticker */
                    const { x, y } = getWorldCoords(e.clientX, e.clientY);
                    for (let i = stickers.length - 1; i >= 0; i--) {
                        const st = stickers[i];
                        const w = st.img.width * st.scale;
                        const h = st.img.height * st.scale;
                        const sideBand = Math.floor(h * 0.3);

                        if (x >= st.x && x <= st.x + 32 &&
                            y >= st.y + sideBand && y <= st.y + h - sideBand) {
                            st.flipX = !st.flipX;
                            drawCanvas();
                            updateLiveSnapshotIfCurrent();
                            updateHistoryThumbs();
                            return;
                        }
                        // Right
                        if (x >= st.x + w - 32 && x <= st.x + w &&
                            y >= st.y + sideBand && y <= st.y + h - sideBand) {
                            st.flipX = !st.flipX;
                            drawCanvas();
                            updateLiveSnapshotIfCurrent();
                            updateHistoryThumbs();
                            return;
                        }

                        if (!st.flipBookImages || st.flipBookImages.length < 2) continue;
                        if (deleteButtonHit(st, x, y)) {
                            deleteCurrentFlipbookImage(st);
                            drawCanvas();
                            updateLiveSnapshotIfCurrent();
                            updateHistoryThumbs();
                            return; // Stop - don't start drag
                        }
                        const hit = arrowBoxHit(st, x, y);
                        if (hit === "prev") {
                            stepFlipbook(st, -1);
                            stickers.forEach(st => {
                                if (st.domFocus) st.domFocus.style.display = "none";
                                if (st.domScaleGui) st.domScaleGui.style.display = "none";
                            });
                            activeStickerIndex = -1;
                            hoveredStickerIndex = -1;
                            drawCanvas();
                            updateLiveSnapshotIfCurrent();
                            updateHistoryThumbs();
                            return; // Stop - don't start drag
                        }
                        if (hit === "next") {
                            stepFlipbook(st, 1);
                            stickers.forEach(st => {
                                if (st.domFocus) st.domFocus.style.display = "none";
                                if (st.domScaleGui) st.domScaleGui.style.display = "none";
                            });
                            activeStickerIndex = -1;
                            hoveredStickerIndex = -1;
                            drawCanvas();
                            updateLiveSnapshotIfCurrent();
                            updateHistoryThumbs();
                            return; // Stop - don't start drag
                        }
                    }
                    const clickedIndex = hitTestSticker(x, y);
                    if (clickedIndex !== -1) {
                        if (e.shiftKey) {
                            if (selectedStickerIndices.has(clickedIndex)) {
                                selectedStickerIndices.delete(clickedIndex);
                            } else {
                                selectedStickerIndices.add(clickedIndex);
                            }
                        } else {
                            selectedStickerIndices.clear();
                            selectedStickerIndices.add(clickedIndex);
                        }
                        activeStickerIndex = clickedIndex;
                        ensureHudForSticker(stickers[activeStickerIndex]);
                        showHudManually = true;
                        const st = stickers[activeStickerIndex];
                        layoutModeButton(st, activeStickerIndex);
                        drawCanvas();
                    } else {
                        activeStickerIndex = -1;
                        selectedStickerIndices.clear();
                        hoveredStickerIndex = -1;
                        isDraggingSticker = false;
                        isResizingCorner = false;
                        drawCanvas();
                        return;
                    }
                    hoveredStickerIndex = -1;
                    isDraggingSticker = false;
                    isResizingCorner = false;

                    let st = stickers[activeStickerIndex];

                    switch (st.mode) {

                        case 'edit':
                            if (e.altKey) {
                                const cloned = cloneSticker(st);
                                stickers.push(cloned);
                                activeStickerIndex = stickers.length - 1;
                                selectedStickerIndices.clear();
                                selectedStickerIndices.add(activeStickerIndex);
                                ensureHudForSticker(cloned);
                                drawCanvas();
                                updateLiveSnapshotIfCurrent();
                                updateHistoryThumbs();
                                st = cloned;
                                didSomething = true;
                                isDraggingSticker = true;
                                dragOffsetX = x - st.x;
                                dragOffsetY = y - st.y;
                                break;
                            }
                            if (e.ctrlKey) {
                                if (beginRotation(st, x, y)) return;
                                return;
                            }
                            if (beginScaling(st, x, y)) return;          // corner ⇒ live scale
                            didSomething = true;
                            isDraggingSticker = true;               // ② start drag
                            dragOffsetX = x - st.x;
                            dragOffsetY = y - st.y;
                            break;

                        case 'upload': {
                            /* allow corner-resize first */
                            if (beginScaling(st, x, y)) break;

                            /* plain click ⇒ open FG chooser, remember which sticker to update */
                            currentUploadSticker = st;
                            fgImageInput.click();
                            break;
                        }
                    }

                    if (st.flipBookImages && st.flipBookImages.length > 1) {
                        const hit = arrowBoxHit(st, x, y);
                        if (hit === "prev") {
                            stepFlipbook(st, -1);
                            drawCanvas();
                            updateLiveSnapshotIfCurrent();
                            updateHistoryThumbs();
                            return; // do not start drag
                        }
                        if (hit === "next") {
                            stepFlipbook(st, 1);
                            drawCanvas();
                            updateLiveSnapshotIfCurrent();
                            updateHistoryThumbs();
                            return; // do not start drag
                        }
                    }
                });

                canvas.addEventListener("mousemove", (e) => {
                    if (isPanning) {
                        // convert screen-movement (pixels) → world-space units
                        let dx = (e.movementX / wrapperScale) * (1 / camScale);
                        let dy = (e.movementY / wrapperScale) * (1 / camScale);
                        if (e.shiftKey) {
                            if (!panLockAxis) panLockAxis = Math.abs(dx) > Math.abs(dy) ? 'x' : 'y';
                            if (panLockAxis === 'x') dy = 0; else dx = 0;
                        } else {
                            panLockAxis = null;
                        }
                        camOffsetX += dx * camScale;
                        camOffsetY += dy * camScale;
                        drawCanvas();
                        updateLiveSnapshotIfCurrent();
                        updateHistoryThumbs();
                        return;
                    }

                    const { x, y } = getWorldCoords(e.clientX, e.clientY);

                    if (isRotatingSticker && activeStickerIndex !== -1) {
                        const st = stickers[activeStickerIndex];
                        let angle = Math.atan2(y - rotationCenterY, x - rotationCenterX) - rotationStartAngle;
                        if (e.shiftKey) {
                            const step = Math.PI / 12;
                            angle = Math.round(angle / step) * step;
                        }
                        st.rotation = angle;
                        drawCanvas();
                        updateLiveSnapshotIfCurrent();
                        updateHistoryThumbs();
                        return;
                    }

                    if (isResizingCorner && activeStickerIndex !== -1) {
                        let st = stickers[activeStickerIndex];
                        let dx = x - stickerCenterX;
                        let dy = y - stickerCenterY;
                        let dist = Math.sqrt(dx * dx + dy * dy);
                        let ratio = dist / scaleStartDist;
                        st.scale = Math.max(0.05, originalScale * ratio);
                        let newW = st.img.width * st.scale;
                        let newH = st.img.height * st.scale;
                        st.x = stickerCenterX - newW / 2;
                        st.y = stickerCenterY - newH / 2;
                        drawCanvas();
                        updateLiveSnapshotIfCurrent();
                        updateHistoryThumbs();
                        return;
                    }

                    if (isDraggingSticker && activeStickerIndex !== -1) {
                        let st = stickers[activeStickerIndex];
                        let newX = x - dragOffsetX;
                        let newY = y - dragOffsetY;
                        if (e.shiftKey) {
                            if (!dragLockAxis) dragLockAxis = Math.abs(newX - st.x) > Math.abs(newY - st.y) ? 'x' : 'y';
                            if (dragLockAxis === 'x') newY = st.y; else newX = st.x;
                        } else {
                            dragLockAxis = null;
                        }
                        st.x = newX;
                        st.y = newY;
                        drawCanvas();
                        updateLiveSnapshotIfCurrent();
                        updateHistoryThumbs();
                        return;
                    }

                    if (hoveredStickerIndex !== -1) {
                        const st = stickers[hoveredStickerIndex];
                        const w = st.img.width * st.scale;
                        const h = st.img.height * st.scale;
                        const actionY = st.y + h - 5;
                        const actionX = st.x + w / 2;
                        const actionSize = 32;

                        // If mouse is over the menu button: set cursor, set hover state, redraw, and return!
                        if (
                            (x - actionX) ** 2 + (y - actionY) ** 2 < (actionSize / 2 + 6) ** 2
                        ) {
                            actionMenuHoverIndex = hoveredStickerIndex;
                            canvas.style.cursor = "pointer";
                            drawCanvas();
                            return; // This stops grab hand from appearing!
                        } else {
                            actionMenuHoverIndex = -1;
                        }
                    }
                    // Detect hover for both active and inactive stickers
                    let foundHover = false;
                    flipButtonSide = null;

                    for (let i = stickers.length - 1; i >= 0; i--) {
                        const st = stickers[i];
                        const w = st.img.width * st.scale;
                        const h = st.img.height * st.scale;

                        // 1️⃣ If inside sticker bounds...
                        if (x >= st.x && x <= st.x + w && y >= st.y && y <= st.y + h) {
                            foundHover = true;
                            hoveredStickerIndex = i;

                            // 1. Flip side (priority: left or right vertical band, center third only)
                            const sideBand = Math.floor(h * 0.3);
                            // Left
                            if (x >= st.x && x <= st.x + 32 &&
                                y >= st.y + sideBand && y <= st.y + h - sideBand) {
                                flipButtonSide = "left";
                                canvas.style.cursor = "pointer";
                                drawCanvas();
                                return;
                            }
                            // Right
                            if (x >= st.x + w - 32 && x <= st.x + w &&
                                y >= st.y + sideBand && y <= st.y + h - sideBand) {
                                flipButtonSide = "right";
                                canvas.style.cursor = "pointer";
                                drawCanvas();
                                return;
                            }

                            // 2. Flipbook buttons: delete & arrows
                            if (st.flipBookImages && st.flipBookImages.length > 1) {
                                const del = deleteButtonHit(st, x, y);
                                st.deleteHover = del;
                                if (del) {
                                    canvas.style.cursor = "pointer";
                                    drawCanvas();
                                    return;
                                }
                                const hit = arrowBoxHit(st, x, y);
                                st.arrowHover = (hit === "prev") ? "left"
                                    : (hit === "next") ? "right"
                                        : null;
                                if (hit === "prev" || hit === "next") {
                                    canvas.style.cursor = "pointer";
                                    drawCanvas();
                                    return;
                                }
                            } else {
                                st.arrowHover = null;
                                st.deleteHover = false;
                            }

                            // 3. Corner pin scaling
                            const hit = hitCornerHandle(st, x, y);
                            if (hit !== -1) {
                                canvas.style.cursor = ctrlDown
                                    ? 'grab'
                                    : ((hit === 0 || hit === 3) ? 'nwse-resize' : 'nesw-resize');
                                hoveredCornerIndex = hit;
                                drawCanvas();
                                return;
                            } else {
                                hoveredCornerIndex = -1;
                            }
                            if (actionMenuOpenIndex !== -1 && stickers[actionMenuOpenIndex]) {
                                openStickerActionDrawer(stickers[actionMenuOpenIndex]);
                            }
                            // 4. Inside sticker, center: move/drag
                            canvas.style.cursor = isDraggingSticker ? "grabbing" : "grab";
                            drawCanvas();
                            return;
                        }
                    }
                    if (!foundHover && hoveredStickerIndex !== -1) {
                        hoveredStickerIndex = -1;
                        flipButtonSide = null;
                        hoveredCornerIndex = -1;
                        canvas.style.cursor = "default";
                        drawCanvas();
                        updateLiveSnapshotIfCurrent();
                        updateHistoryThumbs();
                    }

                    // Default: reset cursor and hover corner
                    //if (isCanvasClean()) {
                    //    canvas.style.cursor = imageCursor;
                    //    showCanvasHoverTip(e);
                    //} else {
                    //    canvas.style.cursor = "default";
                    //    document.getElementById("floatingCanvasTip").classList.remove("visible");
                    //}
                    document.getElementById("floatingCanvasTip").classList.remove("visible");
                    canvas.style.cursor = "default";

                    if (hoveredCornerIndex !== -1) {
                        hoveredCornerIndex = -1;
                        drawCanvas();
                    }
                    if (hoveredStickerIndex !== -1) {
                        const st = stickers[hoveredStickerIndex];
                        if (st.flipBookImages && st.flipBookImages.length > 1) {
                            const hit = arrowBoxHit(st, x, y);
                            if (hit === "prev" || hit === "next") {
                                canvas.style.cursor = "pointer";
                                return;
                            }
                        }
                    }
                    if (hoveredStickerIndex !== -1 && ctrlDown && !isRotatingSticker) {
                        showRotateHint(stickers[hoveredStickerIndex]);
                    } else if (!isRotatingSticker) {
                        hideRotateHint();
                    }
                    if (hoveredStickerIndex === -1) {
                        // Restore sticker GUI overlays unless ctrl is held
                        stickers.forEach(st => {
                            if (st.domFocus) st.domFocus.style.display = ctrlDown ? "none" : "flex";
                            if (st.domScaleGui) st.domScaleGui.style.display = "none";
                        });
                        activeStickerIndex = -1;
                        drawCanvas();
                    }
                });

                document.addEventListener("mouseup", (e) => {
                    isPanning = false;
                    isDraggingSticker = false;
                    isResizingCorner = false;
                    isRotatingSticker = false;
                    dragLockAxis = null;
                    panLockAxis = null;
                    hideRotateHint();

                    if (didSomething) pushHistory();
                    didSomething = false;
                    hoveredCornerIndex = -1;
                });

                canvas.addEventListener("click", () => {
                    if (isClickMode) return;
                    if (showHudManually) {
                        showHudManually = false;
                        return;
                    }

                    viewModeClicks = (viewModeClicks + 1) % 3;

                    stickers.forEach(st => {
                        if (!st.domFocus) return;

                        const isVisible = st.domElement?.style.visibility !== "hidden";

                        if (viewModeClicks === 1) {
                            // 🔹 First click: hide mode, outline; show focus only for hidden stickers
                            st.domFocus.style.display = isVisible ? "none" : "flex";
                            st.domFocus.style.opacity = 1;
                        } else if (viewModeClicks === 2) {
                            // 🔹 Second click: hide everything
                            st.domFocus.style.display = "none";
                        } else {
                            // 🔹 Third click: re-show focus if hidden
                            st.domFocus.style.display = st.hidden ? "flex" : "none";
                            st.domFocus.style.opacity = 1;
                        }
                    });
                    if (viewModeClicks === 1 || viewModeClicks === 2) {
                        activeStickerIndex = -1; // Deselect sticker!
                        hoveredStickerIndex = -1;
                        drawCanvas();            // Ensure layoutModeButton() runs with idx === -1
                    }

                    if (is3DActive && window.glbStickers && window.glbStickers.length) {
                        window.glbStickers.forEach(st => {
                            st.outline.style.opacity = 0;
                            st.focusBtn.style.display = "none";
                        });
                        if (viewModeClicks === 1) {
                            window.glbStickers.forEach(st => {
                                st.outline.style.opacity = 0;
                                st.focusBtn.style.display = "flex";
                            });
                        } else if (viewModeClicks === 2) {
                            window.glbStickers.forEach(st => {
                                st.outline.style.opacity = 0;
                                st.focusBtn.style.display = "none";
                            });
                        } else {
                            window.glbStickers.forEach(st => {
                                st.focusBtn.style.display = st.canvas.style.display === "none" ? "flex" : "none";
                            });
                        }
                    }
                });

                /**
                 * Extract a sticker region from a relit composite, with scaling handled automatically.
                 * @param {Image} relitComposite - The relit result image (from LBM).
                 * @param {HTMLCanvasElement} compCanvas - The canvas sent to LBM.
                 * @param {Object} st - The sticker object (must have x, y, img.width, img.height).
                 * @returns {HTMLCanvasElement} - The sticker region as a canvas.
                 */
                function extractStickerFromLBMScaled(relitComposite, compCanvas, st) {
                    const scaleX = relitComposite.width / compCanvas.width;
                    const scaleY = relitComposite.height / compCanvas.height;
                    const stickerCanvas = document.createElement("canvas");
                    stickerCanvas.width = st.img.width;
                    stickerCanvas.height = st.img.height;
                    const sCtx = stickerCanvas.getContext("2d");

                    // Scale extraction to match any backend size difference
                    sCtx.drawImage(
                        relitComposite,
                        st.x * scaleX, st.y * scaleY, st.img.width * scaleX, st.img.height * scaleY, // src (scaled)
                        0, 0, st.img.width, st.img.height                                            // dest
                    );

                    return stickerCanvas;
                }

                function updateStickerImageInPlace(st, img, scale = 1) {
                    st.img = img;
                    st.flipBookImages = [img];
                    st.flipBookIndex = 0;
                    st.mode = "edit";
                    st.scale = scale;
                    if (!st.domElement) createStickerDOM(st);
                    if (!st.domFocus) createModeButton(st);

                    // Only update overlays after the image is loaded and has real dimensions!
                    const updateOverlay = () => {
                        layoutModeButton(st, stickers.indexOf(st));
                        drawCanvas();
                    };
                    if (!img.complete || img.naturalWidth === 0) {
                        img.onload = updateOverlay;
                        st.domElement.src = img.src; // Will trigger onload when ready
                    } else {
                        updateOverlay();
                    }
                }
                // ---- Helper to load an image from dataURL or src ----
                function loadImageAsync(src) {
                    return new Promise((resolve, reject) => {
                        const img = new Image();
                        img.onload = () => resolve(img);
                        img.onerror = reject;
                        img.src = src;
                    });
                }

                // ---- Helper to apply original alpha to a relit canvas ----
                function applyAlphaFromSource(sourceImg, targetCanvas) {
                    const w = sourceImg.width, h = sourceImg.height;
                    const alphaSrc = document.createElement("canvas");
                    alphaSrc.width = w;
                    alphaSrc.height = h;
                    const alphaCtx = alphaSrc.getContext("2d", { willReadFrequently: true });
                    alphaCtx.drawImage(sourceImg, 0, 0);
                    const alphaData = alphaCtx.getImageData(0, 0, w, h).data;

                    const outCtx = targetCanvas.getContext("2d", { willReadFrequently: true });
                    const outImgData = outCtx.getImageData(0, 0, w, h);
                    const outData = outImgData.data;

                    for (let i = 0; i < outData.length; i += 4) {
                        outData[i + 3] = alphaData[i + 3];
                    }
                    outCtx.putImageData(outImgData, 0, 0);
                }

                function exportStickerImage(st) {
                    if (!st || !st.img) return;
                    const scale = st.scale || 1;
                    const rot = st.rotation || 0;
                    const img = st.img;
                    const w = img.width * scale;
                    const h = img.height * scale;
                    const cos = Math.cos(rot);
                    const sin = Math.sin(rot);
                    const off = document.createElement("canvas");
                    off.width = Math.ceil(Math.abs(w * cos) + Math.abs(h * sin));
                    off.height = Math.ceil(Math.abs(w * sin) + Math.abs(h * cos));
                    const ctx = off.getContext("2d");
                    ctx.translate(off.width / 2, off.height / 2);
                    if (st.flipX) ctx.scale(-1, 1);
                    ctx.rotate(rot);
                    ctx.scale(scale, scale);
                    ctx.drawImage(img, -img.width / 2, -img.height / 2);
                    try {
                        const dataUrl = off.toDataURL("image/png");
                        const link = document.createElement("a");
                        link.download = "fg.png";
                        link.href = dataUrl;
                        document.body.appendChild(link);
                        link.click();
                        link.remove();
                    } catch (err) {
                        console.error("Export failed:", err);
                    }
                }

                // ---- FG Import Handler ----
                document.getElementById('fgImageInput').addEventListener('change', function (e) {
                    const file = e.target.files[0];
                    if (!file) { this.value = ""; return; }

                    const reader = new FileReader();
                    reader.onload = function () {
                        window.pendingFGImport = reader.result; // full base64 (RGBA)
                        showRelightPromptCentered();
                        updateLBMIndicatorBtn();
                    };
                    reader.readAsDataURL(file);
                    this.value = "";
                });

                function captureGlbStickerSnapshot(sticker) {
                    if (!sticker || !(sticker.canvas instanceof HTMLCanvasElement)) return null;

                    const wrapper = document.getElementById("canvasWrapper");
                    if (!wrapper) return null;

                    try {
                        if (sticker.renderer && sticker.scene && sticker.camera && typeof sticker.renderer.render === "function") {
                            sticker.renderer.render(sticker.scene, sticker.camera);
                        }
                    } catch (renderErr) {
                        console.warn("Relight snapshot render failed:", renderErr);
                    }

                    const wrapRect = wrapper.getBoundingClientRect();
                    const rect = sticker.canvas.getBoundingClientRect();

                    const worldWidth = rect.width / camScale;
                    const worldHeight = rect.height / camScale;
                    if (!worldWidth || !worldHeight) return null;

                    const worldX = (rect.left - wrapRect.left - camOffsetX) / camScale;
                    const worldY = (rect.top - wrapRect.top - camOffsetY) / camScale;

                    const snapWidth = Math.max(1, Math.round(worldWidth));
                    const snapHeight = Math.max(1, Math.round(worldHeight));
                    const snapshotCanvas = document.createElement("canvas");
                    snapshotCanvas.width = snapWidth;
                    snapshotCanvas.height = snapHeight;

                    try {
                        const srcW = sticker.canvas.width || rect.width;
                        const srcH = sticker.canvas.height || rect.height;
                        snapshotCanvas
                            .getContext("2d")
                            .drawImage(
                                sticker.canvas,
                                0, 0,
                                srcW, srcH,
                                0, 0,
                                snapWidth, snapHeight
                            );
                    } catch (err) {
                        console.error("Relight snapshot capture failed:", err);
                        return null;
                    }

                    return {
                        image: snapshotCanvas,
                        alphaSource: snapshotCanvas,
                        x: worldX,
                        y: worldY,
                        w: worldWidth,
                        h: worldHeight,
                        destW: snapWidth,
                        destH: snapHeight
                    };
                }

                async function runStickerRelight(sticker) {
                    const isGlbSticker = !!(sticker && !sticker.img && sticker.canvas instanceof HTMLCanvasElement);

                    if (!backgroundImage || !backgroundImage.width || !backgroundImage.height) {
                        setActionText("Load a background before relighting.");
                        hideCancelBtn();
                        return;
                    }

                    if (!sticker) {
                        setActionText("Relight requires a foreground sticker.");
                        hideCancelBtn();
                        return;
                    }

                    let stickerScale = typeof sticker.scale === "number" ? sticker.scale : 1;
                    let sourceForComposite = null;
                    let stickerRegion = null;
                    let alphaSource = null;

                    if (isGlbSticker) {
                        const snapshot = captureGlbStickerSnapshot(sticker);
                        if (!snapshot) {
                            setActionText("Relight needs a visible 3D snapshot first.");
                            hideCancelBtn();
                            return;
                        }
                        sourceForComposite = snapshot.image;
                        stickerRegion = {
                            x: snapshot.x,
                            y: snapshot.y,
                            w: snapshot.w,
                            h: snapshot.h,
                            destW: snapshot.destW,
                            destH: snapshot.destH
                        };
                        alphaSource = snapshot.alphaSource;
                        stickerScale = 1;
                    } else {
                        if (!sticker.img) {
                            setActionText("Relight requires a foreground sticker.");
                            hideCancelBtn();
                            return;
                        }
                        if (!sticker.img.width || !sticker.img.height) {
                            setActionText("Relight is unavailable until the sticker image finishes loading.");
                            hideCancelBtn();
                            return;
                        }
                        sourceForComposite = sticker.img;
                        stickerRegion = {
                            x: sticker.x,
                            y: sticker.y,
                            w: sticker.img.width * stickerScale,
                            h: sticker.img.height * stickerScale,
                            destW: sticker.img.width,
                            destH: sticker.img.height
                        };
                        alphaSource = sticker.img;
                    }

                    if (!stickerRegion.w || !stickerRegion.h) {
                        setActionText("Relight requires a visible sticker region.");
                        hideCancelBtn();
                        return;
                    }

                    showCancelBtn();
                    setActionText("Relighting...");

                    //const stickerScale = typeof sticker.scale === "number" ? sticker.scale : 1;

                    // 1. Build a composite image: BG + sticker at sticker position
                    const compositeCanvas = document.createElement("canvas");
                    compositeCanvas.width = backgroundImage.width;
                    compositeCanvas.height = backgroundImage.height;
                    const compCtx = compositeCanvas.getContext("2d");
                    compCtx.drawImage(backgroundImage, 0, 0, backgroundImage.width, backgroundImage.height);
                    //compCtx.drawImage(
                    //    sticker.img,
                    //    sticker.x, sticker.y,
                    //    sticker.img.width * stickerScale,
                    //    sticker.img.height * stickerScale
                    //);

                    // 2. Save sticker’s position/size for extraction after relight
                    //const stickerRegion = {
                    //    x: sticker.x,
                    //    y: sticker.y,
                    //    w: sticker.img.width * stickerScale,
                    //    h: sticker.img.height * stickerScale
                    //};
                    if (isGlbSticker) {
                        compCtx.drawImage(
                            sourceForComposite,
                            0, 0,
                            sourceForComposite.width || stickerRegion.destW,
                            sourceForComposite.height || stickerRegion.destH,
                            stickerRegion.x,
                            stickerRegion.y,
                            stickerRegion.w,
                            stickerRegion.h
                        );
                    } else {
                        compCtx.drawImage(
                            sourceForComposite,
                            stickerRegion.x,
                            stickerRegion.y,
                            stickerRegion.w,
                            stickerRegion.h
                        );
                    }

                    try {
                        const res = await fetch("/relight-lbm", {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({
                                fg_image: compositeCanvas.toDataURL("image/png"),
                                job_id: uuid(),
                            })
                        });
                        const result = await res.json();
                        if (result.image) {
                            // 3. Extract the correct sticker region, accounting for LBM's scaling
                            const relitComposite = await loadImageAsync(result.image);

                            const scaleX = relitComposite.width / compositeCanvas.width;
                            const scaleY = relitComposite.height / compositeCanvas.height;

                            // Extract at the sticker's original size to avoid double-scaling
                            const fgExtractCanvas = document.createElement("canvas");
                            fgExtractCanvas.width = Math.max(1, Math.round(stickerRegion.destW));
                            fgExtractCanvas.height = Math.max(1, Math.round(stickerRegion.destH));

                            fgExtractCanvas
                                .getContext("2d")
                                .drawImage(
                                    relitComposite,
                                    stickerRegion.x * scaleX,
                                    stickerRegion.y * scaleY,
                                    stickerRegion.w * scaleX,
                                    stickerRegion.h * scaleY,
                                    0, 0,
                                    fgExtractCanvas.width,
                                    fgExtractCanvas.height
                                );

                            // 4. Restore alpha (if needed)
                            //const fgAlphaCanvas = document.createElement("canvas");
                            //fgAlphaCanvas.width = sticker.img.width;
                            //fgAlphaCanvas.height = sticker.img.height;
                            //fgAlphaCanvas.getContext("2d").drawImage(
                            //    sticker.img, 0, 0,
                            //    fgAlphaCanvas.width, fgAlphaCanvas.height
                            //);
                            //applyAlphaFromSource(fgAlphaCanvas, fgExtractCanvas);
                            applyAlphaFromSource(alphaSource, fgExtractCanvas);


                            // 5. Update the sticker in place
                            const relitImg = await loadImageAsync(fgExtractCanvas.toDataURL("image/png"));

                            if (isGlbSticker) {
                                const newSticker = {
                                    img: relitImg,
                                    flipBookImages: [relitImg],
                                    flipBookIndex: 0,
                                    x: Math.round(stickerRegion.x),
                                    y: Math.round(stickerRegion.y),
                                    scale: 1,
                                    rotation: 0,
                                    flipX: false,
                                    mode: "edit",
                                    domButton: null,
                                    domElement: null
                                };
                                stickers.push(newSticker);
                                activeStickerIndex = stickers.length - 1;
                                createStickerDOM(newSticker);
                                createModeButton(newSticker);
                                layoutModeButton(newSticker, activeStickerIndex);
                                drawCanvas();
                                if (typeof updateLiveSnapshotIfCurrent === "function") updateLiveSnapshotIfCurrent();
                                if (typeof updateHistoryThumbs === "function") updateHistoryThumbs();
                                trackRecentImport(relitImg.src);
                                hideCancelBtn();
                                setActionText("Relit snapshot added as new sticker.");
                                return;
                            }

                            updateStickerImageInPlace(sticker, relitImg, sticker.scale);

                            drawCanvas();
                            hideCancelBtn();
                            setActionText("Relit FG placed");
                            trackRecentImport(sticker.img.src);
                        } else {
                            hideCancelBtn();
                            setActionText("Relight failed");
                        }
                    } catch (err) {
                        hideCancelBtn();
                        setActionText("Relight error: " + err.message);
                    }
                }

                // ---- Relight YES Handler: composite BG+FG, relight, extract FG ----
                document.getElementById('relightYesBtn').onclick = async function () {
                    hideRelightPrompt();
                    showCancelBtn();
                    if (!window.pendingFGImport || !backgroundImage) return;

                    setActionText("Relighting...");
                    fakeProcessBar(10000);

                    const fgImg = await loadImageAsync(window.pendingFGImport);

                    // Scale FG to fit within BG bounds
                    let scale = Math.min(
                        backgroundImage.width / fgImg.width,
                        backgroundImage.height / fgImg.height,
                        1
                    );
                    const scaledW = Math.round(fgImg.width * scale);
                    const scaledH = Math.round(fgImg.height * scale);

                    // Center the FG
                    const offsetX = Math.round((backgroundImage.width - scaledW) / 2);
                    const offsetY = Math.round((backgroundImage.height - scaledH) / 2);

                    // Composite BG + FG
                    const compositeCanvas = document.createElement("canvas");
                    compositeCanvas.width = backgroundImage.width;
                    compositeCanvas.height = backgroundImage.height;
                    const compCtx = compositeCanvas.getContext("2d");
                    compCtx.drawImage(backgroundImage, 0, 0, backgroundImage.width, backgroundImage.height);
                    compCtx.drawImage(fgImg, offsetX, offsetY, scaledW, scaledH);

                    try {
                        const res = await fetch("/relight-lbm", {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({
                                fg_image: compositeCanvas.toDataURL("image/png"),
                                job_id: uuid()
                            })
                        });
                        const result = await res.json();

                        // Stop the process bar as soon as the result is back
                        stopFakeProcessBar();

                        if (result.image) {
                            const relitComposite = await loadImageAsync(result.image);

                            // Extract the region where FG was composited
                            const fgExtractCanvas = document.createElement("canvas");
                            fgExtractCanvas.width = scaledW;
                            fgExtractCanvas.height = scaledH;
                            const extractCtx = fgExtractCanvas.getContext("2d");
                            const scaleX = relitComposite.width / compositeCanvas.width;
                            const scaleY = relitComposite.height / compositeCanvas.height;

                            extractCtx.drawImage(
                                relitComposite,
                                offsetX * scaleX, offsetY * scaleY, scaledW * scaleX, scaledH * scaleY,
                                0, 0, scaledW, scaledH
                            );

                            // Restore FG alpha
                            const fgAlphaCanvas = document.createElement("canvas");
                            fgAlphaCanvas.width = scaledW;
                            fgAlphaCanvas.height = scaledH;
                            fgAlphaCanvas.getContext("2d").drawImage(fgImg, 0, 0, scaledW, scaledH);

                            applyAlphaFromSource(fgAlphaCanvas, fgExtractCanvas);

                            // -- THIS IS WHERE YOU DEFINE relitFinalImg --
                            const relitFinalImg = await loadImageAsync(fgExtractCanvas.toDataURL("image/png"));

                            if (currentUploadSticker) {
                                const st = currentUploadSticker;
                                st.img = relitFinalImg;
                                st.flipBookImages = [relitFinalImg];
                                st.flipBookIndex = 0;
                                st.mode = "edit";
                                st.scale = st.scale || 1;
                                // Ensure overlays exist!
                                if (!st.domElement) createStickerDOM(st);
                                if (!st.domFocus) createModeButton(st);

                                // After setting the image, guarantee the DOM and overlay positions are up to date
                                st.domElement.src = relitFinalImg.src;
                                clampStickerToCanvas(st, { center: false });
                                layoutModeButton(st, stickers.indexOf(st));
                                currentUploadSticker = null;
                                activeStickerIndex = stickers.indexOf(st);
                            } else {
                                // Remove previous FG sticker if any (legacy/center mode only)
                                if (typeof activeStickerIndex === "number" && activeStickerIndex !== -1) {
                                    let st = stickers[activeStickerIndex];
                                    st.domElement?.remove();
                                    st.domFocus?.remove();
                                    stickers.splice(activeStickerIndex, 1);
                                    activeStickerIndex = -1;
                                }
                                // Place the relit sticker at the same center
                                const st = {
                                    img: relitFinalImg,
                                    x: 0,
                                    y: 0,
                                    scale: Math.min(scale || 1, 1),
                                    flipX: false,
                                    flipBookImages: [relitFinalImg],
                                    flipBookIndex: 0,
                                    rotation: 0,
                                    mode: "edit",
                                    domButton: null,
                                    domElement: null
                                };
                                stickers.push(st);
                                activeStickerIndex = stickers.length - 1;
                                createStickerDOM(st);
                                createModeButton(st);
                                clampStickerToCanvas(st, { center: true });
                                layoutModeButton(st, stickers.indexOf(st));
                            }
                            pushHistory();
                            drawCanvas();
                            hideCancelBtn();
                            setActionText("Relit FG placed");
                            trackRecentImport(fgImg.src);

                        } else {
                            setActionText("Relight failed");
                        }
                        window.pendingFGImport = null;
                    } catch (err) {
                        stopFakeProcessBar();
                        setActionText("Relight error: " + err.message);
                    }
                };


                // ---- Relight NO Handler: FG as-is ----
                document.getElementById('relightNoBtn').onclick = async function () {
                    hideRelightPrompt();

                    document.getElementById('relightPrompt').style.display = 'none';
                    if (!window.pendingFGImport) return;

                    const fgImg = await loadImageAsync(window.pendingFGImport);

                    // Compute scaled placement
                    let scale = Math.min(
                        backgroundImage.width / fgImg.width,
                        backgroundImage.height / fgImg.height,
                        1
                    );
                    const scaledW = Math.round(fgImg.width * scale);
                    const scaledH = Math.round(fgImg.height * scale);
                    const offsetX = Math.round((backgroundImage.width - scaledW) / 2);
                    const offsetY = Math.round((backgroundImage.height - scaledH) / 2);

                    // --- New: If in Upload FG mode, update sticker in place ---
                    if (currentUploadSticker) {
                        const st = currentUploadSticker;
                        st.img = fgImg;
                        st.flipBookImages = [fgImg];
                        st.flipBookIndex = 0;
                        st.mode = "edit";
                        // Preserve: x, y, scale, flipX!
                        if (!st.domElement) createStickerDOM(st);
                        if (!st.domFocus) createModeButton(st);
                        st.domElement.src = fgImg.src;
                        clampStickerToCanvas(st, { center: false });
                        layoutModeButton(st, stickers.indexOf(st));
                        activeStickerIndex = stickers.indexOf(st);
                        currentUploadSticker = null;
                    } else {
                        // Remove previous FG sticker if any (legacy/center mode only)
                        if (typeof activeStickerIndex === "number" && activeStickerIndex !== -1) {
                            let st = stickers[activeStickerIndex];
                            st.domElement?.remove();
                            st.domFocus?.remove();
                            stickers.splice(activeStickerIndex, 1);
                            activeStickerIndex = -1;
                        }
                        // Create and center sticker
                        const st = {
                            img: fgImg,
                            x: 0,
                            y: 0,
                            scale: Math.min(scale || 1, 1),
                            flipX: false,
                            flipBookImages: [fgImg],
                            flipBookIndex: 0,
                            rotation: 0,
                            mode: "edit",
                            domButton: null,
                            domElement: null
                        };
                        stickers.push(st);
                        activeStickerIndex = stickers.length - 1;
                        if (!st.domElement) createStickerDOM(st);
                        if (!st.domFocus) createModeButton(st);
                        st.domElement.src = fgImg.src;
                        clampStickerToCanvas(st, { center: true });
                        layoutModeButton(st, stickers.indexOf(st));
                    }

                    pushHistory();
                    drawCanvas();
                    setActionText("FG placed as-is");
                    trackRecentImport(fgImg.src);
                    window.pendingFGImport = null;
                };

                document.getElementById("closeRelightPromptBtn").onclick = function () {
                    hideRelightPrompt();
                };
                document.addEventListener('keydown', function (e) {
                    if (e.key === "Escape" && document.getElementById("relightPrompt").style.display !== "none") {
                        hideRelightPrompt();
                    }
                });

                /******************************************************
                 * BG => from computer
                 ******************************************************/
                bgFromComputerBtn.addEventListener("click", () => bgInput.click());
                bgInput.addEventListener("change", e => {
                    let file = e.target.files[0];
                    if (!file) return;
                    userLoadedBg = true;
                    disableBgHoverArea();
                    updatePromptHudTitle();
                    refreshDrawerState();

                    document.getElementById("homePromptContainer").style.display = "none";

                    let img = new Image();
                    img.onload = () => {
                        backgroundImage = img;
                        userLoadedBg = true;
                        disableBgHoverArea();
                        computeBgLayout(img);
                        depthImage = null;
                        imgGenImage = null;
                        segmentationMask = null;
                        refinedMaskImage = null;
                        //isOverlayVisible = false;
                        //toggleOverlayBtn.style.display = "none";

                        homeImageContainer.style.display = "none";
                        canvasContainer.style.display = "block";
                        updateCanvasCursorState();
                        mainHeader.style.display = "block";

                        drawCanvas();
                        liveBGImage = backgroundImage;
                        liveFGStickers = stickers.map(cloneSticker);
                        updateHistoryThumbs();

                        bgFilenameDiv.style.display = "block";
                        bgFilenameText.textContent = file.name;
                        setActionText("BG loaded from computer");
                    };
                    img.src = URL.createObjectURL(file);
                    e.target.value = "";
                });

                /******************************************************
                 * FG => single / multi
                 ******************************************************/
                document.addEventListener('DOMContentLoaded', () => {

                    fgImageBtn.addEventListener("click", () => fgImageInput.click());
                    //fgAssetBtn.addEventListener("click", () => fgAssetInput.click());
                    //fgFlipBookBtn.addEventListener("click", () => fgFlipBookInput.click());

                    // Single-image or Asset handler
                    function handleSingleStickerFile(file) {
                        if (!file || !file.type.startsWith("image/")) return;

                        function handleFGImport(fileOrDataUrl) {
                            window.pendingFGImport = fileOrDataUrl; // or an Image()
                            document.getElementById('relightPrompt').style.display = 'flex';
                        }

                        const img = new Image();
                        img.dataset.filename = file.name;
                        img.onload = () => {
                            const st = {
                                img,
                                x: 0,
                                y: 0,
                                scale: 1.0,
                                flipX: false,
                                flipBookImages: [img],
                                flipBookIndex: 0,
                                rotation: 0,
                                mode: "edit",
                                domButton: null,
                                domElement: null
                            };
                            stickers.push(st);
                            activeStickerIndex = stickers.length - 1;

                            if (!st.domElement) createStickerDOM(st);
                            if (!st.domFocus) createModeButton(st);
                            clampStickerToCanvas(st, { center: true });
                            layoutModeButton(st, stickers.indexOf(st));
                            pushHistory();
                            drawCanvas();

                            setTimeout(() => {
                                layoutModeButton(st, stickers.indexOf(st));
                                drawCanvas();
                            }, 0);  // Defer until DOM is fully laid out
                            setActionText("Foreground image added");
                            itrackRecentImport(img.src);
                        };
                        img.src = URL.createObjectURL(file);
                    }

                    // Wire up the inputs
                    document.getElementById('fgImageInput').addEventListener('change', function (e) {
                        const file = e.target.files[0];
                        if (!file) { this.value = ""; return; }

                        const reader = new FileReader();
                        reader.onload = function () {
                            // Only store the base64, do not create a sticker yet!
                            window.pendingFGImport = reader.result;
                            document.getElementById('relightPrompt').style.display = 'flex';
                        };
                        reader.readAsDataURL(file);
                        this.value = "";
                    });

                    fgAssetInput.addEventListener('change', async e => {
                        const file = e.target.files[0];
                        if (!file) return;

                        const reader = new FileReader();
                        reader.onload = async () => {
                            const fgImg = await loadImageAsync(reader.result);

                            let st;
                            if (currentUploadSticker) {
                                st = currentUploadSticker;
                                st.img = fgImg;
                                st.flipBookImages = [fgImg];
                                st.flipBookIndex = 0;
                                st.mode = "edit";
                                // Preserve: x, y, scale, flipX!
                                if (!st.domElement) createStickerDOM(st);
                                if (!st.domFocus) createModeButton(st);
                                st.domElement.src = fgImg.src;
                                clampStickerToCanvas(st, { center: false });
                                layoutModeButton(st, stickers.indexOf(st));
                                activeStickerIndex = stickers.indexOf(st);
                                currentUploadSticker = null;
                            } else {
                                st = {
                                    img: fgImg,
                                    x: 0,
                                    y: 0,
                                    scale: 1,
                                    flipX: false,
                                    flipBookImages: [fgImg],
                                    flipBookIndex: 0,
                                    rotation: 0,
                                    mode: "edit",
                                    domButton: null,
                                    domElement: null
                                };
                                stickers.push(st);
                                activeStickerIndex = stickers.length - 1;
                                if (!st.domElement) createStickerDOM(st);
                                if (!st.domFocus) createModeButton(st);
                                st.domElement.src = fgImg.src;
                                clampStickerToCanvas(st, { center: true });
                                layoutModeButton(st, stickers.indexOf(st));
                            }
                            pushHistory();
                            drawCanvas();
                            liveFGStickers = stickers.map(cloneSticker);
                            updateHistoryThumbs();
                            trackRecentImport(fgImg.src);

                            setActionText("Asset FG placed");
                            window.pendingFGImport = null;
                        };
                        reader.readAsDataURL(file);
                        e.target.value = "";
                    });

                    // FlipBook (multi-image) handler
                    fgFlipBookInput.addEventListener("change", e => {
                        const files = Array.from(e.target.files || []);
                        if (!files.length) {
                            setActionText("No stickers for FlipBook");
                            return;
                        }
                        let loadedCount = 0;
                        const flipImages = [];
                        files.forEach(file => {
                            const img = new Image();
                            img.onload = () => {
                                loadedCount++;
                                flipImages.push(img);

                                // Only after all images loaded
                                if (loadedCount === files.length) {
                                    if (currentUploadSticker) {
                                        const st = currentUploadSticker;
                                        st.flipBookImages = flipImages;
                                        st.flipBookIndex = 0;
                                        st.img = flipImages[0];
                                        if (!st.domElement) createStickerDOM(st);
                                        if (!st.domFocus) createModeButton(st);
                                        st.domElement.src = flipImages[0].src;
                                        clampStickerToCanvas(st, { center: false });
                                        layoutModeButton(st, stickers.indexOf(st));
                                        activeStickerIndex = stickers.indexOf(st);
                                        currentUploadSticker = null;
                                        trackRecentImport(flipImages[0].src);
                                    } else {
                                        const st = {
                                            img: flipImages[0],
                                            x: 0,
                                            y: 0,
                                            scale: 1.0,
                                            flipX: false,
                                            flipBookImages: flipImages,
                                            flipBookIndex: 0,
                                            domButton: null,
                                            domElement: null
                                        };
                                        stickers.push(st);
                                        activeStickerIndex = stickers.length - 1;
                                        if (!st.domElement) createStickerDOM(st);
                                        if (!st.domFocus) createModeButton(st);
                                        clampStickerToCanvas(st, { center: true });
                                        if (st.domElement) st.domElement.src = flipImages[0].src;
                                        layoutModeButton(st, stickers.indexOf(st));
                                        trackRecentImport(flipImages[0].src);
                                    }
                                    pushHistory();
                                    drawCanvas();
                                    setActionText(`Loaded ${files.length} images in FlipBook`);
                                    window.pendingFGImport = null;
                                }
                            };
                            img.src = URL.createObjectURL(file);
                        });
                        e.target.value = "";
                    });
                });

                /******************************************************
                * buildCompositeForBackend => for Backend Processes
                ******************************************************/
                async function buildCompositeForBackend() {
                    const restoreHud = hideAllStickerHud();

                    if (window.updateGlbPreviewImage) {
                        await window.updateGlbPreviewImage(true);
                    }

                    const srcBG = chooseCompositeBG();
                    const baseW = Math.max(1, bgW || canvas?.width || (srcBG?.naturalWidth || srcBG?.width) || 1);
                    const baseH = Math.max(1, bgH || canvas?.height || (srcBG?.naturalHeight || srcBG?.height) || 1);
                    const nativeW = srcBG
                        ? (srcBG.naturalWidth || srcBG.videoWidth || srcBG.width || baseW)
                        : baseW;
                    const nativeH = srcBG
                        ? (srcBG.naturalHeight || srcBG.videoHeight || srcBG.height || baseH)
                        : baseH;
                    const scaleX = nativeW / baseW;
                    const scaleY = nativeH / baseH;

                    const offC = document.createElement("canvas");
                    offC.width = Math.round(nativeW);
                    offC.height = Math.round(nativeH);
                    const offCtx = offC.getContext("2d");
                    offCtx.imageSmoothingEnabled = true;
                    offCtx.imageSmoothingQuality = "high";

                    offCtx.save();
                    offCtx.scale(scaleX, scaleY);

                    if (srcBG) {
                        offCtx.drawImage(srcBG, 0, 0, baseW, baseH);
                    } else if (backgroundImage) {
                        offCtx.drawImage(backgroundImage, 0, 0, baseW, baseH);
                    } else {
                        offCtx.clearRect(0, 0, baseW, baseH);
                    }

                    /* 2 – each sticker with proper masking */
                    const useLive = beforeLockIndex === -1 && (selectedHistoryIndex !== -1 || currentOutIndex !== -1);
                    const stickerSrc = useLive ? liveFGStickers : stickers;
                    stickerSrc.forEach(st => {
                        if (!st.img || st.hidden) return;
                        const tmpC = document.createElement('canvas');
                        tmpC.width = baseW;
                        tmpC.height = baseH;
                        const tCtx = tmpC.getContext('2d');
                        tCtx.imageSmoothingEnabled = true;
                        tCtx.imageSmoothingQuality = 'high';

                        /* a) sticker with transforms */
                        tCtx.save();
                        const w = st.img.width * st.scale;
                        const h = st.img.height * st.scale;
                        tCtx.translate(st.x + w / 2, st.y + h / 2);
                        if (st.flipX) tCtx.scale(-1, 1);
                        tCtx.rotate(st.rotation || 0);
                        tCtx.scale(st.scale, st.scale);
                        tCtx.drawImage(st.img, -st.img.width / 2, -st.img.height / 2);
                        tCtx.restore();

                        /* b) punch hole INSIDE the object (BG‑mode only) */
                        if (segmentationMask && !isForegroundMode) {
                            const mCan = document.createElement('canvas');
                            mCan.width = baseW;
                            mCan.height = baseH;
                            const mCtx = mCan.getContext('2d');
                            mCtx.imageSmoothingEnabled = true;
                            mCtx.imageSmoothingQuality = 'high';
                            mCtx.drawImage(segmentationMask, 0, 0, baseW, baseH);

                            const img = mCtx.getImageData(0, 0, baseW, baseH);
                            const d = img.data;
                            for (let i = 0; i < d.length; i += 4) {
                                const gray = (d[i] + d[i + 1] + d[i + 2]) / 3;
                                d[i + 3] = gray > 127 ? 255 : 0;
                            }
                            mCtx.putImageData(img, 0, 0);

                            tCtx.globalCompositeOperation = 'destination-out';
                            tCtx.drawImage(mCan, 0, 0, baseW, baseH);
                            tCtx.globalCompositeOperation = 'source-over';
                        }

                        /* c) blend back */
                        offCtx.drawImage(tmpC, 0, 0, baseW, baseH);
                    });

                    if (window.isGlbVisible && window.glbStickers && window.glbStickers.length) {
                        const wrapper = document.getElementById("canvasWrapper").getBoundingClientRect();
                        window.glbStickers.forEach(st => {
                            if (st.canvas.style.display === "none") return;
                            const rect = st.canvas.getBoundingClientRect();
                            const x = (rect.left - wrapper.left - camOffsetX) / camScale;
                            const y = (rect.top - wrapper.top - camOffsetY) / camScale;
                            const w = rect.width / camScale;
                            const h = rect.height / camScale;
                            offCtx.drawImage(st.canvas, x, y, w, h);
                        });
                    }

                    offCtx.restore();
                    applyImageAdjustmentsToContext(offCtx, offC.width, offC.height, { force: true });
                    restoreHud();
                    return offC;
                }

                // Build an FG-only alpha mask the same size as the background
                async function buildFgMaskForBackend(expandPx = 0, featherPx = 0) {
                    const srcBG = chooseCompositeBG();
                    const baseW = Math.max(1, bgW || canvas?.width || (srcBG?.naturalWidth || srcBG?.width) || 1);
                    const baseH = Math.max(1, bgH || canvas?.height || (srcBG?.naturalHeight || srcBG?.height) || 1);
                    const nativeW = srcBG
                        ? (srcBG.naturalWidth || srcBG.videoWidth || srcBG.width || baseW)
                        : baseW;
                    const nativeH = srcBG
                        ? (srcBG.naturalHeight || srcBG.videoHeight || srcBG.height || baseH)
                        : baseH;
                    const scaleX = nativeW / baseW;
                    const scaleY = nativeH / baseH;
                    const uniformScale = Math.max(scaleX, scaleY);

                    const mC = document.createElement("canvas");
                    mC.width = Math.round(nativeW);
                    mC.height = Math.round(nativeH);
                    const mX = mC.getContext("2d");
                    mX.imageSmoothingEnabled = true;
                    mX.imageSmoothingQuality = "high";

                    mX.save();
                    mX.scale(scaleX, scaleY);
                    mX.clearRect(0, 0, baseW, baseH);

                    const useLive = beforeLockIndex === -1 && (selectedHistoryIndex !== -1 || currentOutIndex !== -1);
                    const maskSrc = useLive ? liveFGStickers : stickers;
                    maskSrc.filter(st => !st.hidden).forEach(st => {
                        if (!st.img) return;
                        mX.save();
                        const w = st.img.width * st.scale;
                        const h = st.img.height * st.scale;
                        mX.translate(st.x + w / 2, st.y + h / 2);
                        if (st.flipX) mX.scale(-1, 1);
                        mX.rotate(st.rotation || 0);
                        mX.scale(st.scale, st.scale);
                        mX.drawImage(st.img, -st.img.width / 2, -st.img.height / 2);
                        mX.restore();
                    });
                    mX.restore();

                    const img = mX.getImageData(0, 0, mC.width, mC.height);
                    const d = img.data;
                    for (let i = 0; i < d.length; i += 4) {
                        const a = d[i + 3];
                        const v = a > 8 ? 255 : 0;
                        d[i] = d[i + 1] = d[i + 2] = v;
                        d[i + 3] = v;
                    }
                    mX.putImageData(img, 0, 0);

                    if (expandPx > 0 || featherPx > 0) {
                        const expandAmount = Math.max(0, expandPx * uniformScale);
                        const featherAmount = Math.max(0, featherPx * uniformScale);

                        const eC = document.createElement("canvas");
                        eC.width = mC.width; eC.height = mC.height;
                        const eX = eC.getContext("2d");
                        eX.imageSmoothingEnabled = true;
                        eX.imageSmoothingQuality = "high";
                        eX.filter = `blur(${expandAmount}px)`;
                        eX.drawImage(mC, 0, 0);

                        const fC = document.createElement("canvas");
                        fC.width = mC.width; fC.height = mC.height;
                        const fX = fC.getContext("2d");
                        fX.imageSmoothingEnabled = true;
                        fX.imageSmoothingQuality = "high";
                        fX.filter = `blur(${featherAmount}px)`;
                        fX.drawImage(eC, 0, 0);
                        return fC;
                    }
                    return mC;
                }


                /******************************************************
                * SAMPLES
                ******************************************************/
                bgSamplesBtn.addEventListener("click", async () => {
                    try {
                        let r = await fetch(`${API_BASE}/samples-list`);
                        let data = await r.json();
                        if (!Array.isArray(data) || data.length === 0) {
                            setActionText("No samples found");
                            return;
                        }
                        sampleImages = data;
                        currentSampleIndex = 0;
                        openSamplesOverlay(sampleImages[0]);
                    } catch (err) {
                        console.error("Samples =>", err);
                        setActionText("Samples => see console");
                    }
                });

                closeSamplesBtn.addEventListener("click", () => {
                    samplesOverlay.style.display = "none";
                });
                function openSamplesOverlay(filename) {
                    const overlay = document.getElementById("samplesOverlay");
                    if (!overlay) {
                        console.error("samplesGalleryOverlay not found!");
                        return;
                    }
                    samplesOverlay.style.display = "flex";
                    const useSampleBtn = document.getElementById("useSampleBtn");
                    if (!useSampleBtn) {
                        console.error("useSampleBtn not found!");
                        return;
                    }
                    samplesImage.src = `${API_BASE}/samples/${filename}?t=${Date.now()}`;
                }
                samplesArrowLeft.addEventListener("click", () => {
                    if (!sampleImages.length) return;
                    currentSampleIndex--;
                    if (currentSampleIndex < 0) currentSampleIndex = sampleImages.length - 1;
                    openSamplesOverlay(sampleImages[currentSampleIndex]);
                });
                samplesArrowRight.addEventListener("click", () => {
                    if (!sampleImages.length) return;
                    currentSampleIndex++;
                    if (currentSampleIndex >= sampleImages.length) currentSampleIndex = 0;
                    openSamplesOverlay(sampleImages[currentSampleIndex]);
                });
                useSampleBtn.addEventListener("click", () => {
                    if (!sampleImages.length) return;

                    // Close the overlay **first**:
                    samplesOverlay.style.display = "none";
                    document.getElementById("homePromptContainer").style.display = "none";

                    // Then load in background
                    const filename = sampleImages[currentSampleIndex];
                    const fullUrl = `${API_BASE}/samples/${filename}?t=${Date.now()}`;
                    loadNewBackgroundImage(fullUrl);
                    const bigImg = new Image();
                    bigImg.crossOrigin = "Anonymous";

                    bigImg.onload = () => {
                        backgroundImage = bigImg;
                        computeBgLayout(bigImg);
                        depthImage = null;
                        imgGenImage = null;
                        segmentationMask = null;
                        refinedMaskImage = null;
                        //isOverlayVisible = false;
                        //toggleOverlayBtn.style.display = "none";

                        homeImageContainer.style.display = "none";
                        canvasContainer.style.display = "block";
                        updateCanvasCursorState();
                        mainHeader.style.display = "block";
                        drawCanvas();
                        liveBGImage = backgroundImage;
                        liveFGStickers = stickers.map(cloneSticker);
                        updateLiveSnapshotIfCurrent();
                        updateHistoryThumbs();

                        bgFilenameDiv.style.display = "block";
                        bgFilenameText.textContent = filename;
                        setActionText("Background Loaded ✔");
                        syncCaption();

                    };

                    // Fire off the request
                    bigImg.src = `${API_BASE}/samples/${filename}`;
                });

                /******************************************************
                 * GALLERY
                 ******************************************************/
                galleryBtn.addEventListener("click", async () => {
                    try {
                        const resp = await fetch(`${API_BASE}/gallery-list`);
                        const data = await resp.json();
                        if (!Array.isArray(data)) {
                            setActionText("Gallery => invalid response");
                            return;
                        }
                        galleryFilenames = data;
                        galleryShowingCollections = false;
                        setGalleryCollectionsToggleState();
                        renderGalleryItems(galleryFilenames);
                        galleryOverlay.style.display = "flex";
                        galleryOverlay.scrollTop = 0;
                        requestAnimationFrame(adjustGalleryGrid);
                    } catch (err) {
                        console.error("Gallery =>", err);
                        setActionText("Gallery => see console");
                    }
                });

                if (galleryCollectionsToggle) {
                    galleryCollectionsToggle.addEventListener("click", () => {
                        galleryShowingCollections = !galleryShowingCollections;
                        setGalleryCollectionsToggleState();
                        if (galleryShowingCollections) {
                            renderGalleryItems(Array.from(galleryCollections));
                        } else {
                            renderGalleryItems(galleryFilenames);
                        }
                        requestAnimationFrame(adjustGalleryGrid);
                    });
                }
                closeGalleryBtn.addEventListener("click", () => {
                    galleryOverlay.style.display = "none";
                });
                gallerySizeSlider.addEventListener("input", () => {
                    galleryScale = parseFloat(gallerySizeSlider.value);
                    adjustGalleryGrid();
                });
                document.addEventListener("keydown", (e) => {
                    if (e.key === "Escape" && window.getComputedStyle(galleryOverlay).display !== "none") {
                        galleryOverlay.style.display = "none";
                    }
                });

                window.addEventListener("resize", adjustGalleryGrid);

                /******************************************************
                * FlipBook
                ******************************************************/
                let flipBookLibraryImages = [];

                fgFlipBookBtn.addEventListener("click", async () => {
                    // Show the Flip Book overlay
                    flipBookOverlay.style.display = "block";
                    flipBookImagesWrapper.innerHTML = "";
                    flipBookLibraryImages = [];

                    // Example list of subfolders you have in http://127.0.0.1:5000/flipbook/
                    try {
                        // 1) Fetch subfolders from your server
                        const resp = await fetch(`${API_BASE}/flipbook-list`);
                        const data = await resp.json();
                        // data is like:
                        // {
                        //   "chair1": ["chair_01.png","chair_02.png"],
                        //   "lamp1":  ["lamp_front.png","lamp_side.png"],
                        //   ...
                        // }

                        // 2) For each folderName => pick a random file or the first one
                        for (let folderName in data) {
                            const files = data[folderName];
                            if (!Array.isArray(files) || files.length === 0) continue;

                            // pick a random index:
                            const randomIndex = Math.floor(Math.random() * files.length);
                            const randomFile = files[randomIndex]; // e.g. "chair_01.png"

                            const fullPaths = files.map(fname =>
                                `${API_BASE}/flipbook/${folderName}/${fname}`
                            );
                            flipBookLibraryImages.push(fullPaths);
                        }

                        renderFlipBookLibrary();

                    } catch (err) {
                        console.error("FlipBook =>", err);
                        setActionText("FlipBook => see console for error");
                    }
                });

                // Click handlers for the import icons (top & bottom)
                document.getElementById('flipBookImportTop').onclick =
                    document.getElementById('flipBookImportBottom').onclick = function () {
                        document.getElementById('fgFlipBookInput').click();
                    };

                // When files are selected, add them to the library
                document.getElementById('fgFlipBookInput').onchange = function (e) {
                    const files = Array.from(e.target.files);
                    if (!files.length) return;

                    // Load all images, then push as a group
                    const group = [];
                    let loadedCount = 0;

                    files.forEach(file => {
                        const reader = new FileReader();
                        reader.onload = function (evt) {
                            group.push(evt.target.result);
                            loadedCount++;
                            if (loadedCount === files.length) {
                                // Push the group as a new flipbook entry, do NOT replace anything
                                flipBookLibraryImages.push(group);
                                renderFlipBookLibrary();   // This should render all groups, not just the last!
                            }
                        };
                        reader.readAsDataURL(file);
                    });

                    e.target.value = "";
                };

                function renderFlipBookLibrary() {
                    const wrapper = document.getElementById('flipBookImagesWrapper');
                    wrapper.innerHTML = '';
                    flipBookLibraryImages.forEach((group, groupIdx) => {
                        const itemDiv = document.createElement('div');
                        itemDiv.classList.add('flipBookItem');
                        let previewIdx = 0; // local to this closure

                        const imgEl = document.createElement('img');
                        imgEl.classList.add('flipBookImg');
                        imgEl.src = group[previewIdx];
                        itemDiv.appendChild(imgEl);

                        if (group.length > 1) {
                            const badge = document.createElement('span');
                            badge.textContent = group.length + ' imgs';
                            badge.style.cssText = 'position:absolute;top:7px;right:12px;font-size:11px;color:#27e0b8;';
                            itemDiv.appendChild(badge);

                            // Cycle left/right arrows
                            const arrowBtnStyle = `
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            position: absolute;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            top: 50%;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            transform: translateY(-50%) scaleY(2.0) scaleX(0.85);
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            font-size: 54px;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            color: #eee;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            background: none;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            border: none;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            cursor: pointer;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            padding: 0 6px;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            font-weight: 1000;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            border-radius: 8px;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            transition: color 0.16s, background 0.16s;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            //box-shadow: 0 1px 6px #111b, 0 0 1px #000a;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            z-index: 2;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        `;

                            // Left
                            const leftBtn = document.createElement('button');
                            leftBtn.innerHTML = "&#10094;"; // Unicode ❮
                            leftBtn.style.cssText = arrowBtnStyle + "left: 6px;";
                            leftBtn.onclick = (e) => {
                                e.stopPropagation();
                                previewIdx = (previewIdx - 1 + group.length) % group.length;
                                imgEl.src = group[previewIdx];
                            };
                            leftBtn.onmouseenter = function () {
                                this.style.color = "#31e9b1";
                                //this.style.background = "rgba(49,233,177,0.08)";
                            };
                            leftBtn.onmouseleave = function () {
                                this.style.color = "#eee";
                                this.style.background = "none";
                            };
                            itemDiv.appendChild(leftBtn);

                            const rightBtn = document.createElement('button');
                            rightBtn.innerHTML = "&#10095;"; // Unicode ❯
                            rightBtn.style.cssText = arrowBtnStyle + "right: 6px;";
                            rightBtn.onclick = (e) => {
                                e.stopPropagation();
                                previewIdx = (previewIdx + 1) % group.length;
                                imgEl.src = group[previewIdx];
                            };
                            rightBtn.onmouseenter = function () {
                                this.style.color = "#31e9b1";
                                //this.style.background = "rgba(49,233,177,0.08)";
                            };
                            rightBtn.onmouseleave = function () {
                                this.style.color = "#eee";
                                this.style.background = "none";
                            };
                            itemDiv.appendChild(rightBtn);
                        }

                        // In renderFlipBookLibrary(), update click handler:
                        itemDiv.onclick = () => {
                            const selectedImg = new Image();
                            selectedImg.onload = () => {
                                const st = {
                                    img: selectedImg,
                                    x: 0,
                                    y: 0,
                                    scale: 1.0,
                                    flipX: false,
                                    flipBookImages: group.map(src => {
                                        const im = new Image();
                                        im.src = src;
                                        return im;
                                    }),
                                    flipBookIndex: previewIdx,
                                    rotation: 0,
                                    domButton: null,
                                    domElement: null,
                                    mode: "edit"
                                };
                                stickers.push(st);
                                activeStickerIndex = stickers.length - 1;
                                createStickerDOM(st);
                                createModeButton(st);
                                clampStickerToCanvas(st, { center: true });
                                layoutModeButton(st, stickers.indexOf(st));
                                pushHistory();
                                drawCanvas();
                                setActionText("FlipBook sticker placed on canvas");
                            };
                            selectedImg.src = group[previewIdx];   // <-- Use currently selected
                        };



                        wrapper.appendChild(itemDiv);
                    });
                }

                // Up arrow => scroll up
                flipBookArrowUp.addEventListener("click", () => {
                    flipBookImagesWrapper.scrollBy({ top: -120, behavior: "smooth" });
                });

                // Down arrow => scroll down
                flipBookArrowDown.addEventListener("click", () => {
                    flipBookImagesWrapper.scrollBy({ top: 120, behavior: "smooth" });
                });

                // Close button
                closeFlipBookBtn.addEventListener("click", () => {
                    flipBookOverlay.style.display = "none";
                });

                // Example placeholders for the functions you’ll integrate
                function loadSubfolderImages(folderName) {
                    // Return all frames in that subfolder. Hard-coded or do a fetch from your server
                    // The user can cycle through these on the canvas
                    return [
                        `${API_BASE}/flipbook/${folderName}/02.png`,
                        `${API_BASE}/flipbook/${folderName}/04.png`,
                        `${API_BASE}/flipbook/${folderName}/10.png`,
                        `${API_BASE}/flipbook/${folderName}/14.png`,
                    ];
                }

                function addStickerToCanvas(previewPath, subfolderPaths = null) {
                    const newImg = new Image();
                    newImg.crossOrigin = "anonymous";
                    newImg.onload = () => {
                        // create brand-new sticker
                        const st = {
                            img: newImg,
                            x: 0,
                            y: 0,
                            scale: 1,
                            flipX: false,
                            flipBookImages: [newImg],
                            flipBookIndex: 0,
                            rotation: 0,
                            mode: "edit",      // default Edit mode
                            domButton: null,
                            domElement: null
                        };
                        stickers.push(st);
                        activeStickerIndex = stickers.length - 1;
                        createStickerDOM(st);
                        createModeButton(st);            // ← attaches the floating icon
                        clampStickerToCanvas(st, { center: true });
                        layoutModeButton(st, stickers.indexOf(st));
                        activeStickerIndex = stickers.length - 1;   // optional: auto-select
                        pushHistory();
                        drawCanvas();
                        trackRecentImport(newImg.src);
                        setActionText("Recent image added");

                        // Now that st is definitely in stickers[], attach the subfolder frames
                        if (subfolderPaths && subfolderPaths.length > 0) {
                            st.flipBookImages = []; // optional: clear out single
                            st.flipBookIndex = 0;
                            let loadedCount = 0;
                            subfolderPaths.forEach((p, idx) => {
                                const im = new Image();
                                im.crossOrigin = "anonymous";
                                im.onload = () => {
                                    loadedCount++;
                                    st.flipBookImages.push(im);
                                    if (idx === 0) {
                                        // optionally set st.img = first frame
                                        st.img = im;
                                        drawCanvas();
                                    }
                                    if (loadedCount === subfolderPaths.length) {
                                        setActionText("Loaded " + loadedCount + " images => cyle through with arrows");
                                    }
                                };
                                im.src = p;
                            });
                        }
                    };
                    newImg.src = previewPath;
                }

                function attachFlipBookArrayToSticker(imgPaths) {
                    const st = stickers[stickers.length - 1];
                    st.flipBookImages = [];
                    st.flipBookIndex = 0;

                    let loadedCount = 0;
                    imgPaths.forEach((p, idx) => {
                        const im = new Image();
                        im.onload = () => {
                            loadedCount++;
                            st.flipBookImages.push(im);
                            // Optionally if idx===0, st.img = im
                            if (loadedCount === imgPaths.length) {
                                setActionText(`Loaded ${loadedCount} images for subfolder => can cycle on-canvas!`);
                            }
                        };
                        im.src = p;
                    });
                }
                function populateRecentOverlay() {
                    recentImagesWrapper.innerHTML = '';
                    recentImports.forEach(src => {
                        const item = document.createElement('div');
                        item.className = 'flipBookItem';
                        const img = document.createElement('img');
                        img.className = 'flipBookImg';
                        img.src = src;
                        item.appendChild(img);
                        item.addEventListener('click', () => {
                            addStickerToCanvas(src);
                            recentOverlay.style.display = 'none';
                        });
                        recentImagesWrapper.appendChild(item);
                    });
                }


                /******************************************************
                * Assets Library
                ******************************************************/
                let assetsLibraryItems = [];
                let assetsLoaded = false;

                fgAssetBtn.addEventListener("click", async () => {
                    assetsOverlay.style.display = "block";

                    if (!assetsLoaded) {
                        assetsImagesWrapper.innerHTML = "";
                        assetsLibraryItems = [];

                        try {
                            const resp = await fetch(`${API_BASE}/assets-list`);
                            const files = await resp.json();               // ["x.png","y.webp",...]

                            files.forEach(fname => {
                                const fullPath = `${API_BASE}/assets/${fname}`;
                                if (fname.toLowerCase().endsWith('.glb') || fname.toLowerCase().endsWith('.gltf')) {
                                    assetsLibraryItems.push({ src: fullPath, type: 'model', name: fname });
                                } else {
                                    assetsLibraryItems.push({ src: fullPath, type: 'image', name: fname });
                                }
                            });

                            assetsLoaded = true;
                            setActionText(`Assets ⇒ ${files.length} items loaded`);
                        } catch (err) {
                            console.error("Assets ⇒", err);
                            setActionText("Assets ⇒ see console for error");
                        }
                    }

                    renderAssetsLibrary();
                });

                document.getElementById('assetsImportTop').onclick =
                    document.getElementById('assetsImportBottom').onclick = function () {
                        document.getElementById('fgAssetInput').click();
                    };

                document.getElementById('fgAssetInput').onchange = function (e) {
                    const files = Array.from(e.target.files);
                    if (!files.length) return;

                    let loadedCount = 0;
                    files.forEach(file => {
                        const ext = file.name.toLowerCase().split('.').pop();
                        if (ext === 'glb' || ext === 'gltf') {
                            const url = URL.createObjectURL(file);
                            assetsLibraryItems.push({ src: url, type: 'model', name: file.name });
                            loadedCount++;
                            if (loadedCount === files.length) {
                                renderAssetsLibrary();
                            }
                        } else {
                            const reader = new FileReader();
                            reader.onload = function (evt) {
                                assetsLibraryItems.push({ src: evt.target.result, type: 'image', name: file.name });
                                loadedCount++;
                                if (loadedCount === files.length) {
                                    renderAssetsLibrary();
                                }
                            };
                            reader.readAsDataURL(file);
                        }
                    });
                    e.target.value = "";
                };

                function renderAssetsLibrary() {
                    const assetsWrapper = document.getElementById('assetsImagesWrapper');
                    assetsWrapper.innerHTML = '';
                    assetsLibraryItems.forEach(item => {
                        const elem = document.createElement("div");
                        elem.className = "assetsItem";

                        if (item.type === 'image') {
                            const img = document.createElement("img");
                            img.className = "assetsImg";
                            img.crossOrigin = "anonymous";
                            img.src = item.src;
                            elem.appendChild(img);
                            elem.addEventListener("click", e => {
                                if (e.ctrlKey) {
                                    e.preventDefault();
                                    e.stopPropagation();
                                    if (typeof activeStickerIndex === "number" && activeStickerIndex !== -1) {
                                        const st = stickers[activeStickerIndex];
                                        const prevX = st.x;
                                        const prevY = st.y;
                                        const newImg = new Image();
                                        newImg.crossOrigin = "anonymous";
                                        newImg.onload = () => {
                                            st.img = newImg;
                                            st.mode = "edit";
                                            if (!st.domElement) createStickerDOM(st);
                                            if (!st.domFocus) createModeButton(st);
                                            st.x = prevX;
                                            st.y = prevY;
                                            st.domElement.src = newImg.src;
                                            layoutModeButton(st, stickers.indexOf(st));
                                            drawCanvas();
                                        };
                                        newImg.src = img.src;
                                        setActionText("FG sticker swapped in place");
                                    } else {
                                        setActionText("Select a sticker first.");
                                    }
                                } else {
                                    addStickerToCanvas(img.src);
                                }
                            });
                        } else if (item.type === 'model') {
                            const thumb = document.createElement("div");
                            thumb.className = "assetsModelThumb";

                            const nameSpan = document.createElement("span");
                            nameSpan.className = "assetsModelName";
                            nameSpan.textContent = item.name || "3D";
                            thumb.appendChild(nameSpan);

                            const icon = document.createElement("i");
                            icon.className = "fas fa-cube";
                            thumb.appendChild(icon);

                            if (item.name) thumb.title = item.name;
                            elem.appendChild(thumb);
                            elem.addEventListener("click", () => {
                                const wrapRect = document.getElementById('canvasWrapper').getBoundingClientRect();
                                const x = wrapRect.width / 2 - 80;
                                const y = wrapRect.height / 2 - 80;
                                loadGlb(item.src, x, y, 160);
                                setActionText("3-D model loaded");
                            });
                        }
                        assetsWrapper.appendChild(elem);
                    });
                }
                /* optional: keep panel scroll helpers */
                assetsArrowUp.addEventListener("click", () => assetsImagesWrapper.scrollBy({ top: -120, behavior: "smooth" }));
                assetsArrowDown.addEventListener("click", () => assetsImagesWrapper.scrollBy({ top: 120, behavior: "smooth" }));
                closeAssetsBtn.addEventListener("click", () => assetsOverlay.style.display = "none");

                recentArrowUp.addEventListener('click', () => recentImagesWrapper.scrollBy({ top: -120, behavior: 'smooth' }));
                recentArrowDown.addEventListener('click', () => recentImagesWrapper.scrollBy({ top: 120, behavior: 'smooth' }));
                closeRecentBtn.addEventListener('click', () => recentOverlay.style.display = 'none');

                /******************************************************
                * SETTINGS => Show/hide
                ******************************************************/
                settingsBtn.addEventListener("click", () => {
                    settingsOverlay.style.display = "flex";
                    setActionText("Opened Settings dialog");
                });
                settingsOverlay.addEventListener("click", e => {
                    if (e.target === settingsOverlay) {
                        settingsOverlay.style.display = "none";
                        setActionText("Closed Settings (outside click)");
                    }
                });
                closeSettingsBtn.addEventListener("click", () => {
                    settingsOverlay.style.display = "none";
                    setActionText("Closed Settings dialog");
                });
                cancelSettingsBtn.addEventListener("click", () => {
                    settingsOverlay.style.display = "none";
                    setActionText("Cancelled Settings changes");
                });

                /******************************************************
                 * Restore Defaults
                 ******************************************************/
                restoreDefaultsBtn.addEventListener("click", () => {
                    samModelSelect.value = "vit_l";
                    imgGenModelSelect.value = "stable";
                    imgGenStrength.value = "0.2";
                    imgGenGuidance.value = "7";
                    imgGenSteps.value = "30";
                    strengthValueLabel.textContent = "0.2";
                    guidanceValueLabel.textContent = "7";
                    stepsValueLabel.textContent = "30";

                    txt2ImgModelSelect.value = "flux_schnell";
                    txt2ImgResolution.value = "512x512";
                    txt2ImgGuidance.value = "5";
                    txt2ImgSteps.value = "2";
                    txt2ImgGuidanceVal.textContent = "5";
                    txt2ImgStepsVal.textContent = "2";

                    enhanceStrengthSlider.value = "0.8";
                    enhanceStrengthLabel.textContent = "0.8";

                    objRemovalPrompt.value = "";
                    objRemovalStrength.value = "1.0";
                    objRemovalGuidance.value = "20";
                    objRemovalSteps.value = "30";
                    objRemovalStrengthVal.textContent = "1.0";
                    objRemovalGuidanceVal.textContent = "20";
                    objRemovalStepsVal.textContent = "30";

                    //threedModelSelect.value = "mini";
                    //captionModelSelect.value = "blip2";

                    setActionText("All settings restored to default");
                });
                saveSettingsBtn.addEventListener("click", () => {
                    settingsOverlay.style.display = "none";
                    setActionText("Saved Settings");
                });

                /******************************************************
                 * GPU => CPU => toggling
                 ******************************************************/
                gpuBtn.addEventListener("click", () => {
                    isGpuMode = !isGpuMode;
                    if (isGpuMode) {
                        gpuBtn.classList.remove("cpuMode");
                        setActionText("Switched to GPU Mode");
                    } else {
                        gpuBtn.classList.add("cpuMode");
                        setActionText("Switched to CPU Mode");
                    }
                });

                /******************************************************
                 * Purge => /purge-cache
                 ******************************************************/
                purgeCacheBtn.addEventListener("click", async () => {
                    try {
                        const resp = await fetch(`${API_BASE}/purge-cache`, {
                            method: "POST"
                        });
                        const data = await resp.json();
                        if (data.error) {
                            setActionText("Purge error => " + data.error);
                        } else {
                            setActionText("Cache => " + data.message);
                        }
                    } catch (err) {
                        console.error("Purge =>", err);
                        setActionText("Purge => error => see console");
                    }
                });
                /******************************************************
                * Cancel Model / Process
                ******************************************************/
                document.getElementById("cancelModelBtn").onclick = async function () {
                    setActionText("Canceling process…");
                    await fetch(`${API_BASE}/cancel-model`, { method: "POST" });
                    hideCancelBtn();
                };

                /******************************************************
                * LockSeed
                ******************************************************/
                const lockSeedCheckbox = document.getElementById("lockSeedCheckbox");
                const seedInput = document.getElementById("seedInput");
                const lockSeedCheckboxD2i = document.getElementById("lockSeedCheckboxD2i");
                const seedInputD2i = document.getElementById("seedInputD2i");

                lockSeedCheckbox.checked = false; // unlock by default
                seedInput.disabled = false;       // let them see / edit if they want

                lockSeedCheckbox.addEventListener("change", () => {
                    if (lockSeedCheckbox.checked) {
                        // “Locked” => freeze whatever number is in there, disable the field
                        seedInput.disabled = true;
                        setActionText("Seed locked at: " + seedInput.value);
                    } else {
                        // “Unlocked” => re-enable, so next generation calls will randomize or let them type
                        seedInput.disabled = false;
                        setActionText("Seed unlocked => will randomize on each generation");
                    }
                });

                // 3) For each generation call:
                function getActiveSeed() {
                    if (lockSeedCheckbox.checked) {
                        // If locked, always use what’s in the box
                        return parseInt(seedInput.value, 10) || 0;
                    } else {
                        // If unlocked, generate a new random each time
                        const rand = Math.floor(Math.random() * 99999999);
                        seedInput.value = rand;
                        return rand;
                    }
                }

                lockSeedCheckboxD2i.addEventListener("change", () => {
                    if (lockSeedCheckboxD2i.checked) {
                        seedInputD2i.disabled = true;
                        setActionText("Depth2Img => seed locked at: " + seedInputD2i.value);
                    } else {
                        seedInputD2i.disabled = false;
                        setActionText("Depth2Img => unlocked => random each time");
                    }
                });

                // Then a function that picks a seed for Depth2Img
                function getActiveSeedD2i() {
                    if (lockSeedCheckboxD2i.checked) {
                        return parseInt(seedInputD2i.value, 10) || 0;
                    } else {
                        // pick random
                        const rand = Math.floor(Math.random() * 99999999);
                        seedInputD2i.value = rand;
                        return rand;
                    }
                }

                /* ———————————————————————————— spinner helpers ———————————————————————————— */
                function showGlobalSpinner() {
                    const ov = canvasSpinnerOverlay;                 // short alias
                    ov.dataset.origParent = ov.parentElement.id || ""; // remember home
                    document.body.appendChild(ov);                     // lift out of hidden canvas
                    Object.assign(ov.style, {
                        position: "fixed",
                        inset: "0",
                        top: "50%",
                        left: "50%",
                        transform: "translate(-50%,-50%)",
                        background: "rgba(0,0,0,0.4)",
                        width: "100vw",        // full width
                        height: "100vh",         // full height
                        display: "flex"
                    });
                }

                function hideGlobalSpinner() {
                    const ov = canvasSpinnerOverlay;
                    ov.style.display = "none";

                    /* snap overlay back to its original wrapper */
                    const home = ov.dataset.origParent && document.getElementById(ov.dataset.origParent);
                    if (home) home.appendChild(ov);

                    ov.removeAttribute("style");          // restore default CSS
                    delete ov.dataset.origParent;
                }

                /* ---------- HOME  Generate ---------- */
                homeGenerateBtn.onclick = function () {
                    const promptTxt = document.getElementById("homePromptInput").value.trim();
                    if (!userLoadedBg) {
                        runFluxText2Img(promptTxt);
                        return;
                    }
                    const modelChoice = document.getElementById("homePromptModelSelect").value;
                    runStableDiffusionFlow(modelChoice, promptTxt);
                };

                /* ---------- KONTEXT  Generate ---------- */
                // ——— Global Kontext Seed (shared by Lighting + Time-of-Day) ———
                const KON_SEED_KEY = 'kontextSeed';

                function ensureOption(select, seed) {
                    if (!select || !seed) return;
                    const val = String(seed);
                    const exists = Array.from(select.options).some(o => o.value === val);
                    if (!exists) {
                        const opt = document.createElement('option');
                        opt.value = val;
                        opt.textContent = val;
                        select.add(opt);
                    }
                }

                function syncSeedUI(seed) {
                    const s = String(seed || '');
                    const fluxSeedSelect = document.getElementById('fluxSeedSelect');
                    const todSeedSelect = document.getElementById('todSeedSelect');
                    const stylizeSeedSelect = document.getElementById('stylizeSeedSelect');

                    [fluxSeedSelect, todSeedSelect, stylizeSeedSelect].forEach(sel => {
                        if (sel && s) { ensureOption(sel, s); sel.value = s; }
                    });
                }

                function getKonSeed() {
                    return localStorage.getItem(KON_SEED_KEY) || '';
                }

                function setKonSeed(seed) {
                    if (!seed && seed !== 0) return;
                    const s = String(seed);
                    localStorage.setItem(KON_SEED_KEY, s);
                    syncSeedUI(s);
                }

                function chooseCompositeBG() {
                    const beforeImg = getBeforeImage();
                    // Use locked "Before" image if set; otherwise fall back to the original snapshot.
                    return beforeImg || backgroundImage;
                }

                // On load, reflect any saved seed into both HUDs
                document.addEventListener('DOMContentLoaded', () => {
                    const s = getKonSeed();
                    if (s) syncSeedUI(s);
                });

                function initKontextToggleGroup(section) {
                    const state = { align: false, depth: false, fullRes: false };
                    if (!section) {
                        return state;
                    }
                    const buttons = section.querySelectorAll('.kontextToggleBtn');
                    const updateButton = (btn, isOn) => {
                        btn.classList.toggle('is-on', isOn);
                        btn.setAttribute('aria-pressed', String(isOn));
                        btn.setAttribute('data-state', isOn ? 'on' : 'off');
                    };
                    buttons.forEach(btn => {
                        const key = btn.dataset.setting;
                        if (!key) return;
                        const applyState = on => {
                            state[key] = !!on;
                            updateButton(btn, state[key]);
                        };
                        applyState(btn.dataset.default === 'on');
                        const toggle = () => applyState(!state[key]);
                        btn.addEventListener('click', toggle);
                        btn.addEventListener('keydown', evt => {
                            if (evt.key === ' ' || evt.key === 'Enter') {
                                evt.preventDefault();
                                toggle();
                            }
                        });
                    });
                    return state;
                }

                // Lighting HUD param controls
                const fluxPromptInput = document.getElementById("fluxPromptInput");
                const fluxGuidance = document.getElementById("fluxGuidance");
                const fluxGuidanceVal = document.getElementById("fluxGuidanceVal");
                const fluxSteps = document.getElementById("fluxSteps");
                const fluxStepsVal = document.getElementById("fluxStepsVal");
                const fluxSeedLock = document.getElementById("fluxSeedLock");
                const fluxSeedSelect = document.getElementById("fluxSeedSelect");
                const runFluxKontextBtn = document.getElementById("runFluxKontextBtn");

                const STYLE_PRESETS = {
                    photo: "a realistic photograph",
                    //photo: "a realistic photograph, harmonize lighting with the scene, preserve camera and composition, no geometry changes",
                    painterly: "a high quality animation styled image with harmonized lighting",
                    //painterly: "a painterly style of artwork, harmonize lighting with the scene, preserve camera and composition",
                    cinematic: "a realistic cinematic photograph",
                    hyperreal: "an exceptional quality, high fidelity, and hyper-realistic image"
                    //hyperreal: "an exceptional quality, high fidelity, and hyper-realistic image, harmonize lighting with the scene, preserve camera and composition"
                };

                const lightingHud = document.getElementById("workflowLightingHUD");
                const lightingStyleDisplay = document.getElementById("lightingStyleDisplay");
                const lightingStyleButtons = document.querySelectorAll(".styleIconButton");
                const lightingToggleState = initKontextToggleGroup(document.getElementById('lightingKontextToggles'));

                function setLightingStyle(key) {
                    if (lightingHud) lightingHud.dataset.style = key;
                    if (lightingStyleDisplay) lightingStyleDisplay.textContent = STYLE_PRESETS[key] || "";
                }

                lightingStyleButtons.forEach(btn => {
                    btn.addEventListener("click", () => {
                        lightingStyleButtons.forEach(b => { b.classList.remove("active"); b.setAttribute("aria-pressed", "false"); });
                        btn.classList.add("active");
                        btn.setAttribute("aria-pressed", "true");
                        setLightingStyle(btn.dataset.style);
                    });
                });

                // default: "a realistic photograph"
                setLightingStyle("photo");

                document.querySelectorAll('#workflowLightingHUD .hudSectionHeader').forEach(header => {
                    header.style.cursor = 'pointer';
                    header.addEventListener('click', () => {
                        const body = header.nextElementSibling;
                        if (!body) return;
                        body.classList.toggle('collapsed');
                        header.classList.toggle('active');
                    });
                });

                fluxGuidance.addEventListener("input", () => {
                    fluxGuidanceVal.textContent = fluxGuidance.value;
                });
                fluxSteps.addEventListener("input", () => {
                    fluxStepsVal.textContent = fluxSteps.value;
                });
                if (fluxSeedLock && fluxSeedSelect) {
                    fluxSeedLock.addEventListener('click', () => {
                        const locked = fluxSeedLock.classList.toggle('locked');
                        fluxSeedLock.setAttribute('aria-pressed', String(locked));
                        fluxSeedLock.textContent = locked ? '🔒' : '🔓';
                        if (locked && (fluxSeedSelect.value === 'random' || !fluxSeedSelect.value)) {
                            const newSeed = String(Math.floor(Math.random() * 1e9));
                            const opt = document.createElement('option');
                            opt.value = newSeed;
                            opt.textContent = newSeed;
                            fluxSeedSelect.add(opt);
                            fluxSeedSelect.value = newSeed;
                        }
                    });
                }

                // POST handler for FLUX Lighting
                runFluxKontextBtn.onclick = async function () {
                    setActionText("Lumify Composite: Generating...");
                    runFluxKontextBtn.classList.add("seafoam30Active", "processing");

                    // Snapshot current canvas for Before/After unless a view is locked
                    if (beforeLockIndex === -1 && currentOutIndex === -1) {
                        liveBGImage = backgroundImage;
                        liveFGStickers = stickers.map(cloneSticker);
                    }

                    // Compose the canvas+stickers as the input for FLUX
                    const styleKey = lightingHud?.dataset?.style || "photo";
                    const stylePhrase = STYLE_PRESETS[styleKey] || "";
                    const userText = (fluxPromptInput.value || "").trim();
                    //const finalPrompt = [stylePhrase, userText].filter(Boolean).join(", ");
                    //const RELIGHT_CORE = "relight scene, match light direction, add contact shadows, maintain original camera framing, composition, perspective, and exact camera focal length";
                    //const finalPrompt = [stylePhrase, RELIGHT_CORE, userText].filter(Boolean).join(", ");
                    const finalPrompt = [stylePhrase, userText].filter(Boolean).join(", ");

                    const offC = await buildCompositeForBackend();
                    const composite_b64 = offC.toDataURL("image/png");
                    //const maskC = await buildFgMaskForBackend();
                    const focus_mask_b64 = buildUnionStickerMaskPNG(offC.width, offC.height);

                    // Choose a seed (random if not locked)
                    // ——— Lighting: choose/record seed ———
                    let seed = getKonSeed();
                    const locked = fluxSeedLock?.classList.contains('locked');

                    if (locked) {
                        // Use the selected value if present, otherwise fall back to global or random
                        const sel = (fluxSeedSelect?.value || '').trim();
                        if (sel && sel !== 'random') {
                            seed = sel;
                        }
                        if (!seed) seed = String(Math.floor(Math.random() * 1e9));
                        // Mirror to UI and persist
                        ensureOption(fluxSeedSelect, seed);
                        fluxSeedSelect.value = seed;
                    } else {
                        // Unlocked: always pick a fresh random seed
                        seed = String(Math.floor(Math.random() * 1e9));
                        if (fluxSeedSelect) fluxSeedSelect.value = 'random';
                    }

                    // Persist globally so ToD can reuse it without copy/paste
                    setKonSeed(seed);


                    // Compose POST body
                    const payload = {
                        //prompt: fluxPromptInput.value || "",
                        prompt: finalPrompt,
                        steps: parseInt(fluxSteps.value, 10),
                        guidance: parseFloat(fluxGuidance.value),
                        seed: parseInt(seed, 10),
                        composite_b64,
                        width: offC.width,
                        height: offC.height,
                        workflow: "lighting",
                        align: !!lightingToggleState.align,
                        full_res: !!lightingToggleState.fullRes,
                        use_depth: !!lightingToggleState.depth
                        //focus_mask_b64,
                    };

                    // Show a spinner/progress
                    showCancelBtn();
                    fakeProcessBar(9000);

                    try {
                        const res = await fetch(`/flux-kontext`, {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify(payload)
                        });
                        const result = await res.json();

                        stopFakeProcessBar();
                        hideCancelBtn();

                        if (result.seed_used) {
                            setKonSeed(result.seed_used);
                        }

                        if (result.image) {
                            const img = new Image();
                            img.src = result.image;
                            img.onload = () => {
                                backgroundImage = img;
                                const info = `Prompt: ${payload.prompt || ''}\nSteps: ${payload.steps}\nGuidance: ${payload.guidance}\nSeed: ${seed}`;
                                sessionOutputs.push({ img, model: 'Lumify', info });
                                currentOutIndex = sessionOutputs.length - 1;
                                isOverlayVisible = false;
                                resetBeforeAfterState();
                                updateFgStickerVisibility();
                                updateFgToggleBtnVisual();
                                computeBgLayout(img);
                                drawCanvas();
                                updateHistoryThumbs();
                                updateLiveSnapshotIfCurrent();
                                setActionText("Kontext Lighting generated ✔");
                            };
                        } else {
                            setActionText("Kontext Error: " + (result.error || "Unknown error"));
                        }
                    } catch (e) {
                        stopFakeProcessBar();
                        hideCancelBtn();
                        setActionText("Flux Kontext failed: " + e.message);
                    } finally {
                        runFluxKontextBtn.classList.remove("seafoam30Active", "processing");
                    }
                };

                // POST handler for FLUX Camera

                (function () {
                    document.addEventListener('DOMContentLoaded', () => {
                        const hud = document.getElementById('workflowCameraHUD');
                        if (!hud) return; // camera HUD not on this page

                        // --- helpers from your app (defensive guards keep this drop-in safe)
                        const API_BASE = window.API_BASE || "";
                        const setActionText = window.setActionText || function () { };
                        const showCancelBtn = window.showCancelBtn || function () { };
                        const hideCancelBtn = window.hideCancelBtn || function () { };
                        const fakeProcessBar = window.fakeProcessBar || function () { };
                        const stopFakeProcessBar = window.stopFakeProcessBar || function () { };
                        const buildCompositeForBackend = window.buildCompositeForBackend || null;
                        const ensureOption = window.ensureOption || function (sel, seed) {
                            if (!sel) return;
                            const s = String(seed);
                            if ([...sel.options].some(o => o.value === s)) return;
                            const opt = document.createElement('option'); opt.value = s; opt.textContent = s; sel.add(opt);
                        };
                        const getKonSeed = window.getKonSeed || function () { return "" };
                        const setKonSeed = window.setKonSeed || function () { };

                        // --- UI elements inside #workflowCameraHUD
                        const useDegreesEl = hud.querySelector('#camUseDegrees');
                        const fovTweakEl = hud.querySelector('#camFovTweak');
                        const subjectLockEl = hud.querySelector('#camSubjectLock');

                        const advHeader = hud.querySelector('#cameraAdvHeader');
                        const advBody = hud.querySelector('#cameraAdvBody');
                        const advPrompt = hud.querySelector('#cameraAdvPrompt');
                        const guidance = hud.querySelector('#cameraGuidance');
                        const guidanceVal = hud.querySelector('#cameraGuidanceVal');
                        const steps = hud.querySelector('#cameraSteps');
                        const stepsVal = hud.querySelector('#cameraStepsVal');
                        const seedLock = hud.querySelector('#cameraSeedLock');
                        const seedSelect = hud.querySelector('#cameraSeedSelect');

                        const actionLabelWrap = hud.querySelector('#cameraActionLabel');
                        const actionPrimary = hud.querySelector('#camActionPrimary') || actionLabelWrap;
                        const actionSecondary = hud.querySelector('#camActionSecondary');
                        const selectionMove = hud.querySelector('#camSelectedMove');
                        const selectionValue = hud.querySelector('#camSelectedValue');
                        const sliderWrap = hud.querySelector('#camValueControl');
                        const sliderLabelEl = hud.querySelector('#camSliderLabel');
                        const sliderBody = hud.querySelector('#camSliderBody');
                        const useDeg = useDegreesEl;
                        const fovTweak = fovTweakEl;

                        const runBtn = hud.querySelector('#runCameraKontextBtn');

                        // Reflect slider readouts
                        if (guidance && guidanceVal) guidance.addEventListener('input', () => guidanceVal.textContent = guidance.value);
                        if (steps && stepsVal) steps.addEventListener('input', () => stepsVal.textContent = steps.value);

                        // Seed lock behavior (matches Lighting HUD)
                        if (seedLock) {
                            seedLock.addEventListener('click', () => {
                                const lockedNow = seedLock.classList.toggle('locked');
                                seedLock.setAttribute('aria-pressed', String(lockedNow));
                                seedLock.textContent = lockedNow ? '🔒' : '🔓';
                                if (lockedNow && seedSelect && (!seedSelect.value || seedSelect.value === 'random')) {
                                    const newSeed = String(Math.floor(Math.random() * 1e9));
                                    ensureOption(seedSelect, newSeed);
                                    seedSelect.value = newSeed;
                                }
                            });
                        }

                        hud.querySelectorAll('.hudSectionHeader').forEach(header => {
                            if (header.textContent.trim().toLowerCase().startsWith('advanced prompt')) {
                                const body = header.nextElementSibling;
                                if (body) body.classList.add('collapsed'); // default collapsed
                                header.style.cursor = 'pointer';
                                header.addEventListener('click', () => {
                                    if (!body) return;
                                    body.classList.toggle('collapsed');
                                    header.classList.toggle('active');
                                });
                            }
                        });

                        const ACTIONS = {
                            tilt_up: {
                                label: 'Tilt Up',
                                kind: 'deg',
                                degRange: { min: -360, max: 360, step: 1, def: 10 },
                                intensityRange: { min: 0, max: 100, step: 1, def: 30 }
                            },
                            tilt_down: {
                                label: 'Tilt Down',
                                kind: 'deg',
                                degRange: { min: -360, max: 360, step: 1, def: 10 },
                                intensityRange: { min: 0, max: 100, step: 1, def: 30 }
                            },
                            pan_left: {
                                label: 'Pan Left',
                                kind: 'deg',
                                degRange: { min: -360, max: 360, step: 1, def: 10 },
                                intensityRange: { min: 0, max: 100, step: 1, def: 30 }
                            },
                            pan_right: {
                                label: 'Pan Right',
                                kind: 'deg',
                                degRange: { min: -360, max: 360, step: 1, def: 10 },
                                intensityRange: { min: 0, max: 100, step: 1, def: 30 }
                            },
                            roll_left: {
                                label: 'Roll Left',
                                kind: 'deg',
                                degRange: { min: -360, max: 360, step: 1, def: 8 },
                                intensityRange: { min: 0, max: 100, step: 1, def: 30 }
                            },
                            roll_right: {
                                label: 'Roll Right',
                                kind: 'deg',
                                degRange: { min: -360, max: 360, step: 1, def: 8 },
                                intensityRange: { min: 0, max: 100, step: 1, def: 30 }
                            },
                            zoom_in: { label: 'Zoom In', kind: 'pct', min: 0, max: 100, step: 1, def: 30 },
                            zoom_out: { label: 'Zoom Out', kind: 'pct', min: 0, max: 100, step: 1, def: 30 },
                            recenter: { label: 'Recenter', kind: 'none' }
                        };

                        const OPPOSITE_ACTIONS = {
                            tilt_up: 'tilt_down',
                            tilt_down: 'tilt_up',
                            pan_left: 'pan_right',
                            pan_right: 'pan_left',
                            roll_left: 'roll_right',
                            roll_right: 'roll_left',
                            zoom_in: 'zoom_out',
                            zoom_out: 'zoom_in',
                            dolly_in: 'dolly_out',
                            dolly_out: 'dolly_in',
                            truck_left: 'truck_right',
                            truck_right: 'truck_left',
                            crane_up: 'crane_down',
                            crane_down: 'crane_up',
                            orbit_left: 'orbit_right',
                            orbit_right: 'orbit_left'
                        };

                        const EXCLUSIVE_GROUPS = [
                            ['tilt_up', 'tilt_down'],
                            ['pan_left', 'pan_right'],
                            ['roll_left', 'roll_right'],
                            ['zoom_in', 'zoom_out'],
                            ['dolly_in', 'dolly_out'],
                            ['truck_left', 'truck_right'],
                            ['crane_up', 'crane_down'],
                            ['orbit_left', 'orbit_right']
                        ];

                        const state = {
                            activeAction: null,
                            selections: new Map()
                        };

                        const buttonByAction = new Map();
                        const conflictTimers = new WeakMap();

                        function toTitleCase(str = '') {
                            return str.replace(/[_-]+/g, ' ').replace(/\b\w/g, ch => ch.toUpperCase());
                        }

                        function labelForAction(key) {
                            if (!key) return 'Choose a camera move';
                            return ACTIONS[key]?.label || toTitleCase(key);
                        }

                        function sliderLabelText(meta, usingDegrees) {
                            if (!meta) return 'Value';
                            if (meta.kind === 'deg') {
                                return usingDegrees ? 'Degrees' : 'Intensity';
                            }
                            if (meta.kind === 'pct') {
                                return 'Intensity';
                            }
                            if (meta.kind === 'none') {
                                return 'Value';
                            }
                            return 'Amount';
                        }

                        function messageForMeta(action, meta, usingDegrees) {
                            if (!action) {
                                return 'Pick a control on the pad to reveal its settings.';
                            }
                            if (!meta || meta.kind === 'none') {
                                return action === 'recenter'
                                    ? 'Recenter the subject. No extra settings.'
                                    : 'This control does not expose an adjustable parameter.';
                            }
                            const labelText = sliderLabelText(meta, usingDegrees).toLowerCase();
                            let message = `Use the slider to adjust the ${labelText}.`;
                            const isZoom = action === 'zoom_in' || action === 'zoom_out';
                            if (isZoom && fovTweak && !fovTweak.checked) {
                                message += ' Tip: enable “FOV Tweak” for a more pronounced zoom effect.';
                            }
                            return message;
                        }

                        function setActionMessages(primaryText, secondaryText) {
                            const primary = primaryText || 'Choose a camera move';
                            if (actionPrimary) actionPrimary.textContent = primary;
                            if (actionSecondary) {
                                if (secondaryText) {
                                    actionSecondary.textContent = secondaryText;
                                    actionSecondary.style.display = '';
                                } else {
                                    actionSecondary.textContent = '';
                                    actionSecondary.style.display = 'none';
                                }
                            }
                        }

                        function resetSlider(labelText, valueText, isEmpty) {
                            if (sliderBody) sliderBody.innerHTML = '';
                            if (sliderLabelEl) sliderLabelEl.textContent = labelText || 'Value';
                            if (selectionValue) selectionValue.textContent = valueText || '—';
                            if (sliderWrap) sliderWrap.classList.toggle('is-empty', !!isEmpty);
                        }

                        function formatValue(meta, value, usingDegrees) {
                            const numeric = Number(value);
                            if (!Number.isFinite(numeric)) return String(value);
                            if (!meta || meta.kind === 'none') return '—';
                            if (meta.kind === 'deg') {
                                if (usingDegrees) {
                                    return `${numeric}°`;
                                }
                                return `${Math.abs(numeric)}%`;
                            }
                            if (meta.kind === 'pct') {
                                return `${numeric}%`;
                            }
                            return `${numeric}`;
                        }

                        function sliderRangeFor(meta, usingDegrees) {
                            if (!meta || meta.kind === 'none') return null;

                            const clampRange = (range, fallback) => {
                                const base = { ...fallback, ...(range || {}) };
                                const min = Number.isFinite(base.min) ? base.min : fallback.min;
                                const max = Number.isFinite(base.max) ? base.max : fallback.max;
                                const step = Number.isFinite(base.step) && base.step > 0 ? base.step : fallback.step;
                                let def = Number.isFinite(base.def) ? base.def : fallback.def;
                                if (def < min) def = min;
                                if (def > max) def = max;
                                return { min, max, step, def };
                            };

                            if (meta.kind === 'deg') {
                                if (usingDegrees) {
                                    return clampRange(meta.degRange, { min: -360, max: 360, step: 1, def: 10 });
                                }
                                return clampRange(meta.intensityRange, { min: 0, max: 100, step: 1, def: 30 });
                            }

                            return clampRange(meta, { min: 0, max: 100, step: 1, def: 30 });
                        }

                        function clampToRange(value, range) {
                            if (!range) return Number(value) || 0;
                            const numeric = Number(value);
                            if (!Number.isFinite(numeric)) return range.def;
                            if (numeric < range.min) return range.min;
                            if (numeric > range.max) return range.max;
                            return numeric;
                        }

                        function ensureSelectionEntry(action, meta) {
                            let entry = state.selections.get(action);
                            if (!entry) {
                                entry = { meta: meta || null, values: {} };
                                state.selections.set(action, entry);
                            } else if (!entry.values) {
                                entry.values = {};
                            }

                            if (!meta) return entry;

                            if (meta.kind === 'deg') {
                                if (!Number.isFinite(entry.values.deg)) {
                                    const degDefaults = sliderRangeFor(meta, true);
                                    entry.values.deg = degDefaults ? degDefaults.def : 10;
                                }
                                if (!Number.isFinite(entry.values.intensity)) {
                                    const intDefaults = sliderRangeFor(meta, false);
                                    entry.values.intensity = intDefaults ? intDefaults.def : 30;
                                }
                            } else if (meta.kind === 'pct') {
                                if (!Number.isFinite(entry.values.pct)) {
                                    const pctDefaults = sliderRangeFor(meta, false);
                                    entry.values.pct = pctDefaults ? pctDefaults.def : (meta.def ?? 30);
                                }
                            } else if (meta.kind !== 'none') {
                                if (!Number.isFinite(entry.values.value)) {
                                    const defaults = sliderRangeFor(meta, false);
                                    entry.values.value = defaults ? defaults.def : 0;
                                }
                            }

                            return entry;
                        }

                        function getStoredValue(action, meta, usingDegrees, sliderRange) {
                            const entry = state.selections.get(action);
                            if (!entry || !meta) return sliderRange?.def ?? 0;
                            if (meta.kind === 'deg') {
                                const key = usingDegrees ? 'deg' : 'intensity';
                                const val = entry.values?.[key];
                                return Number.isFinite(val) ? val : sliderRange?.def ?? 0;
                            }
                            if (meta.kind === 'pct') {
                                const val = entry.values?.pct;
                                return Number.isFinite(val) ? val : sliderRange?.def ?? 0;
                            }
                            if (meta.kind === 'none') return 0;
                            const val = entry.values?.value;
                            return Number.isFinite(val) ? val : sliderRange?.def ?? 0;
                        }

                        function setStoredValue(action, meta, usingDegrees, value) {
                            const entry = state.selections.get(action);
                            if (!entry || !meta) return;
                            if (!entry.values) entry.values = {};
                            if (meta.kind === 'deg') {
                                const key = usingDegrees ? 'deg' : 'intensity';
                                entry.values[key] = Number(value);
                            } else if (meta.kind === 'pct') {
                                entry.values.pct = Number(value);
                            } else if (meta.kind !== 'none') {
                                entry.values.value = Number(value);
                            }
                        }

                        function updateButtonStates() {
                            buttonByAction.forEach((btn, action) => {
                                const isSelected = state.selections.has(action);
                                const isActive = isSelected && action === state.activeAction;
                                btn.classList.toggle('selected', isSelected);
                                btn.classList.toggle('active', isActive);
                                btn.setAttribute('aria-pressed', isSelected ? 'true' : 'false');
                            });
                        }

                        function joinLabels(labels) {
                            if (!labels.length) return '';
                            if (labels.length === 1) return labels[0];
                            if (labels.length === 2) return `${labels[0]} and ${labels[1]}`;
                            return `${labels.slice(0, -1).join(', ')}, and ${labels[labels.length - 1]}`;
                        }

                        function updateSelectionSummary() {
                            if (!selectionMove) return;
                            if (!state.selections.size) {
                                selectionMove.textContent = 'Choose a camera move';
                                return;
                            }
                            const labels = Array.from(state.selections.keys()).map(labelForAction);
                            if (labels.length === 1) {
                                selectionMove.textContent = `Selected: ${labels[0]}`;
                            } else {
                                selectionMove.textContent = `Selected (${labels.length}): ${joinLabels(labels)}`;
                            }
                        }

                        function renderReveal(action) {
                            if (!action || !state.selections.has(action)) {
                                resetSlider('Value', '—', true);
                                setActionMessages('Choose a camera move', 'Pick a control on the pad to reveal its settings.');
                                return;
                            }

                            const meta = ACTIONS[action];
                            const usingDegrees = !!(useDeg && useDeg.checked);
                            const others = Array.from(state.selections.keys()).filter(a => a !== action);
                            let secondary = messageForMeta(action, meta, usingDegrees);
                            if (others.length) {
                                secondary += ` Also queued: ${joinLabels(others.map(labelForAction))}.`;
                            }
                            setActionMessages(labelForAction(action), secondary);

                            if (!sliderWrap || !sliderBody || !selectionValue) {
                                return;
                            }

                            if (!meta || meta.kind === 'none') {
                                resetSlider('Value', '—', true);
                                return;
                            }

                            const sliderRange = sliderRangeFor(meta, usingDegrees);
                            if (!sliderRange) {
                                resetSlider('Value', '—', true);
                                return;
                            }

                            ensureSelectionEntry(action, meta);
                            const currentValue = clampToRange(getStoredValue(action, meta, usingDegrees, sliderRange), sliderRange);
                            setStoredValue(action, meta, usingDegrees, currentValue);

                            const labelText = sliderLabelText(meta, usingDegrees);
                            resetSlider(labelText, formatValue(meta, currentValue, usingDegrees), false);

                            const slider = document.createElement('input');
                            slider.type = 'range';
                            slider.className = 'stealthSlider camHUD-valueSlider';
                            slider.min = sliderRange.min;
                            slider.max = sliderRange.max;
                            slider.step = sliderRange.step;
                            slider.value = currentValue;

                            sliderBody.appendChild(slider);

                            slider.addEventListener('input', () => {
                                const numeric = Number(slider.value);
                                const modeDegrees = !!(useDeg && useDeg.checked);
                                setStoredValue(action, meta, modeDegrees, numeric);
                                if (selectionValue) selectionValue.textContent = formatValue(meta, numeric, modeDegrees);
                            });
                        }

                        function findConflict(action) {
                            for (const group of EXCLUSIVE_GROUPS) {
                                if (group.includes(action)) {
                                    for (const other of group) {
                                        if (other !== action && state.selections.has(other)) {
                                            return other;
                                        }
                                    }
                                }
                            }
                            return null;
                        }

                        function flashConflict(btn) {
                            if (!btn) return;
                            btn.classList.add('conflict');
                            if (conflictTimers.has(btn)) clearTimeout(conflictTimers.get(btn));
                            const timer = setTimeout(() => {
                                btn.classList.remove('conflict');
                                conflictTimers.delete(btn);
                            }, 400);
                            conflictTimers.set(btn, timer);
                        }

                        function setActiveAction(action) {
                            state.activeAction = action || null;
                            updateButtonStates();
                            updateSelectionSummary();
                            if (action) {
                                renderReveal(action);
                            } else {
                                resetSlider('Value', '—', true);
                                setActionMessages('Choose a camera move', 'Pick a control on the pad to reveal its settings.');
                            }
                        }

                        function handlePadSelection(action) {
                            const btn = buttonByAction.get(action);
                            if (!btn) return;
                            const meta = ACTIONS[action];
                            const isSelected = state.selections.has(action);

                            if (isSelected) {
                                state.selections.delete(action);
                                const next = state.activeAction === action
                                    ? (Array.from(state.selections.keys()).pop() || null)
                                    : state.activeAction;
                                setActiveAction(next);
                                return;
                            }

                            const conflict = findConflict(action);
                            if (conflict) {
                                flashConflict(btn);
                                const conflictBtn = buttonByAction.get(conflict);
                                if (conflictBtn) flashConflict(conflictBtn);
                                const attemptedLabel = labelForAction(action);
                                const conflictLabel = labelForAction(conflict);
                                setActionMessages('Conflicting camera moves', `Cannot combine ${attemptedLabel} with ${conflictLabel}.`);
                                return;
                            }

                            const entry = ensureSelectionEntry(action, meta);
                            state.selections.set(action, entry);
                            setActiveAction(action);
                        }

                        resetSlider('Value', '—', true);
                        setActionMessages('Choose a camera move', 'Pick a control on the pad to reveal its settings.');
                        updateSelectionSummary();

                        hud.querySelectorAll('.camHUD-btn, .camHUD-cornerBtn').forEach(btn => {
                            const action = btn.dataset.action || btn.dataset.cam;
                            if (!action) return;
                            buttonByAction.set(action, btn);
                            btn.setAttribute('aria-pressed', 'false');
                            btn.addEventListener('click', () => handlePadSelection(action));
                        });

                        updateButtonStates();

                        // When toggles change, re-render current action’s controls
                        [useDeg, fovTweak].forEach(el => el?.addEventListener('change', () => {
                            if (state.activeAction && state.selections.has(state.activeAction)) {
                                renderReveal(state.activeAction);
                            } else {
                                setActionMessages('Choose a camera move', 'Pick a control on the pad to reveal its settings.');
                                updateSelectionSummary();
                            }
                        }));

                        // Prompt builder for Kontext
                        function buildCameraPrompt() {
                            if (!state.selections.size) return '';

                            const usingDegrees = !!(useDegreesEl && useDegreesEl.checked);
                            const basePrompts = {
                                tilt_up: amount => `tilt the camera upward by ${amount}`,
                                tilt_down: amount => `tilt the camera downward by ${amount}`,
                                pan_left: amount => `pan the camera left horizontally by ${amount}`,
                                pan_right: amount => `pan the camera right horizontally by ${amount}`,
                                roll_left: amount => `roll the camera counter-clockwise by ${amount}`,
                                roll_right: amount => `roll the camera clockwise by ${amount}`,
                                zoom_in: amount => `zoom the camera in tighter by ${amount}`,
                                zoom_out: amount => `zoom the camera out wider by ${amount}`,
                                dolly_in: amount => `dolly in ${amount} with natural perspective`,
                                dolly_out: amount => `dolly out ${amount} with natural perspective`,
                                truck_left: amount => `slide the camera left by ${amount} (truck move)`,
                                truck_right: amount => `slide the camera right by ${amount} (truck move)`,
                                crane_up: amount => `raise the camera ${amount} (crane move)`,
                                crane_down: amount => `lower the camera ${amount} (crane move)`,
                                orbit_left: amount => `orbit the camera left around the subject by ${amount}`,
                                orbit_right: amount => `orbit the camera right around the subject by ${amount}`
                            };

                            const moves = [];
                            state.selections.forEach((entry, action) => {
                                if (action === 'recenter') {
                                    moves.push('recenter the subject; keep original composition and focal length');
                                    return;
                                }

                                const meta = ACTIONS[action];
                                let effectiveAction = action;
                                let amountWord = 'a small amount';

                                if (meta) {
                                    const values = entry?.values || {};
                                    if (meta.kind === 'pct') {
                                        const range = sliderRangeFor(meta, false);
                                        const pct = clampToRange(values.pct ?? (range ? range.def : meta.def ?? 30), range);
                                        const magnitude = Math.abs(pct);
                                        amountWord = `${magnitude}%`;
                                    } else if (meta.kind === 'deg') {
                                        if (usingDegrees) {
                                            const range = sliderRangeFor(meta, true);
                                            const degVal = clampToRange(values.deg ?? (range ? range.def : 10), range);
                                            if (degVal < 0) {
                                                effectiveAction = OPPOSITE_ACTIONS[action] || action;
                                            }
                                            amountWord = `${Math.abs(degVal)} degrees`;
                                        } else {
                                            const range = sliderRangeFor(meta, false);
                                            const intensity = clampToRange(values.intensity ?? (range ? range.def : 30), range);
                                            const magnitude = Math.abs(intensity);
                                            if (magnitude <= 25) amountWord = 'a subtle amount';
                                            else if (magnitude <= 60) amountWord = 'a noticeable amount';
                                            else amountWord = 'an aggressive amount';
                                        }
                                    }
                                }

                                const baseFn = basePrompts[effectiveAction];
                                const label = labelForAction(action).toLowerCase();
                                const base = baseFn
                                    ? baseFn(amountWord)
                                    : `adjust the camera (${label}) by ${amountWord}`;
                                if (base) moves.push(base);
                            });

                            const locks = ['preserve framing', 'avoid cropping', 'keep focal length constant'];
                            if (subjectLockEl && subjectLockEl.checked) locks.push('keep main subject centered and sharp');
                            if (fovTweakEl && fovTweakEl.checked) locks.push('allow slight FOV adjustment to maintain scale');

                            const extra = advPrompt && advPrompt.value.trim();
                            const parts = [];
                            if (moves.length) parts.push(moves.join('; '));
                            if (locks.length) parts.push(locks.join(', '));
                            if (extra) parts.push(extra);

                            return parts.filter(Boolean).join(', ');
                        }

                        // Submit → POST to /flux-kontext (same contract as Lighting HUD)
                        if (runBtn) runBtn.addEventListener('click', async () => {
                            if (!buildCompositeForBackend) {
                                console.warn('buildCompositeForBackend() missing.');
                                return;
                            }
                            if (!state.selections.size) {
                                setActionMessages('Choose a camera move', 'Pick a control on the pad to reveal its settings.');
                                updateSelectionSummary();
                                return;
                            }

                            if (!state.activeAction || !state.selections.has(state.activeAction)) {
                                const first = state.selections.keys().next().value || null;
                                if (first) setActiveAction(first);
                            }

                            const prompt = buildCameraPrompt();
                            if (!prompt) {
                                setActionMessages('Choose a camera move', 'Pick a control on the pad to reveal its settings.');
                                return;
                            }

                            const selectionLabels = Array.from(state.selections.keys()).map(labelForAction);
                            const selectionSummary = selectionLabels.length
                                ? selectionLabels.join(' + ')
                                : 'Custom camera move';

                            // Choose/persist seed (same pattern as Lighting/ToD)
                            let seed = getKonSeed();
                            const locked = seedLock && seedLock.classList.contains('locked');
                            if (locked) {
                                const sel = (seedSelect && seedSelect.value || '').trim();
                                if (sel && sel !== 'random') seed = sel;
                                if (!seed) seed = String(Math.floor(Math.random() * 1e9));
                                if (seedSelect) { ensureOption(seedSelect, seed); seedSelect.value = seed; }
                            } else {
                                seed = String(Math.floor(Math.random() * 1e9));
                                if (seedSelect) seedSelect.value = 'random';
                            }
                            setKonSeed(seed);

                            // Build the composite we send to Kontext
                            const offC = await buildCompositeForBackend();
                            const composite_b64 = offC.toDataURL('image/png');

                            // UI: spinner/progress
                            const at = document.getElementById('actionText'); // fix invalid LHS issue
                            if (at) at.textContent = 'Camera: Generating...';
                            runBtn.classList.add('seafoam30Active', 'processing');
                            showCancelBtn(); fakeProcessBar(9000);

                            // Payload expected by /flux-kontext
                            const payload = {
                                workflow: 'camera',
                                prompt,
                                steps: parseInt(steps.value, 10),
                                guidance: parseFloat(guidance.value),
                                seed: parseInt(seed, 10),
                                composite_b64,
                                width: offC.width,
                                height: offC.height
                            };

                            try {
                                const res = await fetch(`/flux-kontext`, {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify(payload)
                                });
                                const result = await res.json();
                                stopFakeProcessBar(); hideCancelBtn();
                                runBtn.classList.remove('processing');

                                if (result?.seed_used) setKonSeed(result.seed_used);

                                if (result?.image) {
                                    const img = new Image();
                                    img.src = result.image;
                                    img.onload = () => {
                                        backgroundImage = img;
                                        const info =
                                            `Camera: ${selectionSummary}\n` +
                                            `Steps: ${payload.steps}\n` +
                                            `Guidance: ${payload.guidance}\n` +
                                            `Seed: ${seed}`;
                                        sessionOutputs.push({ img, model: 'CAMERA', info });
                                        currentOutIndex = sessionOutputs.length - 1;
                                        isOverlayVisible = false;
                                        updateFgStickerVisibility();
                                        computeBgLayout(img);
                                        drawCanvas();
                                        updateHistoryThumbs();
                                        updateLiveSnapshotIfCurrent();
                                        setActionText('Kontext Camera applied ✔');
                                    };
                                } else {
                                    setActionText('Camera Error: ' + (result.error || 'Unknown error'));
                                }
                            } catch (e) {
                                stopFakeProcessBar(); hideCancelBtn();
                                runBtn.classList.remove('processing');
                                setActionText('Camera failed: ' + e.message);
                                console.error(e);
                            } finally {
                                runBtn.classList.remove('seafoam30Active');
                            }
                        });
                    });
                })();


                // Time of Day HUD controls---------------
                (function () {
                    // ---------- Safe DOM helpers ----------
                    const $ = (s, r = document) => r.querySelector(s);
                    const $$ = (s, r = document) => Array.from(r.querySelectorAll(s));

                    document.addEventListener('DOMContentLoaded', () => {
                        const hud = $('#workflowTimeOfDayHUD');
                        if (!hud) return; // nothing to wire if HUD not on page

                        const todToggleState = initKontextToggleGroup(document.getElementById('todKontextToggles'));

                        // ---------- Elements (per your current markup) ----------
                        const todPromptInput = $('#todPromptInput');
                        const todDaypartDisplay = $('#todDaypartDisplay');
                        const todDaypartLabel = $('#todDaypartLabel');
                        const sweetSelect = $('#todSweetenerSelect');     // legacy <select multiple>
                        const sweetLegacyDisplay = $('#todSweetenerDisplay');    // legacy label under select
                        const intensity = $('#todIntensity');
                        const intensityValue = $('#todIntensityValue');
                        const todGuidance = $('#todGuidance');
                        const todGuidanceVal = $('#todGuidanceVal');
                        const todSteps = $('#todSteps');
                        const todStepsVal = $('#todStepsVal');
                        const todSeedLock = $('#todSeedLock');
                        const todSeedSelect = $('#todSeedSelect');
                        const runBtn = $('#runTimeOfDayBtn');

                        // Optional (enhanced extras UI). If missing, we fall back to <select>.
                        const extrasControl = $('#todExtrasControl');
                        const extrasToggle = $('#todExtrasToggle');
                        const extrasMenu = $('#todExtrasMenu');
                        const extrasSummary = $('#todExtrasSummary');

                        // ---------- State ----------
                        const todState = {
                            daypart: 'midday',
                            sweet: new Set(['match-sky', 'match-shadows']),  // defaults on
                            intensity: intensity ? +intensity.value : 50
                        };

                        // ---------- Presets & sweeteners ----------
                        const TOD_PRESETS = {
                            golden_am: { prompt: "a realistic photograph at sunrise", guidance: 1.6 },
                            midday: { prompt: "a realistic photograph on a sunny day, high contrast", guidance: 1.4 },
                            overcast: { prompt: "a realistic photograph on an overcast day", guidance: 1.4 },
                            blue_hour: { prompt: "post‑sunset deep blue skylight, minimal direct sun, soft cyan fill, subtle warm city/window accents", guidance: 1.6 },
                            sunset: { prompt: "a realistic photograph at sunset", guidance: 1.6 },
                            night: { prompt: "a realistic photograph at night", guidance: 1.8 }
                            //golden_am: { prompt: "early morning golden light, low sun angle ~10–15°, soft warm highlights, gentle long shadows, crisp air", steps: 9, guidance: 1.6 },
                            //midday: { prompt: "overhead hard white sunlight, short defined shadows, high contrast, minimal atmospheric scatter", steps: 8, guidance: 1.9 },
                            //overcast: { prompt: "full cloud cover, large softbox sky, shadowless diffuse light, flattened contrast, cool neutral tones", steps: 8, guidance: 1.6 },
                            //blue_hour: { prompt: "post‑sunset deep blue skylight, minimal direct sun, soft cyan fill, subtle warm city/window accents", steps: 10, guidance: 1.8 },
                            //sunset: { prompt: "low sun ~5–10°, saturated warm spectrum, long cinematic shadows, slight haze for glow", steps: 10, guidance: 1.75 },
                            //night: { prompt: "nighttime scene lit by moon and practicals, cool blue ambience, soft long shadows, subdued contrast", steps: 11, guidance: 2.0 }
                        };
                        const TOD_TINTS = {
                            golden_am: 'rgba(255,182,70,.38)',
                            midday: 'rgba(100,206,255,.35)',
                            overcast: 'rgba(97,97,133,.50)',
                            blue_hour: 'rgba(90,140,255,.28)',
                            sunset: 'rgba(251,145,143,.47)',
                            night: 'rgba(156,132,191,.38)'
                        };

                        const SWEETENERS = {
                            "match-sky": "harmonize sky color temperature and luminance with chosen daypart",
                            "match-shadows": "align shadow direction and softness to daypart sun/moon angle",
                            "mist": "fine moisture mist, subtle diffusion",
                            "godrays": "sunbeams through particles (volumetric crepuscular rays)",
                            "longShadows": "emphasized long directional shadows",
                            "volumetric": "visible volumetric light shafts in air",
                            "warm": "warmer white balance bias",
                            "cool": "cooler white balance bias"
                        };

                        // ---------- Helpers ----------
                        function setActiveSingle(container, selector, target, cls = 'active') {
                            $$(selector, container).forEach(b => {
                                b.classList.remove(cls);
                                b.setAttribute('aria-pressed', 'false');
                            });
                            target.classList.add(cls);
                            target.setAttribute('aria-pressed', 'true');
                            target.classList.add('flash'); setTimeout(() => target.classList.remove('flash'), 230);
                        }

                        function updateDaypartPhrase() {
                            if (todDaypartDisplay) {
                                const base = TOD_PRESETS[todState.daypart]?.prompt || '';
                                todDaypartDisplay.textContent = base ? `Time of day phrase: ${base}` : '';
                            }
                            if (todDaypartLabel) {
                                const btn = $(`.todIconButton[data-tod="${todState.daypart}"]`, hud);
                                const labelText = btn?.getAttribute('title') || todState.daypart;
                                todDaypartLabel.textContent = labelText ? labelText.toUpperCase() : '';
                            }
                        }

                        function updateSweetenerDisplayFromSelect() {
                            if (!sweetSelect) return;
                            const values = Array.from(sweetSelect.selectedOptions).map(o => o.value);
                            todState.sweet = new Set(values);
                            if (sweetLegacyDisplay) {
                                const labels = values.map(v => sweetSelect.querySelector(`option[value="${v}"]`)?.textContent || v);
                                sweetLegacyDisplay.textContent = labels.join(', ');
                            }
                        }

                        function applyTodTint() {
                            const tintPane = document.getElementById('todTintPane');
                            if (!tintPane) return;
                            // Base glass bg stays constant; tint varies by daypart
                            tintPane.style.setProperty('--tod-bg',
                                'linear-gradient( to bottom right, rgba(26,36,41,.92), rgba(24,28,33,.86) )');
                            tintPane.style.setProperty('--tod-tint', TOD_TINTS[todState.daypart] || 'transparent');
                        }

                        // Update your existing display function to also apply the tint
                        function updateDaypartDisplay() {
                            const base = TOD_PRESETS[todState.daypart]?.prompt || '';
                            todDaypartDisplay.innerHTML = 'Time of day phrase: <em>' + base + '</em>';
                            applyTodTint(); // <— add this line
                        }

                        // Enhanced “Extras” UI (chips + dropdown) — only if markup exists.
                        function wireExtrasControlIfPresent() {
                            if (!extrasControl || !extrasToggle || !extrasMenu || !extrasSummary || !sweetSelect) return;

                            let options = Array.from(sweetSelect.options).map(o => ({
                                value: o.value, label: o.text, selected: o.selected
                            }));

                            const paintMenu = () => {
                                extrasMenu.innerHTML = '';
                                options.forEach((opt, i) => {
                                    const row = document.createElement('label');
                                    row.className = 'optRow';
                                    row.setAttribute('role', 'option');
                                    row.setAttribute('aria-selected', String(!!opt.selected));

                                    const cb = document.createElement('input');
                                    cb.type = 'checkbox';
                                    cb.checked = !!opt.selected;
                                    cb.dataset.index = i;

                                    const txt = document.createElement('span');
                                    txt.textContent = opt.label;

                                    row.append(cb, txt);
                                    extrasMenu.appendChild(row);
                                });
                            };

                            const paintSummary = () => {
                                extrasSummary.innerHTML = '';
                                const selectedLabels = [];
                                options.forEach((opt, i) => {
                                    sweetSelect.options[i].selected = !!opt.selected;
                                    if (opt.selected) {
                                        selectedLabels.push(opt.label);
                                        const chip = document.createElement('span');
                                        chip.className = 'todChip';
                                        chip.textContent = opt.label;

                                        const x = document.createElement('button');
                                        x.className = 'x';
                                        x.setAttribute('aria-label', `Remove ${opt.label}`);
                                        x.textContent = '×';
                                        x.addEventListener('click', (e) => {
                                            e.stopPropagation();
                                            opt.selected = false;
                                            paintMenu(); paintSummary();
                                            updateSweetenerDisplayFromSelect();
                                        });
                                        chip.appendChild(x);
                                        extrasSummary.appendChild(chip);
                                    }
                                });
                                if (sweetLegacyDisplay) sweetLegacyDisplay.textContent = selectedLabels.join(', ');
                                extrasToggle.textContent = selectedLabels.length ? `${selectedLabels.length} selected` : 'Choose extras';
                                // sync state set
                                todState.sweet = new Set(options.filter(o => o.selected).map(o => o.value));
                            };

                            extrasMenu.addEventListener('change', (e) => {
                                const idx = e.target?.dataset?.index;
                                if (idx !== undefined) {
                                    options[idx].selected = e.target.checked;
                                    paintSummary();
                                }
                            });

                            extrasToggle.addEventListener('click', () => {
                                extrasControl.classList.toggle('open');
                                extrasToggle.setAttribute('aria-expanded', extrasControl.classList.contains('open'));
                            });

                            document.addEventListener('click', (e) => {
                                if (!extrasControl.contains(e.target)) extrasControl.classList.remove('open');
                            });

                            sweetSelect.addEventListener('change', () => {
                                options.forEach((opt, i) => {
                                    opt.selected = sweetSelect.options[i].selected;
                                });
                                paintMenu();
                                paintSummary();
                            });

                            paintMenu();
                            paintSummary();
                        }

                        // Build final prompt for backend
                        function buildKontextPrompt() {
                            const base = TOD_PRESETS[todState.daypart] || TOD_PRESETS.midday;
                            const basePrompt = base?.prompt || '';
                            const sweetText = Array.from(todState.sweet)
                                .map(k => SWEETENERS[k])
                                .filter(Boolean)
                                .join(', ');

                            // Map intensity to quick prompt seasoning + backend strength
                            const strengthRaw = Number.isFinite(todState.intensity) ? todState.intensity : 0;
                            const strengthClamped = Math.max(0, Math.min(100, strengthRaw));
                            const strengthWord = strengthClamped < 35 ? 'subtle' : strengthClamped > 70 ? 'pronounced' : 'balanced';
                            const intensityRatio = strengthClamped / 100;
                            const denoiseStrength = 0.05 + intensityRatio * 0.2; // 0.05 → 0.25 window

                            const adv = (todPromptInput?.value || '').trim();

                            const core = [
                                basePrompt,
                                sweetText ? `${strengthWord} ${sweetText}` : '',
                                //"coherent photographic lighting, physically plausible, no color cast clipping",
                                adv
                            ].filter(Boolean).join(', ');

                            return {
                                prompt: core,
                                steps: parseInt(todSteps?.value || base.steps, 10),
                                guidance: parseFloat(todGuidance?.value || base.guidance),
                                daypart: todState.daypart,
                                sweeteners: Array.from(todState.sweet),
                                intensity: strengthClamped,
                                advPrompt: adv,
                                basePrompt,
                                strength: Number(denoiseStrength.toFixed(3))
                            };
                        }

                        // Expose a clean, typo‑free state getter for other modules
                        window.getTimeOfDayState = () => ({
                            daypart: todState.daypart,
                            sweet: Array.from(todState.sweet),
                            intensity: todState.intensity,
                            steps: parseInt(todSteps?.value || TOD_PRESETS[todState.daypart].steps, 10),
                            guidance: parseFloat(todGuidance?.value || TOD_PRESETS[todState.daypart].guidance),
                            seedLocked: todSeedLock?.classList.contains('locked') || false,
                            seedValue: parseInt(todSeedSelect?.value || '0', 10) || 0,
                            advPrompt: (todPromptInput?.value || '').trim()
                        });

                        // ---------- Wire daypart buttons ----------
                        $$('.todIconButton[data-tod]', hud).forEach(btn => {
                            btn.addEventListener('click', () => {
                                setActiveSingle(hud, '.todIconButton[data-tod]', btn, 'active'); // uses your .todIconButton.active style
                                todState.daypart = btn.dataset.tod;
                                updateDaypartPhrase();
                                updateDaypartDisplay();
                            });
                        });
                        // Make “midday” active on load if present
                        const defaultBtn = $('.todIconButton[data-tod="midday"]', hud);
                        if (defaultBtn) defaultBtn.click();

                        // ---------- Sliders & readouts ----------
                        if (intensity && intensityValue) {
                            intensity.addEventListener('input', () => {
                                todState.intensity = +intensity.value;
                                intensityValue.textContent = intensity.value;
                            });
                            intensityValue.textContent = intensity.value;
                        }
                        if (todGuidance && todGuidanceVal) {
                            todGuidance.addEventListener('input', () => { todGuidanceVal.textContent = todGuidance.value; });
                            todGuidanceVal.textContent = todGuidance.value;
                        }
                        if (todSteps && todStepsVal) {
                            todSteps.addEventListener('input', () => { todStepsVal.textContent = todSteps.value; });
                            todStepsVal.textContent = todSteps.value;
                        }

                        // ---------- Seed lock UX (Material HUD parity) ----------
                        if (todSeedLock && todSeedSelect) {
                            todSeedLock.addEventListener('click', () => {
                                const locked = todSeedLock.classList.toggle('locked');
                                todSeedLock.setAttribute('aria-pressed', String(locked));
                                todSeedLock.textContent = locked ? '🔒' : '🔓';
                                if (locked && (todSeedSelect.value === 'random' || !todSeedSelect.value)) {
                                    const newSeed = String(Math.floor(Math.random() * 1e9));
                                    const opt = document.createElement('option');
                                    opt.value = newSeed;
                                    opt.textContent = newSeed;
                                    todSeedSelect.add(opt);
                                    todSeedSelect.value = newSeed;
                                }
                            });
                        }

                        // ---------- Extras (select OR enhanced dropdown) ----------
                        if (extrasControl) {
                            wireExtrasControlIfPresent();            // new compact UI (chips)
                        } else if (sweetSelect) {
                            sweetSelect.addEventListener('change', updateSweetenerDisplayFromSelect);
                            updateSweetenerDisplayFromSelect();      // legacy <select multiple>
                        }

                        // ---------- Collapsible sections (like Material HUD) ----------
                        $$('.hudSectionHeader', hud).forEach(header => {
                            header.style.cursor = 'pointer';
                            header.addEventListener('click', () => {
                                const body = header.nextElementSibling;
                                if (!body) return;
                                body.classList.toggle('collapsed');
                                header.classList.toggle('active');
                            });
                        });

                        // ---------- Apply (backend call) ----------
                        if (runBtn) {
                            runBtn.onclick = async function () {
                                setActionText('Time of Day: Generating...');
                                runBtn.classList.add('seafoam30Active', 'processing');

                                // Snapshot current canvas for Before/After unless a view is locked
                                if (beforeLockIndex === -1 && currentOutIndex === -1) {
                                    liveBGImage = backgroundImage;
                                    liveFGStickers = stickers.map(cloneSticker);
                                }

                                // Build composite for backend (provided elsewhere in app)
                                const offC = await buildCompositeForBackend();
                                const composite_b64 = offC.toDataURL('image/png');

                                // ——— ToD: choose/record seed ———
                                let seed = getKonSeed();
                                const todLocked = todSeedLock?.classList.contains('locked');

                                if (todLocked) {
                                    const sel = (todSeedSelect?.value || '').trim();
                                    if (sel && sel !== 'random') seed = sel;
                                    if (!seed) seed = String(Math.floor(Math.random() * 1e9));
                                    ensureOption(todSeedSelect, seed);
                                    todSeedSelect.value = seed;
                                } else {
                                    seed = String(Math.floor(Math.random() * 1e9));
                                    if (todSeedSelect) todSeedSelect.value = 'random';
                                }

                                setKonSeed(seed);

                                // Build prompt from current selections
                                const kp = buildKontextPrompt();

                                // Payload expected by your /flux-kontext route
                                const payload = {
                                    prompt: kp.prompt,
                                    steps: kp.steps,
                                    guidance: kp.guidance,
                                    seed: parseInt(seed, 10),
                                    composite_b64,
                                    width: offC.width,
                                    height: offC.height,
                                    workflow: "tod",
                                    align: !!todToggleState.align,
                                    full_res: !!todToggleState.fullRes,
                                    use_depth: !!todToggleState.depth,
                                    strength: kp.strength,
                                    refinement_intensity: kp.intensity,
                                    sweeteners: kp.sweeteners,
                                    tod_daypart: kp.daypart,
                                    adv_prompt: kp.advPrompt,
                                    base_prompt: kp.basePrompt,
                                };

                                showCancelBtn();
                                fakeProcessBar(9000);

                                try {
                                    const res = await fetch(`/flux-kontext`, {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'application/json' },
                                        body: JSON.stringify(payload)
                                    });
                                    const result = await res.json();

                                    stopFakeProcessBar();
                                    hideCancelBtn();

                                    if (result.seed_used) {
                                        setKonSeed(result.seed_used);
                                    }

                                    if (result.image) {
                                        const img = new Image();
                                        img.src = result.image;
                                        const originalBG = backgroundImage;
                                        img.onload = () => {
                                            backgroundImage = img;
                                            const info =
                                                `Time of Day: ${todState.daypart}\n` +
                                                `Extras: ${Array.from(todState.sweet).join(', ') || 'none'}\n` +
                                                `Steps: ${payload.steps}\n` +
                                                `Guidance: ${payload.guidance}\n` +
                                                `Seed: ${seed}`;
                                            sessionOutputs.push({ img, model: 'TIME OF DAY', info, orig: originalBG, blend: 1 });
                                            currentOutIndex = sessionOutputs.length - 1;
                                            todBlendOriginal = originalBG;
                                            todBlendRatio = 1;
                                            isOverlayVisible = false;
                                            updateFgStickerVisibility();
                                            computeBgLayout(img);
                                            drawCanvas();
                                            updateHistoryThumbs();
                                            updateLiveSnapshotIfCurrent();
                                            setActionText('Time of Day applied ✔');
                                        };
                                    } else {
                                        setActionText('Time of Day Error: ' + (result.error || 'Unknown error'));
                                    }
                                } catch (e) {
                                    stopFakeProcessBar();
                                    hideCancelBtn();
                                    setActionText('Time of Day failed: ' + e.message);
                                } finally {
                                    runBtn.classList.remove('seafoam30Active', 'processing');
                                }
                            };
                        }
                    });
                })();

                // ---- CAMERA PROMPT BUILDER ----
                function buildCameraPrompt(action, {
                    degrees = 10,         // 5–45° typical; used by orbit/tilt/roll
                    amount = 30,          // 0–100; used by dolly/truck/crane/FOV
                    fov = 0,              // -30..+30 (narrow .. wide); optional
                    subjectLock = true,   // try to keep subject size/position
                    advText = ""          // user-supplied extra descriptors
                } = {}) {
                    // Map degree/amount to quick adjectives for minimal text prompts
                    const magWord = (v) => (v <= 10 ? "slight" : v <= 20 ? "moderate" : "pronounced");
                    const amtWord = magWord(Math.abs(degrees || amount));

                    // Core camera verbs -> terse phrases for Kontext
                    const CAMERA_TEMPLATES = {
                        orbit_left: ({ deg }) => `orbit camera left ${deg}°, ${amtWord} background parallax`,
                        orbit_right: ({ deg }) => `orbit camera right ${deg}°, ${amtWord} background parallax`,
                        tilt_up: ({ deg }) => `tilt camera up ${deg}°, adjust horizon`,
                        tilt_down: ({ deg }) => `tilt camera down ${deg}°, adjust horizon`,
                        roll_left: ({ deg }) => `roll camera left ${deg}°`,
                        roll_right: ({ deg }) => `roll camera right ${deg}°`,
                        dolly_in: ({ amt }) => `dolly in ${amt}% with natural perspective`,
                        dolly_out: ({ amt }) => `dolly out ${amt}% with natural perspective`,
                        truck_left: ({ amt }) => `slide camera left ${amt}% (truck)`,
                        truck_right: ({ amt }) => `slide camera right ${amt}% (truck)`,
                        crane_up: ({ amt }) => `raise camera ${amt}% (crane)`,
                        crane_down: ({ amt }) => `lower camera ${amt}% (crane)`,
                    };

                    // Compose the short, “push‑button” instruction
                    const base = CAMERA_TEMPLATES[action]
                        ? CAMERA_TEMPLATES[action]({ deg: degrees, amt: amount })
                        : `reframe camera ${amtWord}`;

                    // Subject lock tries to protect the foreground/character
                    const subjectRule = subjectLock
                        ? "keep main subject identity, size, and position; background only"
                        : "allow global reframe while maintaining scene plausibility";

                    // Optional FOV seasoning
                    const fovRule = (typeof fov === "number" && fov !== 0)
                        ? (fov > 0 ? "slightly wider field of view" : "slightly narrower field of view")
                        : "";

                    // Terse final prompt, ordered for clarity and minimal tokens
                    const finalPrompt = [base, subjectRule, fovRule, advText].filter(Boolean).join(", ");

                    // Negative prompt to avoid nasty geometry/lighting surprises
                    const negative = [
                        "fisheye, extreme warping, deformed subject, face distortion",
                        "heavy relighting, strong color cast"
                    ].join(", ");

                    // Map UI “amount” to denoise strength (Kontext supports 'strength' when available)
                    // Keep it conservative by default (0.08..0.35)
                    const strength = Math.max(0.05, Math.min(0.45, (amount / 100) * 0.35 + 0.08));

                    return { prompt: finalPrompt, negative_prompt: negative, strength };
                }

                // ---------- Stylize HUD ----------
                (function () {
                    const $ = (s, r = document) => r.querySelector(s);
                    const $$ = (s, r = document) => Array.from(r.querySelectorAll(s));
                    document.addEventListener('DOMContentLoaded', () => {
                        const hud = $('#workflowStylizeHUD');
                        if (!hud) return;
                        const modeBtns = $$('.stylizeIconButton', hud);
                        const modeLabel = $('#stylizeModeLabel', hud);
                        const modeDisplay = $('#stylizeModeDisplay', hud);
                        const descriptorSelect = $('#stylizeDescriptorSelect', hud);
                        const intensity = $('#stylizeIntensity', hud);
                        const intensityValue = $('#stylizeIntensityValue', hud);
                        const promptInput = $('#stylizePromptInput', hud);
                        const guidance = $('#stylizeGuidance', hud);
                        const guidanceVal = $('#stylizeGuidanceVal', hud);
                        const steps = $('#stylizeSteps', hud);
                        const stepsVal = $('#stylizeStepsVal', hud);
                        const seedLock = $('#stylizeSeedLock', hud);
                        const seedSelect = $('#stylizeSeedSelect', hud);
                        const runBtn = $('#runStylizeBtn', hud);
                        const drop = $('#stylizeImageDrop', hud);
                        const fileInput = $('#stylizeImageInput', hud);
                        const extrasControl = $('#stylizeExtrasControl', hud);
                        const extrasToggle = $('#stylizeExtrasToggle', hud);
                        const extrasMenu = $('#stylizeExtrasMenu', hud);
                        const extrasSummary = $('#stylizeExtrasSummary', hud);
                        // 1) Grab new controls
                        const styleSection = $('#styleTransferControls', hud);
                        const stylePalette = $('#stylePalette', hud);
                        const stylePaletteVal = $('#stylePaletteVal', hud);
                        const styleTexture = $('#styleTexture', hud);
                        const styleTextureVal = $('#styleTextureVal', hud);
                        const styleLine = $('#styleLine', hud);
                        const styleLineVal = $('#styleLineVal', hud);
                        const styleLightingLock = $('#styleLightingLock', hud);

                        $$('#workflowStylizeHUD .hudSectionHeader').forEach(header => {
                            header.style.cursor = 'pointer';
                            header.addEventListener('click', () => {
                                const body = header.nextElementSibling;
                                if (!body) return;
                                body.classList.toggle('collapsed');
                                header.classList.toggle('active');
                            });
                        });

                        const DESCRIPTORS = {
                            'character-consistency': 'maintain character consistency',
                            'style-matching': 'match artistic style',
                            'local-editing': 'limit edits locally',
                            'background-harmony': 'preserve background harmony'
                        };
                        const MODE_PROMPTS = {
                            'style-transfer': 'apply reference style to image',
                            'refine': 'refine image while keeping style',
                            'add-item': 'add new object matching style',
                            'remove-item': 'remove object seamlessly'
                        };
                        const state = {
                            mode: 'style-transfer',
                            descriptors: new Set(Array.from(descriptorSelect.selectedOptions).map(o => o.value)),
                            intensity: intensity ? +intensity.value : 50,
                            referenceImage: null
                        };

                        //  Readout wiring
                        function _syncReadout(slider, out) { if (slider && out) { out.textContent = slider.value; slider.addEventListener('input', () => out.textContent = slider.value); } }
                        _syncReadout(stylePalette, stylePaletteVal);
                        _syncReadout(styleTexture, styleTextureVal);
                        _syncReadout(styleLine, styleLineVal);

                        // 3) Show this section only in "style-transfer" mode
                        function updateTransferVisibility() {
                            if (!styleSection) return;
                            styleSection.style.display = (state.mode === 'style-transfer') ? 'block' : 'none';
                        }
                        updateTransferVisibility();

                        function updateModeDisplay() {
                            const btn = $(`.stylizeIconButton[data-mode="${state.mode}"]`, hud);
                            const labelText = btn?.getAttribute('title') || state.mode;
                            if (modeLabel) modeLabel.textContent = labelText.toUpperCase();
                            if (modeDisplay) modeDisplay.innerHTML = MODE_PROMPTS[state.mode] ? `Stylize action: <em>${MODE_PROMPTS[state.mode]}</em>` : '';
                        }
                        modeBtns.forEach(btn => {
                            btn.addEventListener('click', () => {
                                state.mode = btn.dataset.mode;
                                modeBtns.forEach(b => { b.classList.remove('active'); b.setAttribute('aria-pressed', 'false'); });
                                btn.classList.add('active');
                                btn.setAttribute('aria-pressed', 'true');
                                updateModeDisplay();
                                updateTransferVisibility();
                            });
                        });
                        updateModeDisplay();

                        //  Nudge the prompt to explicitly avoid relighting when requested
                        //    (Insert these two lines right after `const kp = buildStylizePrompt();` inside your run handler.)
                        function _applyLightingLockToPrompt(kp) {
                            if (state.mode === 'style-transfer' && styleLightingLock?.checked) {
                                kp.prompt += ', keep original lighting, do not change illumination, highlights, or shadows';
                            }
                            return kp;
                        }

                        //  Extend the payload with transfer parameters + workflow="style-transfer"
                        //    (Insert this into your run button handler before the fetch.)
                        function _buildTransferPayloadPatch(offC) {
                            const transfer = {
                                palette: (stylePalette ? Number(stylePalette.value) : 70) / 100,
                                texture: (styleTexture ? Number(styleTexture.value) : 60) / 100,
                                line: (styleLine ? Number(styleLine.value) : 40) / 100,
                                preserve_lighting: !!styleLightingLock?.checked
                            };
                            return {
                                workflow: (state.mode === 'style-transfer') ? 'style-transfer' : state.mode,
                                transfer
                            };
                        }

                        function updateDescriptorsFromSelect() {
                            state.descriptors = new Set(Array.from(descriptorSelect.selectedOptions).map(o => o.value));
                        }
                        if (descriptorSelect) {
                            descriptorSelect.addEventListener('change', updateDescriptorsFromSelect);
                        }
                        function wireDescriptorControl() {
                            if (!extrasControl || !extrasToggle || !extrasMenu || !extrasSummary || !descriptorSelect) return;
                            let options = Array.from(descriptorSelect.options).map(o => ({ value: o.value, label: o.text, selected: o.selected }));
                            const paintMenu = () => {
                                extrasMenu.innerHTML = '';
                                options.forEach((opt, i) => {
                                    const row = document.createElement('label');
                                    row.className = 'optRow';
                                    row.setAttribute('role', 'option');
                                    row.setAttribute('aria-selected', String(!!opt.selected));
                                    const cb = document.createElement('input');
                                    cb.type = 'checkbox';
                                    cb.checked = !!opt.selected;
                                    cb.dataset.index = i;
                                    const txt = document.createElement('span');
                                    txt.textContent = opt.label;
                                    row.append(cb, txt);
                                    extrasMenu.appendChild(row);
                                });
                            };
                            const paintSummary = () => {
                                extrasSummary.innerHTML = '';
                                const selectedLabels = [];
                                options.forEach((opt, i) => {
                                    descriptorSelect.options[i].selected = !!opt.selected;
                                    if (opt.selected) {
                                        selectedLabels.push(opt.label);
                                        const chip = document.createElement('span');
                                        chip.className = 'todChip';
                                        chip.textContent = opt.label;
                                        const x = document.createElement('button');
                                        x.className = 'x';
                                        x.setAttribute('aria-label', `Remove ${opt.label}`);
                                        x.textContent = '×';
                                        x.addEventListener('click', e => { e.stopPropagation(); options[i].selected = false; paintMenu(); paintSummary(); updateDescriptorsFromSelect(); });
                                        chip.appendChild(x);
                                        extrasSummary.appendChild(chip);
                                    }
                                });
                                extrasToggle.textContent = selectedLabels.length ? `${selectedLabels.length} selected` : 'Choose descriptors';
                                state.descriptors = new Set(options.filter(o => o.selected).map(o => o.value));
                            };
                            extrasMenu.addEventListener('change', e => {
                                const idx = e.target?.dataset?.index;
                                if (idx !== undefined) { options[idx].selected = e.target.checked; paintSummary(); }
                            });
                            extrasToggle.addEventListener('click', () => {
                                extrasControl.classList.toggle('open');
                                extrasToggle.setAttribute('aria-expanded', extrasControl.classList.contains('open'));
                            });
                            document.addEventListener('click', e => { if (!extrasControl.contains(e.target)) extrasControl.classList.remove('open'); });
                            paintMenu();
                            paintSummary();
                        }
                        wireDescriptorControl();
                        if (intensity && intensityValue) {
                            intensity.addEventListener('input', () => { state.intensity = +intensity.value; intensityValue.textContent = intensity.value; });
                            intensityValue.textContent = intensity.value;
                        }
                        if (guidance && guidanceVal) {
                            guidance.addEventListener('input', () => guidanceVal.textContent = guidance.value);
                            guidanceVal.textContent = guidance.value;
                        }
                        if (steps && stepsVal) {
                            steps.addEventListener('input', () => stepsVal.textContent = steps.value);
                            stepsVal.textContent = steps.value;
                        }
                        if (seedLock && seedSelect) {
                            seedLock.addEventListener('click', () => {
                                const locked = seedLock.classList.toggle('locked');
                                seedLock.setAttribute('aria-pressed', String(locked));
                                seedLock.textContent = locked ? '🔒' : '🔓';
                                if (locked && (seedSelect.value === 'random' || !seedSelect.value)) {
                                    const newSeed = String(Math.floor(Math.random() * 1e9));
                                    const opt = document.createElement('option');
                                    opt.value = newSeed; opt.textContent = newSeed; seedSelect.add(opt); seedSelect.value = newSeed;
                                }
                            });
                        }
                        function handleFiles(files) {
                            const file = files[0]; if (!file) return;
                            const reader = new FileReader();
                            reader.onload = () => {
                                state.referenceImage = reader.result;
                                drop.classList.add('loaded');
                                drop.innerHTML = `<img src="${reader.result}" alt="reference"/><button class="imageRemoveBtn" title="Remove"><i class='fa-solid fa-trash'></i></button>`;
                                const rm = drop.querySelector('.imageRemoveBtn');
                                rm.addEventListener('click', e => { e.stopPropagation(); state.referenceImage = null; drop.classList.remove('loaded'); drop.innerHTML = '<i class="fa-solid fa-image"></i>'; });
                            };
                            reader.readAsDataURL(file);
                        }
                        if (drop && fileInput) {
                            drop.addEventListener('click', e => { if (e.target.classList.contains('imageRemoveBtn')) return; fileInput.click(); });
                            drop.addEventListener('dragover', e => { e.preventDefault(); drop.classList.add('dragover'); });
                            drop.addEventListener('dragleave', e => { e.preventDefault(); drop.classList.remove('dragover'); });
                            drop.addEventListener('drop', e => { e.preventDefault(); drop.classList.remove('dragover'); handleFiles(e.dataTransfer.files); });
                            fileInput.addEventListener('change', e => handleFiles(e.target.files));
                        }
                        function buildStylizePrompt() {
                            let core = MODE_PROMPTS[state.mode] || '';
                            state.descriptors.forEach(d => { core += ', ' + DESCRIPTORS[d]; });
                            const adv = (promptInput?.value || '').trim();
                            if (adv) core += ', ' + adv;
                            return { prompt: core, steps: parseInt(steps?.value || '8', 10), guidance: parseFloat(guidance?.value || '1.8') };
                        }
                        if (runBtn) {
                            runBtn.onclick = async function () {
                                setActionText('Stylize: Generating...');
                                runBtn.classList.add('seafoam30Active', 'processing');
                                if (beforeLockIndex === -1 && currentOutIndex === -1) { liveBGImage = backgroundImage; liveFGStickers = stickers.map(cloneSticker); }
                                const offC = await buildCompositeForBackend();
                                const composite_b64 = offC.toDataURL('image/png');
                                let seed = getKonSeed();
                                const locked = stylizeSeedLock?.classList.contains('locked');
                                if (locked) {
                                    const sel = (stylizeSeedSelect?.value || '').trim();
                                    if (sel && sel !== 'random') seed = sel;
                                    if (!seed) seed = String(Math.floor(Math.random() * 1e9));
                                    ensureOption(stylizeSeedSelect, seed);
                                    stylizeSeedSelect.value = seed;
                                } else {
                                    seed = String(Math.floor(Math.random() * 1e9));
                                    if (stylizeSeedSelect) stylizeSeedSelect.value = 'random';
                                }
                                setKonSeed(seed);
                                const kp2 = _applyLightingLockToPrompt(buildStylizePrompt());

                                const payload = {
                                    prompt: kp2.prompt,
                                    steps: kp2.steps,
                                    guidance: kp2.guidance,
                                    seed: parseInt(seed, 10),
                                    composite_b64,
                                    width: offC.width,
                                    height: offC.height,
                                    style_b64: state.referenceImage || null,
                                    ..._buildTransferPayloadPatch(offC)   // adds { workflow: "style-transfer", transfer:{…} }
                                };

                                if (state.mode === 'style-transfer' && !state.referenceImage) {
                                    setActionText('Please add a reference image for Style Transfer.');
                                    runBtn.classList.remove('seafoam30Active', 'processing');
                                    return;
                                }
                                showCancelBtn(); fakeProcessBar(9000);
                                try {
                                    const res = await fetch(`/flux-kontext`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                                    const result = await res.json();
                                    stopFakeProcessBar(); hideCancelBtn();
                                    if (result.seed_used) setKonSeed(result.seed_used);
                                    if (result.image) {
                                        const img = new Image(); img.src = result.image; const originalBG = backgroundImage;
                                        img.onload = () => { backgroundImage = img; const info = `Stylize: ${state.mode}\nDescriptors: ${Array.from(state.descriptors).join(', ') || 'none'}\nSteps: ${payload.steps}\nGuidance: ${payload.guidance}\nSeed: ${seed}`; sessionOutputs.push({ img, model: 'STYLIZE', info, orig: originalBG, blend: 1 }); currentOutIndex = sessionOutputs.length - 1; isOverlayVisible = false; updateFgStickerVisibility(); computeBgLayout(img); drawCanvas(); updateHistoryThumbs(); updateLiveSnapshotIfCurrent(); setActionText('Stylization applied ✔'); };
                                    } else {
                                        setActionText('Stylize Error: ' + (result.error || 'Unknown error'));
                                    }
                                } catch (e) {
                                    stopFakeProcessBar(); hideCancelBtn(); setActionText('Stylize failed: ' + e.message);
                                } finally {
                                    runBtn.classList.remove('seafoam30Active', 'processing');
                                }
                            };
                        }
                    });
                })();

                /* ------------------------------------------------------------------ */
                /*  FLUX.1  text‑to‑image  — queue‑based version                      */
                /* ------------------------------------------------------------------ */
                async function pollFluxJob(jobId, onDone, onError, pollMs = 1200) {
                    try {
                        while (true) {
                            await new Promise(r => setTimeout(r, pollMs));
                            const res = await fetch(`${API_BASE}/flux-job/${jobId}`);
                            const info = await res.json();

                            if (info.status === "pending") continue;
                            if (info.status === "error") { onError(info.message); return; }

                            /* done */
                            onDone(info.path);               // <‑‑ this is relPath we save in job_store
                            return;
                        }
                    } catch (e) { onError(e.message); }
                }

                async function runFluxText2Img(
                    promptVal,
                    negativePrompt = "",
                    stepsVal = null,
                    guidanceVal = null,
                    resolution = null
                ) {
                    const needsDrawer = stepsVal === null || guidanceVal === null;
                    const drawerVals = needsDrawer && typeof readPromptDrawer === "function"
                        ? readPromptDrawer()
                        : null;

                    const parseNumber = (value, fallback) => {
                        const num = Number(value);
                        return Number.isFinite(num) ? num : fallback;
                    };

                    const rawSteps = stepsVal ?? drawerVals?.steps;
                    const rawGuidance = guidanceVal ?? drawerVals?.guidance;

                    const steps = clamp(Math.round(parseNumber(rawSteps, 2)), 1, 75);
                    const guidance = clamp(parseNumber(rawGuidance, 5), 1, 30);

                    const resolutionSelect = document.getElementById("paramResolution");
                    let chosenResolution = resolution ?? resolutionSelect?.value;
                    if (!chosenResolution && resolutionSelect && resolutionSelect.selectedIndex >= 0) {
                        const opt = resolutionSelect.options[resolutionSelect.selectedIndex];
                        if (opt) {
                            chosenResolution = opt.value || opt.textContent;
                        }
                    }
                    chosenResolution = (chosenResolution || "512x512")
                        .toString()
                        .toLowerCase()
                        .replace(/×/g, "x")
                        .replace(/\s+/g, "");
                    if (!/^\d+x\d+$/.test(chosenResolution)) {
                        chosenResolution = "512x512";
                    }

                    const payload = {
                        prompt: promptVal,
                        negative_prompt: negativePrompt,
                        steps,
                        guidance,
                        resolution: chosenResolution
                    };

                    console.log("Flux txt2img ⇒", payload);
                    showGlobalSpinner();
                    canvasSpinnerOverlay.style.display = "flex";

                    try {
                        /* 1️⃣  enqueue */
                        const r = await fetch(`${API_BASE}/flux-text2img`, {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify(payload)
                        });
                        const { job_id, error } = await r.json();
                        if (error || !job_id) throw new Error(error || "No job_id");

                        /* 2️⃣  poll */
                        pollFluxJob(
                            job_id,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            /* DONE */(relPath) => {
                                const imgUrl = `${API_BASE}/${relPath}?t=${Date.now()}`;
                                const img = new Image();
                                img.crossOrigin = "anonymous";
                                img.onload = () => {
                                    hideHomePromptHud();
                                    const info = `Prompt: ${payload.prompt}\nNegative: ${payload.negative_prompt}\nSteps: ${payload.steps}\nGuidance: ${payload.guidance}\nResolution: ${payload.resolution}`;
                                    sessionOutputs.push({ img, model: 'FLUX', info });
                                    backgroundImage = img;
                                    userLoadedBg = true;
                                    disableBgHoverArea();
                                    computeBgLayout(img);
                                    homeImageContainer.style.display = "none";
                                    canvasContainer.style.display = "block";
                                    updateCanvasCursorState();
                                    mainHeader.style.display = "block";
                                    updatePromptHudTitle();
                                    refreshDrawerState();
                                    drawCanvas();
                                    updateHistoryThumbs();
                                    setActionText("Flux.1 Schnell text2image success ✔");
                                    canvasSpinnerOverlay.style.display = "none";
                                };
                                img.src = imgUrl;
                            },
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            /* ERR */(msg) => {
                                setActionText("Flux job failed ⇒ " + msg);
                                canvasSpinnerOverlay.style.display = "none";
                            }
                        );

                    } catch (e) {
                        setActionText("Flux enqueue error ⇒ " + e.message);
                        canvasSpinnerOverlay.style.display = "none";
                    }
                }

                // Helper: SD img2img
                function logDrawerVals(tag) {
                    const p = readPromptDrawer();
                    const out = {
                        strength: clamp(p.strength, 0.1, 1),
                        guidance: clamp(p.guidance, 1, 30),
                        steps: clamp(p.steps, 20, 75),
                        seed: p.seed
                    };
                    console.log(`[${tag}] drawer →`, out);
                    return out;
                }
                window.isGlbForcedHidden = true;

                /* ----------  helpers: mask  ---------- */
                /* 1) solid-white full-frame fallback (in case no stickers) */
                function buildFullWhiteMaskPNG(w, h) {
                    const c = document.createElement('canvas');
                    c.width = w; c.height = h;
                    c.getContext('2d').fillStyle = '#fff';
                    c.getContext('2d').fillRect(0, 0, w, h);
                    return c.toDataURL('image/png');
                }

                /* 2) union-of-all foreground stickers → 1-channel PNG dataURL
                      - draws each sticker’s **visible footprint** in white                */
                function buildUnionStickerMaskPNG(w, h) {
                    const useLive = beforeLockIndex === -1 && (selectedHistoryIndex !== -1 || currentOutIndex !== -1);
                    const src = useLive ? liveFGStickers : stickers;
                    const visible = src.filter(st => !st.hidden);
                    if (!visible.length) return null;

                    const baseW = Math.max(1, bgW || canvas?.width || w);
                    const baseH = Math.max(1, bgH || canvas?.height || h);
                    const scaleX = w / baseW;
                    const scaleY = h / baseH;

                    const off = document.createElement('canvas');
                    off.width = w; off.height = h;
                    const ctx = off.getContext('2d');
                    ctx.imageSmoothingEnabled = true;
                    ctx.imageSmoothingQuality = 'high';

                    ctx.fillStyle = '#000';
                    ctx.fillRect(0, 0, w, h);

                    ctx.globalCompositeOperation = 'lighten';
                    ctx.save();
                    ctx.scale(scaleX, scaleY);
                    visible.forEach(st => {
                        if (!st.img) return;
                        const sw = st.img.width * st.scale;
                        const sh = st.img.height * st.scale;
                        ctx.save();
                        ctx.translate(st.x + sw / 2, st.y + sh / 2);
                        if (st.flipX) ctx.scale(-1, 1);
                        if (st.rotation) ctx.rotate(st.rotation);
                        ctx.scale(st.scale, st.scale);
                        ctx.drawImage(st.img, -st.img.width / 2, -st.img.height / 2);
                        ctx.restore();
                    });
                    ctx.restore();
                    ctx.globalCompositeOperation = 'source-over';

                    const id = ctx.getImageData(0, 0, w, h);
                    const d = id.data;
                    for (let i = 0; i < d.length; i += 4) {
                        const a = d[i + 3];
                        d[i] = d[i + 1] = d[i + 2] = 255;
                        d[i + 3] = a > 0 ? 255 : 0;
                    }
                    ctx.putImageData(id, 0, 0);
                    return off.toDataURL('image/png');
                }

                /* ----------  IMG-to-IMG FLOW  ---------- */

                function normalizeParams(model, rawStrength, rawGuidance, rawSteps) {
                    if (model === "sd21") {
                        return {
                            strength: Math.min(rawStrength, 0.90),         // SD-2.1 tolerates 0-0.9
                            guidance: rawGuidance,                         // 7–12 OK
                            steps: Math.max(rawSteps, 20)               // never <20
                        };
                    }
                    /* SDXL & SDXL-Inpaint */
                    return {
                        strength: Math.min(rawStrength, 0.80),           // detail washes out >0.8
                        guidance: Math.max(5, Math.min(rawGuidance, 9)), // XL over-guides above 10
                        steps: Math.max(rawSteps + 10, 30)            // XL needs ~10 more steps
                    };
                }

                async function runStableDiffusionFlow(modelChoice, promptTxt, drawerVals = null) {

                    const MODEL_LABEL = {
                        sd21: "SD 2.1",
                        sdxl: "SDXL",
                        "sdxl-inpaint": "SDXL InPaint"
                    };
                    setActionText(`${MODEL_LABEL[modelChoice] || "Stable Diffusion"} Img-2-Img — processing…`);
                    fakeProcessBar(10000);

                    const dv = drawerVals || readPromptDrawer();      // {strength,guidance,steps,seed}
                    const { strength, guidance, steps } =
                        normalizeParams(modelChoice, dv.strength, dv.guidance, dv.steps);
                    const seed = dv.seed;

                    showCancelBtn();                                // UI helpers
                    if (beforeLockIndex === -1 && currentOutIndex === -1) {
                        liveBGImage = backgroundImage;
                        liveFGStickers = stickers.map(cloneSticker);
                    }
                    const compCan = await buildCompositeForBackend();          // BG + FG
                    const initData = compCan.toDataURL('image/png');

                    /* ----- optional α-mask (SDXL-Inpaint only) ----- */
                    let maskData = null;
                    if (modelChoice === 'sdxl-inpaint') {
                        maskData = buildUnionStickerMaskPNG(compCan.width, compCan.height)
                            || buildFullWhiteMaskPNG(compCan.width, compCan.height);
                    }

                    /* ----- payload ----- */
                    const payload = {
                        prompt: promptTxt,
                        negative_prompt: "",
                        strength,
                        guidance_scale: guidance,
                        steps,
                        seed,
                        init_image: initData,
                        width: Math.floor(compCan.width / 8) * 8,
                        height: Math.floor(compCan.height / 8) * 8
                    };
                    if (maskData) payload.mask_image = maskData;

                    /* ----- routing ----- */
                    let endpoint = "", apiBase = "", useRealProgress = false;
                    switch (modelChoice) {
                        case 'sd21':
                            endpoint = '/sd-img2img'; apiBase = API_BASE; useRealProgress = true; break;
                        case 'sdxl':
                            //endpoint = '/sdxl-img2img'; apiBase = API_5100; break;
                            endpoint = '/sdxl-img2img'; apiBase = API_BASE; break;
                        case 'sdxl-inpaint':
                            //endpoint = '/sdxl-inpaint-img2img'; apiBase = API_5100; break;
                            endpoint = '/sdxl-inpaint-img2img'; apiBase = API_BASE; break;
                        case 'flux':
                            await runFluxText2Img(promptTxt); return;
                        default:
                            setActionText('Unknown model'); return;
                    }

                    /* ----- kick off request ----- */
                    let result;
                    try {
                        const r = await fetch(apiBase + endpoint, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });
                        result = await r.json();
                    } catch (e) {
                        setActionText(`${MODEL_LABEL[modelChoice] || "SD"} Img-2-Img ⇒ error: ` + e.message);
                    }

                    /* ----- handle result ----- */
                    hideCancelBtn(); stopProcessBar();
                    if (!result || !result.image_path) { setActionText('Error: no image'); return; }

                    let url = result.image_path;
                    if (!url.startsWith('http')) url = apiBase + '/' + url.replace(/^[/.]+/, '') + '?t=' + Date.now();

                    const img = new Image();
                    img.crossOrigin = 'anonymous';
                    img.onload = () => {
                        backgroundImage = img;
                        const info = `Prompt: ${promptTxt}\nStrength: ${strength}\nGuidance: ${guidance}\nSteps: ${steps}\nSeed: ${seed}`;
                        sessionOutputs.push({ img, model: MODEL_LABEL[modelChoice], info });
                        currentOutIndex = sessionOutputs.length - 1;
                        isOverlayVisible = false;
                        resetBeforeAfterState();
                        updateFgStickerVisibility();
                        updateFgToggleBtnVisual();
                        drawCanvas();
                        updateHistoryThumbs();
                        setActionText(`${MODEL_LABEL[modelChoice]} Img-2-Img ✔ History Updated→`);
                    };
                    img.src = url;
                }

                /******************************************************
                 * “Image2Image” HUD logic: i2iGenerateBtn
                 ******************************************************/
                const i2iCreativePower = document.getElementById("i2iCreativePower");
                const i2iCreativePowerVal = document.getElementById("i2iCreativePowerVal");

                const i2iPromptPower = document.getElementById("i2iPromptPower");
                const i2iPromptPowerVal = document.getElementById("i2iPromptPowerVal");

                const i2iSteps = document.getElementById("i2iSteps");
                const i2iStepsVal = document.getElementById("i2iStepsVal");

                // For each slider, do an "input" event to update the label
                i2iCreativePower.addEventListener("input", () => {
                    i2iCreativePowerVal.textContent = i2iCreativePower.value;
                });
                i2iPromptPower.addEventListener("input", () => {
                    i2iPromptPowerVal.textContent = i2iPromptPower.value;
                });
                i2iSteps.addEventListener("input", () => {
                    i2iStepsVal.textContent = i2iSteps.value;
                });

                document.getElementById("sdImg2ImgBtn").addEventListener("click", () => {
                    // 1) Show the workflowImageHUD if hidden
                    workflowImageHUD.style.display = "block";
                    // or position it on screen, etc.

                    // 2) Then run the same function
                    handleI2IGenerate();
                });
                document.getElementById("i2iGenerateBtn").addEventListener("click", handleI2IGenerate);
                document.getElementById("sdImg2ImgHudBtn").addEventListener("click", handleI2IGenerate);

                async function handleI2IGenerate() {
                    showCancelBtn();
                    console.log("handleI2IGenerate => reading user I2I parameters...");

                    // 1) Grab references to your HUD elements
                    const i2iPromptInput = document.getElementById("i2iPromptInput");
                    const i2iNegativePromptInput = document.getElementById("i2iNegativePromptInput");
                    const i2iCreativePower = document.getElementById("i2iCreativePower");
                    const i2iPromptPower = document.getElementById("i2iPromptPower");
                    const i2iSteps = document.getElementById("i2iSteps");
                    const i2ilockSeedCheckbox = document.getElementById("i2ilockSeedCheckbox");
                    //const i2iResolution = document.getElementById("i2iResolution");
                    const i2iModelSelect = document.getElementById("i2iModelSelect");

                    // 2) Read the user’s input
                    const promptVal = i2iPromptInput.value.trim();
                    const negativeVal = i2iNegativePromptInput.value.trim();
                    const creativeVal = parseFloat(i2iCreativePower.value) || 0.7;
                    const promptPowerVal = parseFloat(i2iPromptPower.value) || 7.5;
                    const stepsVal = parseInt(i2iSteps.value, 10) || 30;

                    //const [widthStr, heightStr] = (i2iResolution.value || "512x512").split("x");
                    //const outWidth = parseInt(widthStr, 10) || 512;
                    //const outHeight = parseInt(heightStr, 10) || 512;

                    const modelChoice = i2iModelSelect.value; // e.g. "sd15", "sd21", or "flux"

                    if (!promptVal) {
                        setActionText("No prompt => please type something!");
                        return;
                    }

                    // 3) Build the offscreen composite => initDataUrl
                    if (beforeLockIndex === -1 && currentOutIndex === -1) {
                        liveBGImage = backgroundImage;
                        liveFGStickers = stickers.map(cloneSticker);
                    }
                    const offC = await buildCompositeForBackend();
                    const initDataUrl = offC.toDataURL("image/png");


                    // 4) Build the request body
                    const body = {
                        modelChoice: modelChoice,
                        prompt: promptVal,
                        negative_prompt: negativeVal,
                        strength: creativeVal,
                        guidance_scale: promptPowerVal,
                        steps: stepsVal,
                        //width: outWidth,
                        //height: outHeight,
                        init_image: initDataUrl
                    };
                    const chosenSeed = getActiveSeed();
                    body.seed = chosenSeed;

                    setActionText("Image2Image => processing...");
                    i2iGenerateBtn.classList.add("seafoam30Active", "processing");
                    console.log("handleI2IGenerate => sending =>", body);

                    fakeProcessBar(10000);

                    // 6) POST to /sd-img2img (or flux i2i if you implement it)
                    if (modelChoice === "flux") {
                        // If you eventually implement flux i2i, call that route here
                        setActionText("Flux i2i not implemented…skipping");
                        return;
                    }

                    // stable diffusion route
                    try {
                        const resp = await fetch(`${API_BASE}/sd-img2img`, {
                            //add ----- fetch(`${API_BASE} / sd - img2img`, …)
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify(body)
                        });
                        const data = await resp.json();

                        if (data.error) {
                            console.error("SD i2i => error =>", data.error);
                            setActionText("SD img2img => error => " + data.error);
                            return;
                        }

                        if (data.image_path) {
                            const finalUrl = `${API_BASE}/${data.image_path}?t=${Date.now()}`;
                            const newImg = new Image();
                            newImg.crossOrigin = "Anonymous";
                            newImg.onload = () => {
                                const info = `Prompt: ${promptVal}\nNegative: ${negativeVal}\nStrength: ${creativeVal}\nGuidance: ${promptPowerVal}\nSteps: ${stepsVal}\nSeed: ${chosenSeed}`;
                                sessionOutputs.push({ img: newImg, model: modelChoice.toUpperCase(), info });        // Unified history add
                                currentOutIndex = sessionOutputs.length - 1;
                                isOverlayVisible = false;
                                resetBeforeAfterState();
                                updateFgStickerVisibility();
                                updateFgToggleBtnVisual();
                                //currentOutIndex = newIndex;    // <-- add this line
                                backgroundImage = newImg;
                                computeBgLayout(newImg);
                                drawCanvas();
                                updateHistoryThumbs();
                                stopFakeProcessBar();
                                setActionText("Img2Img ✔ History Updated->");
                                hideCancelBtn();
                                //i2iGenerateBtn.classList.remove("seafoam30Active", "processing");


                                //restore3DOverlay();
                            };
                            newImg.src = finalUrl;
                        } else {
                            setActionText("Img2Img => No image returned.");
                            i2iGenerateBtn.classList.remove("seafoam30Active", "processing");
                            stopFakeProcessBar();
                        }
                    } catch (err) {
                        setActionText("Img2Img Error: " + (err.message || err));
                        i2iGenerateBtn.classList.remove("seafoam30Active", "processing");
                        stopFakeProcessBar();
                    }
                }

                //function handleBackendResult(url) {
                //    const img = new Image();
                //    img.onload = function () {
                //        sessionOutputs.push({ img });
                //        backgroundImage = img;
                //        computeBgLayout(img);
                //        drawCanvas();
                //        updateHistoryThumbs();
                //    };
                //    img.src = url; // or a dataURL
                //}

                /******************************************************
                * Depth2Image
                ******************************************************/
                const d2iPromptInput = document.getElementById("d2iPromptInput");
                const d2iNegativePromptInput = document.getElementById("d2iNegativePromptInput");
                const d2iStrength = document.getElementById("d2iStrength");
                const d2iGuidance = document.getElementById("d2iGuidance");
                const d2iSteps = document.getElementById("d2iSteps");

                // Grab the small “value” <span> elements so we can update text
                const d2iStrengthVal = document.getElementById("d2iStrengthVal");
                const d2iGuidanceVal = document.getElementById("d2iGuidanceVal");
                const d2iStepsVal = document.getElementById("d2iStepsVal");

                // Listen for slider input => update text
                d2iStrength.addEventListener("input", () => {
                    d2iStrengthVal.textContent = d2iStrength.value;
                });

                d2iGuidance.addEventListener("input", () => {
                    d2iGuidanceVal.textContent = d2iGuidance.value;
                });

                d2iSteps.addEventListener("input", () => {
                    d2iStepsVal.textContent = d2iSteps.value;
                });

                async function handleDepth2ImgGenerate() {
                    showCancelBtn();
                    console.log("Depth2Img => reading user D2I parameters...");

                    const d2iPromptInput = document.getElementById("d2iPromptInput");
                    const d2iNegativePromptInput = document.getElementById("d2iNegativePromptInput");
                    const d2iStrength = document.getElementById("d2iStrength");
                    const d2iGuidance = document.getElementById("d2iGuidance");
                    const d2iSteps = document.getElementById("d2iSteps");

                    const promptVal = d2iPromptInput.value.trim();
                    const negativeVal = d2iNegativePromptInput.value.trim();
                    const d2iStrengthVal = parseFloat(d2iStrength.value) || 0.6;
                    const d2iGuidanceVal = parseFloat(d2iGuidance.value) || 7.5;
                    const d2iStepsVal = parseInt(d2iSteps.value, 10) || 30;

                    const depthCan = document.createElement('canvas');
                    depthCan.width = bgW;
                    depthCan.height = bgH;
                    const dCtx = depthCan.getContext('2d');

                    /* 1) draw user depth if present, else flat grey */
                    if (depthImage) dCtx.drawImage(depthImage, 0, 0, bgW, bgH);
                    else {
                        dCtx.fillStyle = '#808080';
                        dCtx.fillRect(0, 0, bgW, bgH);
                    }

                    /* 2) punch the same mask */
                    if (segmentationMask && !isForegroundMode) {
                        dCtx.globalCompositeOperation = 'destination-out';
                        dCtx.drawImage(segmentationMask, 0, 0, bgW, bgH);
                        dCtx.globalCompositeOperation = 'source-over';
                    }

                    const depthMaskedUrl = depthCan.toDataURL('image/png');

                    // If you require a background image or a depth image, check them:
                    if (!backgroundImage) {
                        setActionText("No BG => can't run Depth2Img");
                        return;
                    }

                    if (!promptVal) {
                        setActionText("Please enter a Depth2Img prompt!");
                        return;
                    }

                    setActionText("Depth2Img => processing…");
                    // Show spinner overlay if you have one:
                    //canvasSpinnerOverlay.style.display = "flex";
                    sdDepth2ImgBtn.classList.add("seafoam30Active", "processing");

                    fakeProcessBar(10000);


                    if (beforeLockIndex === -1 && currentOutIndex === -1) {
                        liveBGImage = backgroundImage;
                        liveFGStickers = stickers.map(cloneSticker);
                        console.log("SNAPSHOT (GENERATOR)", liveBGImage && liveBGImage.src, liveFGStickers);
                    }

                    // 1) Build your base64 init image from the current canvas or composite
                    const offC = await buildCompositeForBackend();
                    const dataUrl = offC.toDataURL("image/png");

                    const payload = {
                        init_image: dataUrl,
                        prompt: promptVal,
                        negative_prompt: negativeVal,
                        strength: d2iStrengthVal,
                        guidance_scale: d2iGuidanceVal,
                        steps: d2iStepsVal
                    };
                    const chosenSeed = getActiveSeedD2i();
                    payload.seed = chosenSeed;

                    console.log("handleDepth2ImgGenerate => sending =>", payload);

                    // 6) POST request
                    try {
                        const result = await fetchJsonSafe(`${API_BASE}/sd-depth2img`, {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({
                                init_image: dataUrl,
                                depth_image: depthMaskedUrl,
                                prompt: promptVal,
                                negative_prompt: negativeVal,
                                strength: d2iStrengthVal,
                                guidance_scale: d2iGuidanceVal,
                                steps: d2iStepsVal
                            })
                        });
                        //canvasSpinnerOverlay.style.display = "none";

                        if (result.error) {
                            setActionText("SD-Depth2Img => error => " + result.error);
                            return;
                        }
                        // 7) If success, load new image as overlay
                        if (result.image_path) {
                            const finalUrl = `${API_BASE}/${result.image_path}?t=${Date.now()}`;
                            const finalImg = new Image();
                            finalImg.crossOrigin = "Anonymous";
                            finalImg.onload = () => {
                                isOverlayVisible = false;
                                areFgStickersHidden = true;
                                const info = `Prompt: ${promptVal}\nNegative: ${negativeVal}\nStrength: ${d2iStrengthVal}\nGuidance: ${d2iGuidanceVal}\nSteps: ${d2iStepsVal}\nSeed: ${chosenSeed}`;
                                sessionOutputs.push({ img: finalImg, model: 'SD DEPTH2IMG', info });
                                currentOutIndex = sessionOutputs.length - 1;
                                resetBeforeAfterState();
                                updateFgStickerVisibility();
                                updateFgToggleBtnVisual();
                                setActionText("SD Depth2Image ✔ History Updated->");
                                drawCanvas();
                                updateHistoryThumbs();
                                sdDepth2ImgBtn.classList.remove("seafoam30Active", "processing");
                                hideCancelBtn();
                                stopFakeProcessBar();
                            };
                            finalImg.src = finalUrl;
                        }
                    } catch (err) {
                        console.error("SD-Depth2Img =>", err);
                        //canvasSpinnerOverlay.style.display = "none";
                        setActionText("SD-Depth2Img => see console");
                        sdDepth2ImgBtn.classList.remove("seafoam30Active", "processing");
                        stopFakeProcessBar();
                    }
                }
                sdDepth2ImgBtn.addEventListener("click", handleDepth2ImgGenerate);
                sdDepth2ImgHudBtn.addEventListener("click", handleDepth2ImgGenerate);

                /******************************************************
                * Sam Mask => /segment-sam
                ******************************************************/
                async function runGenerateMask(selectedSamModel) {
                    showCancelBtn();
                    if (!backgroundImage) {
                        setActionText("No background => can't generate mask");
                        return;
                    }

                    setActionText("Generating SAM mask...");

                    fakeProcessBar(10000);

                    try {
                        // 1) Render your background into a <canvas> so we can post it
                        const offC = await buildCompositeForBackend();
                        offC.width = canvas.width;
                        offC.height = canvas.height;
                        const offCtx = offC.getContext("2d");
                        offCtx.drawImage(backgroundImage, 0, 0, canvas.width, canvas.height);

                        // 2) Convert to Blob => needed for form data
                        const blob = await new Promise((resolve) => offC.toBlob(resolve, "image/png", 0.95));
                        if (!blob) {
                            setActionText("Could not retrieve BG data => no mask");
                            return;
                        }

                        // 3) Build FormData and send to /segment-sam
                        const formData = new FormData();
                        formData.append("image", blob, "bg.png");
                        formData.append("gpu_mode", isGpuMode ? "true" : "false");
                        formData.append("sam_model", selectedSamModel);
                        // e.g. "vit_l" from HUD or Settings

                        const data = await fetchJsonSafe(`${API_BASE}/segment-sam`, {
                            method: "POST",
                            body: formData,
                        });
                        if (data.error) {
                            setActionText("Mask error => " + data.error);
                            return;
                        }

                        // 4) If success => load the new mask
                        if (data.segmented_path) {
                            const maskUrl = `${API_BASE}/${data.segmented_path}?t=${Date.now()}`;
                            const mImg = new Image();
                            mImg.crossOrigin = "Anonymous";
                            mImg.onload = () => {
                                // Store it
                                segmentationMask = mImg;
                                refinedMaskImage = null; // If you are using refine steps

                                maskOpacitySlider.value = "0.5";

                                setActionText("Mask => ready. Tweak BG/FG or refine if needed.");
                                updateMaskPreview(); // real-time overlay
                                stopFakeProcessBar();
                                drawCanvas();        // in case user toggled BG/FG
                            };
                            mImg.src = maskUrl;
                        }
                    } catch (err) {
                        console.error("GenerateMask =>", err);
                        setActionText("Generate Mask error => " + err.toString());
                        stopFakeProcessBar();
                    } finally {
                        hideCancelBtn();
                    }
                }

                function updateMaskPreview() {
                    overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
                    // If the user set 0% or there's no mask => do nothing
                    const opacityVal = parseFloat(maskOpacitySlider.value);
                    if (!segmentationMask || opacityVal <= 0) return;

                    // 1) copy segmentationMask to an offscreen
                    const offC = document.createElement("canvas");
                    offC.width = overlayCanvas.width;
                    offC.height = overlayCanvas.height;
                    const offCtx = offC.getContext("2d");
                    offCtx.drawImage(segmentationMask, 0, 0, offC.width, offC.height);

                    // 2) getImageData => apply morphological ops
                    let imgData = offCtx.getImageData(0, 0, offC.width, offC.height);
                    imgData = doMorphOps(imgData, offC.width, offC.height);
                    let d = imgData.data;

                    // 2) Convert black => alpha=0, white => alpha=255
                    for (let i = 0; i < d.length; i += 4) {
                        const r = d[i];
                        const g = d[i + 1];
                        const b = d[i + 2];
                        const brightness = (r + g + b) / 3;

                        // if it's 'white' enough => keep alpha=255, else alpha=0
                        //if (brightness > 128) {
                        // Force the pixel to be white
                        d[i] = 255;
                        d[i + 1] = 255;
                        d[i + 2] = 255;
                        d[i + 3] = brightness;
                    }
                    //} else {
                    //d[i + 3] = 0;
                    //}
                    //}

                    // 3) putImageData() back
                    offCtx.putImageData(imgData, 0, 0);

                    // 4) Now draw that offscreen with an additive or screen blend
                    overlayCtx.globalCompositeOperation = "source-over";
                    overlayCtx.globalAlpha = parseFloat(maskOpacitySlider.value);
                    overlayCtx.drawImage(offC, 0, 0);
                    overlayCtx.restore();

                    // Reset to normal
                    //overlayCtx.globalCompositeOperation = "source-over";
                }

                // 2. Hook up each button to call runGenerateMask()

                // HUD “Gen Mask” text button:
                //generateMaskBtn.addEventListener("click", () => {
                //const model = document.getElementById("samModelSelectHud").value;
                //runGenerateMask(model);
                //});

                // HUD “mask” icon in the header:
                generateMaskIcon.addEventListener("click", () => {
                    const model = document.getElementById("samModelSelectHud").value;
                    runGenerateMask(model);
                });

                // top nav “Generate Mask” item (optional)
                generateMaskIconHud.addEventListener("click", () => {
                    // If you wanted to read from your main “Settings” overlay:
                    // const model = samModelSelect.value;
                    // or from the HUD:
                    const model = document.getElementById("samModelSelectHud").value;
                    runGenerateMask(model);
                });

                /******************************************************
                 * REFINE MASKING
                 ******************************************************/
                [maskOpacitySlider, maskDilationSlider, maskBlurSlider].forEach(sld => {
                    sld.addEventListener("input", () => {
                        maskOpacityVal.textContent = maskOpacitySlider.value;
                        maskDilationVal.textContent = maskDilationSlider.value;
                        maskBlurVal.textContent = maskBlurSlider.value;
                        updateMaskPreview();
                    });
                });

                /**
                 * Example morphological pipeline:
                 *   - threshold to binary
                 *   - dilation/erosion
                 *   - blur
                 */
                function doMorphOps(imgData, w, h) {
                    const rawDil = parseInt(maskDilationSlider.value) || 0;
                    const blurVal = parseInt(maskBlurSlider.value) || 0;

                    // For demonstration, let's do alpha-threshold
                    let src = cv.matFromImageData(imgData);
                    let dst = new cv.Mat();

                    // 2) Binarize alpha channel or threshold if needed
                    // (Or you can skip if your mask is already white/black.)
                    // If your mask is in BGR, you might do cv.cvtColor(src, dst, cv.COLOR_BGR2GRAY);
                    // Then threshold => cv.threshold(dst, 128, 255, cv.THRESH_BINARY, dst);

                    // 3) Dilation or erosion
                    if (rawDil !== 0) {
                        let kernelSize = Math.abs(rawDil); // e.g. 5 => 5x5 kernel
                        let kernel = cv.Mat.ones(kernelSize, kernelSize, cv.CV_8U);
                        let anchor = new cv.Point(-1, -1);
                        if (rawDil > 0) {
                            // positive => dilate
                            cv.dilate(src, dst, kernel, anchor, 1);
                        } else {
                            // negative => erode
                            cv.erode(src, dst, kernel, anchor, 1);
                        }
                        src.delete();
                        src = dst.clone();
                    }

                    // 4) Blur
                    if (blurVal > 0) {
                        // Simple box blur
                        cv.blur(src, dst, new cv.Size(blurVal, blurVal), new cv.Point(-1, -1), cv.BORDER_DEFAULT);
                        src.delete();
                        src = dst.clone();
                    }

                    // 5) Convert back to raw ImageData
                    let newImgData = new ImageData(new Uint8ClampedArray(src.data), w, h);

                    src.delete();
                    dst.delete();
                    return newImgData;
                }

                maskBlurSlider.addEventListener("input", () => {
                    maskBlurVal.textContent = maskBlurSlider.value;
                });

                maskDilationSlider.addEventListener("input", () => {
                    maskDilationVal.textContent = maskDilationSlider.value;
                });

                /******************************************************
                 * 3) "Apply" => commit morphological result to refinedMaskImage
                 ******************************************************/
                applyRefineBtn.addEventListener("click", () => {
                    if (!segmentationMask) {
                        setActionText("No segmentationMask => cannot refine");
                        return;
                    }
                    // 1) Create offscreen using the mask's native resolution
                    const offC = document.createElement("canvas");
                    offC.width = segmentationMask.width;
                    offC.height = segmentationMask.height;
                    const offCtx = offC.getContext("2d");
                    offCtx.drawImage(segmentationMask, 0, 0);

                    // 2) getImageData => morphological ops => putImageData
                    let imgData = offCtx.getImageData(0, 0, offC.width, offC.height);
                    imgData = doMorphOps(imgData, offC.width, offC.height);
                    offCtx.putImageData(imgData, 0, 0);

                    // 3) read back => store as the new segmentation mask
                    const newMask = new Image();
                    newMask.crossOrigin = "Anonymous";
                    newMask.onload = () => {
                        segmentationMask = newMask;
                        refinedMaskImage = newMask;
                        setActionText("Refine => mask updated + applied");

                        overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
                        drawCanvas();
                    };
                    newMask.src = offC.toDataURL("image/png");
                });

                /******************************************************
                 * 4) "Clear" => remove any mask
                 ******************************************************/
                clearMaskBtn.addEventListener("click", () => {
                    segmentationMask = null;
                    refinedMaskImage = null;
                    overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
                    setActionText("Mask cleared entirely");
                    // document.getElementById("refineMaskHUD").style.display = "none";
                    drawCanvas();
                });

                /******************************************************
                 * 5) BG/FG => immediate
                 ******************************************************/
                toggleModeBtn.addEventListener("click", () => {
                    // Flip the isForegroundMode
                    isForegroundMode = !isForegroundMode;
                    setActionText(isForegroundMode ? "FG mode => no mask" : "BG mode => behind mask");
                    drawCanvas(); // so user sees the effect instantly
                });

                /******************************************************
                 * invertMask
                 ******************************************************/
                invertMaskBtn.addEventListener("click", () => {
                    if (!segmentationMask) {
                        setActionText("No mask => can't invert");
                        return;
                    }
                    setActionText("Inverting mask...");
                    const offCan = document.createElement("canvas");
                    offCan.width = segmentationMask.width;
                    offCan.height = segmentationMask.height;
                    const offCtx = offCan.getContext("2d");
                    offCtx.drawImage(segmentationMask, 0, 0);

                    let iData = offCtx.getImageData(0, 0, offCan.width, offCan.height);
                    let dd = iData.data;
                    for (let i = 0; i < dd.length; i += 4) {
                        dd[i] = 255 - dd[i];
                        dd[i + 1] = 255 - dd[i + 1];
                        dd[i + 2] = 255 - dd[i + 2];
                    }
                    offCtx.putImageData(iData, 0, 0);

                    let newSrc = offCan.toDataURL();
                    let newMask = new Image();
                    newMask.crossOrigin = "Anonymous";
                    newMask.onload = () => {
                        segmentationMask = newMask;
                        refinedMaskImage = null;
                        setActionText("Mask inverted");
                        drawCanvas();
                    };
                    newMask.src = newSrc;
                });

                /******************************************************
                 * clickMode => single point => /segment-sam-click
                 ******************************************************/
                clickModeBtn.addEventListener('click', () => {
                    isClickMode = !isClickMode;
                    clickModeBtn.classList.toggle('seafoam30Active', isClickMode);
                    canvas.classList.toggle('clickModeCursor', isClickMode);
                    const label = clickModeBtn.querySelector('span');
                    if (label) label.textContent = isClickMode ? 'Click Mode: ON' : 'Click Mode';
                    setActionText(isClickMode
                        ? 'Click Mode ⇒ single‑click anywhere to grab a mask'
                        : 'Click Mode ⇒ OFF');
                });

                canvas.addEventListener('mousedown', e => {
                    if (!isClickMode) return;

                    const { x, y } = getWorldCoords(e.clientX, e.clientY);
                    const fd = {
                        x: Math.round(x), y: Math.round(y),
                        image_name: 'input.jpg',
                        gpu_mode: isGpuMode,
                        sam_model: document.getElementById('samModelSelectHud').value
                    };

                    fetchJsonSafe(`${API_BASE}/segment-sam-click`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(fd)
                    })
                        .then(data => {
                            if (!data.segmented_path) throw new Error('No mask path');
                            const url = `${API_BASE}/${data.segmented_path}?t=${Date.now()}`;
                            const img = new Image();
                            img.crossOrigin = 'Anonymous';
                            img.onload = () => {
                                segmentationMask = img;
                                refinedMaskImage = null;

                                /* NEW: auto‑display the mask */
                                maskOpacitySlider.value = '0.5';   // 50 %
                                maskOpacityVal.textContent = '0.5';
                                isMaskOverlayVisible = true;
                                updateMaskPreview();                // draw mask overlay

                                drawCanvas();                       // redraw FG / BG
                            };
                            img.src = url;
                        })
                        .catch(err => setActionText('ClickMask error – see console'))
                        .finally(() => {
                            isClickMode = false;
                            clickModeBtn.classList.remove('seafoam30Active');
                            canvas.classList.remove('clickModeCursor');
                            const lbl = clickModeBtn.querySelector('span');
                            if (lbl) lbl.textContent = 'Click Mode';
                        });
                });
                /******************************************************
                * 3D pipeline => shapeOnlyBtn, shapeAndTexBtn
                ******************************************************/
                function getPrimarySelectedIndex() {
                    if (selectedStickerIndices.size) return Array.from(selectedStickerIndices)[0];
                    if (activeStickerIndex !== -1) return activeStickerIndex;
                    if (stickers.length > 0) {
                        selectedStickerIndices.add(0);
                        activeStickerIndex = 0;
                        return 0;
                    }
                    return -1;
                }

                function getActiveStickerPNG() {
                    const idx = getPrimarySelectedIndex();
                    if (idx === -1) return null;
                    const st = stickers[idx];
                    if (!st.img) return null;
                    const restoreHud = hideAllStickerHud();
                    const off = document.createElement("canvas");
                    off.width = st.img.width;
                    off.height = st.img.height;
                    off.getContext("2d").drawImage(st.img, 0, 0);
                    restoreHud();
                    return off.toDataURL("image/png");
                }

                /* ----------------------------------------------------
                 * 1.   SHAPE-ONLY
                 * -------------------------------------------------- */
                let lastGeneratedGlb = "";

                document.getElementById("shapeOnlyBtn").addEventListener("click", runShapeOnly);

                async function runShapeOnly() {

                    const png = getActiveStickerPNG();
                    if (!png) { setActionText("Pick a foreground first"); return; }
                    showCancelBtn();

                    //function safeSwapTo3D() {
                    //    const st = stickers?.[activeStickerIndex];
                    //    if (!st || !st.domElement || !glbCanvas) return;

                    //    if (typeof st.domElement.style.visibility !== "undefined") {
                    //        st.domElement.style.visibility = "hidden";
                    //    }

                    //    glbCanvas.style.display = "block";
                    //    outline.style.opacity = 1;
                    //    modeBtn.style.display = "flex";
                    //}

                    //function safeSwapTo2D(sticker) {
                    //    try {
                    //        if (sticker.domElement && sticker.domElement.style) {
                    //            sticker.domElement.style.visibility = "visible";
                    //        }
                    //        if (glbCanvas) {
                    //            glbCanvas.style.display = "none";
                    //        }
                    //        isSwappedTo3D = false;
                    //    } catch (err) {
                    //        console.warn("Swap-to-2D failed:", err);
                    //    }
                    //}

                    shapeOnlyBtn.disabled = true;
                    setActionText("3-D Shape Only… starting");

                    try {
                        const payload = {
                            dataUrl: png,
                            //pipeline_choice: document.getElementById("threedModelSelectHud").value,
                            quality_idx: qualityIdx, // Index from the notched slider (0-4)
                            smooth_iter: parseInt(smoothingLabels[smoothIdx]) // Value as integer
                        };
                        const res = await fetch(API + "/threed-gen-shape", {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify(payload)
                        });
                        const j = await res.json();
                        if (!res.ok) throw new Error(j.error || "Shape step failed");
                        lastGeneratedGlb = j.glb_path;
                        setActionText("Shape done → " + lastGeneratedGlb);

                        // 2 – hide the underlying 2-D sticker
                        const st = stickers[activeStickerIndex];
                        if (!st || !st.domElement) {
                            return setActionText("Sticker DOM missing");
                        }
                        //safeSwapTo3D(st);

                        // 3 – place the WebGL canvas exactly over that sticker
                        const wrapRect = wrapper.getBoundingClientRect();
                        const targetX = st.x * camScale;
                        const targetY = st.y * camScale;
                        const side = st.img.width * st.scale * camScale;   /* we keep GLB square */

                        // 4 – load + show GLB via new helper in sticker_3d_container.js
                        const glbUrl = lastGeneratedGlb.startsWith("http")
                            ? lastGeneratedGlb
                            : `${API}/${lastGeneratedGlb}`;
                        await loadGlb(glbUrl, targetX, targetY, side);

                        setMode("move");               /* start in MOVE ⇒ orbit enabled */
                        setActionText("3-D shape loaded — Move / Scale / Swap ready");
                    }
                    catch (err) {
                        console.error(err);
                        setActionText(err.message.includes("Failed to fetch")
                            ? "Network / CORS error – check Flask logs"
                            : err.message);
                    }
                    finally { shapeOnlyBtn.disabled = false; }
                    hideCancelBtn();
                }

                /* ----------------------------------------------------
                 * 2.   SHAPE + TEXTURE
                 * -------------------------------------------------- */
                async function handleShapeAndTex() {
                    if (!lastGeneratedGlb) { alert("Run Shape-Only first."); return; }

                    const png = getActiveStickerPNG();
                    if (!png) { setActionText("Pick a foreground first"); return; }

                    shapeAndTexBtn.disabled = true;
                    setActionText("3-D Shape+Texture… starting");

                    try {
                        const payload = {
                            dataUrl: png,
                            shape_glb: lastGeneratedGlb            // tell Flask to reuse the mesh
                        };

                        const r = await fetch(API + "/threed-gen-tex", {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify(payload)
                        });
                        const j = await r.json();
                        if (!r.ok) throw new Error(j.error || "Texture failed");

                        setActionText("Textured model → " + j.glb_path);
                    }
                    catch (err) {
                        console.error(err);
                        setActionText(
                            err.message.includes("Failed to fetch")
                                ? "Network / CORS error – check Flask logs."
                                : "Texture step failed – see console."
                        );
                    }
                    finally { shapeAndTexBtn.disabled = false; }
                }

                /* ----------------------------------------------------
                 * 3.   Wire up buttons
                 * -------------------------------------------------- */
                shapeOnlyBtn.addEventListener("click", runShapeOnly);
                shapeAndTexBtn.addEventListener("click", handleShapeAndTex);

                /******************************************************
                 * CLOSING HUDs
                 ******************************************************/
                closeImageHUD.addEventListener("click", () => {
                    workflowImageHUD.style.display = "none";
                    setActionText("Closed Image Workflow HUD");
                    updateDrawerHighlight(wfImg, workflowImageHUD);
                });
                closeLightingHUD.addEventListener("click", () => {
                    workflowLightingHUD.style.display = "none";
                    setActionText("Closed Image Workflow HUD");
                    updateDrawerHighlight(wfLighting, workflowLightingHUD);
                });
                closeTimeHUD.addEventListener("click", () => {
                    workflowTimeHUD.style.display = "none";
                    setActionText("Closed Time of Day Workflow HUD");
                    updateDrawerHighlight(wfTime, workflowTimeHUD);
                });
                closeStylizeHUD.addEventListener("click", () => {
                    workflowStylizeHUD.style.display = "none";
                    setActionText("Closed Stylize Workflow HUD");
                    updateDrawerHighlight(wfStylize, workflowStylizeHUD);
                });
                close3DHUD.addEventListener("click", () => {
                    workflow3DHUD.style.display = "none";
                    setActionText("Closed 3D Workflow HUD");
                    updateDrawerHighlight(wf3D, workflow3DHUD);
                });
                closeVideoHUD.addEventListener("click", () => {
                    workflowVideoHUD.style.display = "none";
                    setActionText("Closed Video Workflow HUD");
                    updateDrawerHighlight(wfVideo, workflowVideoHUD);
                });

                /******************************************************
                 * DRAG HUD => image, 3D, video
                 ******************************************************/
                let isDraggingImageHUD = false;
                let hudOffsetX = 0, hudOffsetY = 0;
                workflowImageHUDTitle.addEventListener("mousedown", e => {
                    isDraggingImageHUD = true;
                    hudOffsetX = e.clientX - workflowImageHUD.offsetLeft;
                    hudOffsetY = e.clientY - workflowImageHUD.offsetTop;
                    e.preventDefault();
                });
                document.addEventListener("mouseup", () => (isDraggingImageHUD = false));
                document.addEventListener("mousemove", e => {
                    if (!isDraggingImageHUD) return;
                    workflowImageHUD.style.left = e.clientX - hudOffsetX + "px";
                    workflowImageHUD.style.top = e.clientY - hudOffsetY + "px";
                });

                let isDraggingTimeHUD = false;
                workflowTimeHUDTitle.addEventListener("mousedown", e => {
                    isDraggingTimeHUD = true;
                    hudOffsetX = e.clientX - workflowTimeHUD.offsetLeft;
                    hudOffsetY = e.clientY - workflowTimeHUD.offsetTop;
                    e.preventDefault();
                });
                document.addEventListener("mouseup", () => (isDraggingTimeHUD = false));
                document.addEventListener("mousemove", e => {
                    if (!isDraggingTimeHUD) return;
                    workflowTimeHUD.style.left = e.clientX - hudOffsetX + "px";
                    workflowTimeHUD.style.top = e.clientY - hudOffsetY + "px";
                });

                let isDraggingStylizeHUD = false;
                workflowStylizeHUDTitle.addEventListener("mousedown", e => {
                    isDraggingStylizeHUD = true;
                    hudOffsetX = e.clientX - workflowStylizeHUD.offsetLeft;
                    hudOffsetY = e.clientY - workflowStylizeHUD.offsetTop;
                    e.preventDefault();
                });
                document.addEventListener("mouseup", () => (isDraggingStylizeHUD = false));
                document.addEventListener("mousemove", e => {
                    if (!isDraggingStylizeHUD) return;
                    workflowStylizeHUD.style.left = e.clientX - hudOffsetX + "px";
                    workflowStylizeHUD.style.top = e.clientY - hudOffsetY + "px";
                });

                let isDraggingLightingHUD = false;
                workflowLightingHUDTitle.addEventListener("mousedown", e => {
                    isDraggingLightingHUD = true;
                    hudOffsetX = e.clientX - workflowLightingHUD.offsetLeft;
                    hudOffsetY = e.clientY - workflowLightingHUD.offsetTop;
                    e.preventDefault();
                });
                document.addEventListener("mouseup", () => (isDraggingLightingHUD = false));
                document.addEventListener("mousemove", e => {
                    if (!isDraggingLightingHUD) return;
                    workflowLightingHUD.style.left = e.clientX - hudOffsetX + "px";
                    workflowLightingHUD.style.top = e.clientY - hudOffsetY + "px";
                });

                let isDragging3d = false;
                workflow3DHUDTitle.addEventListener("mousedown", e => {
                    isDragging3d = true;
                    hudOffsetX = e.clientX - workflow3DHUD.offsetLeft;
                    hudOffsetY = e.clientY - workflow3DHUD.offsetTop;
                    e.preventDefault();
                });
                document.addEventListener("mouseup", () => (isDragging3d = false));
                document.addEventListener("mousemove", e => {
                    if (!isDragging3d) return;
                    workflow3DHUD.style.left = e.clientX - hudOffsetX + "px";
                    workflow3DHUD.style.top = e.clientY - hudOffsetY + "px";
                });

                let isDraggingVideoHUD = false;
                workflowVideoHUDTitle.addEventListener("mousedown", e => {
                    isDraggingVideoHUD = true;
                    hudOffsetX = e.clientX - workflowVideoHUD.offsetLeft;
                    hudOffsetY = e.clientY - workflowVideoHUD.offsetTop;
                    e.preventDefault();
                });
                document.addEventListener("mouseup", () => (isDraggingVideoHUD = false));
                document.addEventListener("mousemove", e => {
                    if (!isDraggingVideoHUD) return;
                    workflowVideoHUD.style.left = e.clientX - hudOffsetX + "px";
                    workflowVideoHUD.style.top = e.clientY - hudOffsetY + "px";
                });

                function makeDraggable(box, handle, ignoreSel = '') {
                    let dragging = false, offX = 0, offY = 0;

                    handle.addEventListener('mousedown', e => {
                        /* bail out if the user started on an ignored element */
                        if (ignoreSel && e.target.closest(ignoreSel)) return;

                        dragging = true;
                        box.style.position = 'absolute';          // switch to absolute once
                        offX = e.clientX - box.offsetLeft;
                        offY = e.clientY - box.offsetTop;
                        e.preventDefault();
                    });

                    document.addEventListener('mouseup', () => dragging = false);
                    document.addEventListener('mousemove', e => {
                        if (!dragging) {               // inside mousemove block
                            box.classList.remove('dragging');
                        } else {
                            box.classList.add('dragging');
                        }
                        if (!dragging) return;
                        box.style.left = e.clientX - offX + 'px';
                        box.style.top = e.clientY - offY + 'px';
                    });
                }

                /******************************************************
                 * Workflow nav => show/hide
                 ******************************************************/
                workflowImageBtn.addEventListener("click", () => {
                    if (workflowImageHUD.style.display !== "none") {
                        workflowImageHUD.style.display = "none";
                        setActionText("Image Workflow HUD => closed");
                    } else {
                        openWorkflowHUD(workflowImageHUD);
                        setActionText("Image Workflow HUD => opened");
                    }
                    updateDrawerHighlight(wfImg, workflowImageHUD);
                });
                workflow3DBtn.addEventListener("click", () => {
                    if (workflow3DHUD.style.display !== "none") {
                        workflow3DHUD.style.display = "none";
                        setActionText("3D Workflow HUD => closed");
                    } else {
                        openWorkflowHUD(workflow3DHUD);
                        setActionText("3D Workflow HUD => opened");
                    }
                    updateDrawerHighlight(wf3D, workflow3DHUD);
                });
                workflowVideoBtn.addEventListener("click", () => {
                    if (workflowVideoHUD.style.display !== "none") {
                        workflowVideoHUD.style.display = "none";
                        setActionText("Video Workflow HUD => closed");
                    } else {
                        openWorkflowHUD(workflowVideoHUD);
                        setActionText("Video Workflow HUD => opened");
                    }
                    updateDrawerHighlight(wfVideo, workflowVideoHUD);
                });
                workflowStylizeBtn.addEventListener("click", () => {
                    if (workflowStylizeHUD.style.display !== "none") {
                        workflowStylizeHUD.style.display = "none";
                        setActionText("Stylize Workflow HUD => closed");
                    } else {
                        openWorkflowHUD(workflowStylizeHUD);
                        setActionText("Stylize Workflow HUD => opened");
                    }
                    updateDrawerHighlight(wfStylize, workflowStylizeHUD);
                });
                workflowLightingBtn.addEventListener("click", () => {
                    if (workflowLightingHUD.style.display !== "none") {
                        workflowLightingHUD.style.display = "none";
                        setActionText("Lighting Workflow HUD => closed");
                    } else {
                        openWorkflowHUD(workflowLightingHUD);
                        setActionText("Lighting Workflow HUD => opened");
                    }
                    updateDrawerHighlight(wfLighting, workflowLightingHUD);
                });
                workflowMaterialBtn.addEventListener("click", () => {
                    if (workflowMaterialHUD.style.display !== "none") {
                        currentStickerForMaterial = null;
                        materialHudDocked = false;
                        closeWorkflowHUD(workflowMaterialHUD);
                        setActionText("Material Workflow HUD => closed");
                    } else {
                        openWorkflowMaterialHUD();
                        setActionText("Material Workflow HUD => opened");
                    }
                    updateDrawerHighlight(wfMaterial, workflowMaterialHUD);
                });
                workflowTimeBtn.addEventListener("click", () => {
                    if (workflowTimeHUD.style.display !== "none") {
                        workflowTimeHUD.style.display = "none";
                        setActionText("Time of Day Workflow HUD => closed");
                    } else {
                        openWorkflowHUD(workflowTimeHUD);
                        setActionText("Time of Day Workflow HUD => opened");
                    }
                    updateDrawerHighlight(wfTime, workflowTimeHUD);
                });

                /******************************************************
                 * Send to PS / Mixamo / Unreal
                 ******************************************************/
                sendToPsBtn.addEventListener("click", async () => {
                    // get the last .glb path we stored
                    const glbPath = lastGeneratedGlb;
                    if (!glbPath) {
                        setActionText("No recently generated .glb found!");
                        return;
                    }
                    setActionText("Sending GLB to Substance 3D Viewer...");

                    try {
                        let resp = await fetch(`${API_BASE}/send-substance`, {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({ glb_path: glbPath })
                        });
                        let data = await resp.json();
                        if (data.error) {
                            setActionText("Substance => " + data.error);
                        } else {
                            setActionText("3D Viewer => launched with .glb!");
                        }
                    } catch (err) {
                        console.error("SendToSubstance =>", err);
                        setActionText("Substance => see console");
                    }
                });
                sendToMixamoBtn.addEventListener("click", () => {
                    setActionText("Sending to Mixamo...");
                    sendToMixamoBtn.classList.add("seafoam30Active");
                    setTimeout(() => sendToMixamoBtn.classList.remove("seafoam30Active"), 1000);
                });
                sendToUnrealBtn.addEventListener("click", async () => {
                    setActionText("Sending to Unreal...");
                    sendToUnrealBtn.classList.add("seafoam30Active");
                    try {
                        const dataUrl = canvas.toDataURL("image/png");
                        const resp = await fetch(`${API_BASE}/send-unreal`, {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({ dataUrl })
                        });
                        const info = await resp.json();
                        if (info.error) {
                            setActionText("Unreal => " + info.error);
                        } else {
                            setActionText("Unreal => " + info.message);
                        }
                    } catch (err) {
                        console.error("SendToUnreal =>", err);
                        setActionText("Unreal => see console");
                    } finally {
                        setTimeout(() => sendToUnrealBtn.classList.remove("seafoam30Active"), 1000);
                    }
                });
                // Helper to read whichever Img2Video fields are visible
                function getI2VFields() {
                    const hudPrompt = document.getElementById("videoPromptHud");
                    const hudStyle = document.getElementById("videoStyleSelectHud");
                    const setPrompt = document.getElementById("img2VideoPrompt");
                    const setStyle = document.getElementById("img2VideoStyle");
                    return {
                        prompt: hudPrompt?.value || setPrompt?.value || "",
                        style: hudStyle?.value || setStyle?.value || ""
                    };
                }

                async function showWanPreview(url) {
                    const overlay = document.createElement("div");
                    overlay.style.cssText =
                        "position:fixed;inset:0;background:rgba(0,0,0,0.6);z-index:10070;display:flex;align-items:center;justify-content:center;";
                    const box = document.createElement("div");
                    box.style.cssText =
                        "width:1280px;max-width:92vw;background:#111;border:1px solid #2b2f35;border-radius:8px;padding:10px;";
                    const vid = document.createElement("video");
                    vid.src = url;
                    vid.controls = true;
                    vid.muted = true;
                    vid.loop = true;
                    vid.autoplay = true;
                    vid.style.cssText = "width:100%;height:auto;border-radius:6px;";
                    const close = document.createElement("div");
                    close.textContent = "Close";
                    close.style.cssText = "margin-top:10px;text-align:right;color:#9ee9d2;cursor:pointer;";
                    close.onclick = () => document.body.removeChild(overlay);
                    box.appendChild(vid);
                    box.appendChild(close);
                    overlay.appendChild(box);
                    document.body.appendChild(overlay);
                }

                const comfyLink = { enabled: true, connected: false };

                function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

                function setComfyStatus(connected, workflowText = "WAN 2.2 i2v") {
                    const dot = document.getElementById("comfyDot");
                    const txt = document.getElementById("comfyDockText");
                    comfyLink.connected = connected;
                    dot.style.background = connected ? "#2be0a5" : "#ef5350";
                    txt.textContent = connected ? `Comfy UI connected · ${workflowText}` : "Comfy UI offline";
                    document.getElementById("comfyDock").classList.toggle("disconnected", !connected);
                }

                const comfyDockEl = document.getElementById('comfyDock');
                comfyDockEl.classList.remove('is-visible');

                const comfyToggle = document.getElementById("comfyToggle");
                comfyToggle.addEventListener("click", () => {
                    comfyLink.enabled = !comfyLink.enabled;
                    comfyToggle.classList.toggle("off", !comfyLink.enabled);
                    if (!comfyLink.enabled) {
                        setComfyStatus(false);
                        setActionText("Comfy link disconnected.");
                        comfyDockEl.classList.remove('is-visible');
                    } else {
                        setComfyStatus(false);
                        setActionText("Comfy link enabled. Press “Send → Comfy UI” to connect.");
                    }
                });

                async function queryComfyStatus() {
                    if (!comfyLink.enabled) return null;
                    try {
                        const info = await fetchJsonSafe(`${API_BASE}/comfy/ping`);
                        if (!info || info.error) return null;
                        return info;
                    } catch (err) {
                        console.warn('Comfy ping failed:', err);
                        return null;
                    }
                }

                // Reveal the dock when the user explicitly chooses Send → Comfy UI
                sendToComfyBtn.addEventListener('click', async () => {
                    // show the dock immediately so the recording captures the “feels connected” moment
                    comfyDockEl.classList.add('is-visible');
                    comfyLink.enabled = true;                   // ensure toggled on
                    comfyToggle.classList.remove('off');
                    setActionText("Connecting to Comfy UI…");
                    await sleep(900);                           // deliberate pause
                    const ping = await queryComfyStatus();
                    await sleep(700);
                    if (!ping || !ping.online) {
                        setActionText("Comfy UI not detected.");
                        setComfyStatus(false);
                        return;
                    }
                    setActionText("Handshake complete.");
                    await sleep(500);
                    setComfyStatus(true, ping.workflow);
                    setActionText(`Connected. ${ping.workflow}`);
                });
                //sendToComfyBtn.addEventListener("click", () => {
                //    setActionText("Sending to Comfy UI...");
                //    sendToComfyBtn.classList.add("seafoam30Active");
                //    setTimeout(() => sendToComfyBtn.classList.remove("seafoam30Active"), 1000);
                //});

                /******************************************************
                 * Depth => /compute-depth
                 ******************************************************/
                async function runComputeDepth() {
                    showCancelBtn();

                    setActionText("Compute Depth => started...");
                    this.classList.add("seafoam30Active");
                    fakeProcessBar(10000);

                    if (beforeLockIndex === -1 && currentOutIndex === -1) {
                        liveBGImage = backgroundImage;
                        liveFGStickers = stickers.map(cloneSticker);
                    }

                    try {
                        const composite = await buildCompositeForBackend();
                        let dataUrl = composite.toDataURL("image/png");

                        let r = await fetch(`${API_BASE}/compute-depth-unified`, {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({ dataUrl })
                        });
                        let info = await r.json();

                        this.classList.remove("seafoam30Active");

                        if (!info.depth_path) {
                            setActionText("No depth_path => see console");
                            console.log("[DEPTH] =>", info);
                            return;
                        }

                        let depthUrl = `${API_BASE}/` + info.depth_path + "?t=" + Date.now();
                        let dImg = new Image();
                        dImg.crossOrigin = "Anonymous";
                        dImg.onload = () => {
                            setActionText("Depth => History Updated->");
                            imgGenImage = null;
                            depthImage = dImg;
                            isOverlayVisible = true;
                            const origBg = backgroundImage;
                            sessionOutputs.push({ img: dImg, model: 'DEPTH', info: 'Computed depth map', orig: origBg });
                            currentOutIndex = sessionOutputs.length - 1;
                            beforeAfterFresh = true;
                            isBeforeAfterPreview = false;
                            beforeAfterState = null;
                            if (sessionOutputs.length === 1) {
                                showHistoryPanel();
                            }
                            updateHistoryThumbs();
                            backgroundImage = origBg;
                            computeBgLayout(backgroundImage);
                            drawCanvas();
                            hideCancelBtn();
                            stopFakeProcessBar();
                        };
                        dImg.src = depthUrl;

                    } catch (err) {
                        console.error("ComputeDepth =>", err);
                        setActionText("Compute Depth => see console");
                        stopFakeProcessBar();
                        hideCancelBtn();
                        this.classList.remove("seafoam30Active");
                    }
                }

                document.querySelectorAll('#computeDepthBtn, #computeDepthHudBtn')
                    .forEach(btn => {
                        btn.addEventListener('click', runComputeDepth);
                    });

                /******************************************************
                 * ENHANCE => /image-enhance
                 ******************************************************/
                enhanceStrengthSlider.addEventListener("input", () => {
                    enhanceStrengthLabel.textContent = enhanceStrengthSlider.value;
                });
                enhanceStrengthHud.addEventListener("input", () => {
                    enhanceStrengthValHud.textContent = enhanceStrengthHud.value;
                });

                async function runEnhanceProcess() {
                    showCancelBtn();

                    if (!backgroundImage) {
                        setActionText("No BG => can't enhance");
                        return;
                    }
                    setActionText("Enhance => started...");
                    enhanceBtn.classList.add("seafoam30Active");
                    fakeProcessBar(10000);

                    const composite = await buildCompositeForBackend();
                    let dataUrl = composite.toDataURL("image/png");
                    let blendVal = parseFloat(enhanceStrengthSlider.value);

                    if (beforeLockIndex === -1 && currentOutIndex === -1) {
                        liveBGImage = backgroundImage;
                        liveFGStickers = stickers.map(cloneSticker);
                        console.log("SNAPSHOT (GENERATOR)", liveBGImage && liveBGImage.src, liveFGStickers);
                    }

                    try {
                        let resp = await fetch(`${API_BASE}/image-enhance`, {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({ dataUrl, blend_strength: blendVal })
                        });
                        let data = await resp.json();
                        enhanceBtn.classList.remove("seafoam30Active");
                        if (data.error) {
                            setActionText("Enhance => error => " + data.error);
                            return;
                        }
                        if (data.enhanced_path) {
                            const newUrl =
                                `${API_BASE}/` + data.enhanced_path + "?t=" + Date.now();
                            const eImg = new Image();
                            eImg.crossOrigin = "Anonymous";
                            eImg.onload = () => {
                                // store full-resolution upscaled image for magnify overlay
                                enhanceImage = eImg;
                                // fit the upscaled result into the current canvas size so
                                // Before/After reveals align with the original canvas
                                const scaledCanvas = document.createElement('canvas');
                                scaledCanvas.width = canvas.width;
                                scaledCanvas.height = canvas.height;
                                scaledCanvas.getContext('2d').drawImage(eImg, 0, 0, scaledCanvas.width, scaledCanvas.height);

                                const displayImg = new Image();
                                displayImg.onload = () => {
                                    backgroundImage = displayImg;
                                    // add to history and enable Before/After toggle
                                    addSessionOutput({ img: displayImg, model: 'ENHANCE', info: `Blend strength: ${blendVal}`, fullSrc: eImg.src });
                                    isOverlayVisible = false;
                                    resetBeforeAfterState();
                                    updateFgStickerVisibility();
                                    updateFgToggleBtnVisual();
                                    drawCanvas();
                                    updateLiveSnapshotIfCurrent();
                                    setActionText("Enhance => History Updated->");
                                };
                                displayImg.src = scaledCanvas.toDataURL('image/png');
                            };
                            eImg.src = newUrl;
                        }
                    } catch (err) {
                        console.error("Enhance =>", err);
                        setActionText("Enhance => error => see console");
                        stopFakeProcessBar();
                        hideCancelBtn();
                    } finally {
                        enhanceBtn.classList.remove("seafoam30Active");
                        stopFakeProcessBar();
                        hideCancelBtn();
                    }
                }
                enhanceBtn.addEventListener("click", runEnhanceProcess);
                enhanceLaunchIcon.addEventListener("click", () => {
                    settingsOverlay.style.display = "none";
                    runEnhanceProcess();
                });

                document.querySelectorAll('#enhanceBtn, #enhanceLaunchIconHud, #enhanceLaunchIcon')
                    .forEach(btn => {
                        btn.addEventListener('click', runEnhanceProcess);
                    });

                /******************************************************
                 * Click => Magnify / Toggle Enhanced
                 ******************************************************/
                magnifyEnhanceBtn.addEventListener("click", () => {
                    if (!enhanceImage) {
                        setActionText("No enhanced image to magnify!");
                        return;
                    }
                    enhancePreviewImg.src = enhanceImage.src;
                    enhancePreviewOverlay.style.display = "flex";
                    setActionText("Showing enhanced image full size");
                });
                toggleEnhanceBtn.addEventListener("click", () => {
                    isEnhanceVisible = !isEnhanceVisible;
                    if (isEnhanceVisible) {
                        toggleEnhanceBtn.classList.add("enhanceOn");
                        setActionText("Enhanced overlay => ON");
                    } else {
                        toggleEnhanceBtn.classList.remove("enhanceOn");
                        setActionText("Enhanced overlay => OFF");
                    }
                    drawCanvas();
                });
                closeEnhancePreviewBtn.addEventListener("click", () => {
                    enhancePreviewOverlay.style.display = "none";
                    if (document.fullscreenElement === enhancePreviewBox) {
                        document.exitFullscreen();
                    }
                    setActionText("Closed enhanced preview");
                });
                fullscreenEnhancePreviewBtn.addEventListener("click", () => {
                    if (!document.fullscreenElement) {
                        enhancePreviewBox.requestFullscreen?.();
                    } else {
                        document.exitFullscreen();
                    }
                });
                downloadEnhancePreviewBtn.addEventListener("click", () => {
                    if (!enhancePreviewImg.src) return;
                    const link = document.createElement("a");
                    link.download = "enhanced.png";
                    link.href = enhancePreviewImg.src;
                    link.click();
                    setActionText("Enhanced image downloaded");
                });
                document.addEventListener("fullscreenchange", () => {
                    if (document.fullscreenElement) {
                        fullscreenEnhancePreviewBtn.innerHTML = '<i class="fas fa-compress"></i>';
                    } else {
                        fullscreenEnhancePreviewBtn.innerHTML = '<i class="fas fa-expand"></i>';
                    }
                });

                /******************************************************
                * Img-to-Caption  (LLaVA only)
                ******************************************************/
                function getCaptionDataUrl() {
                    const maxDim = 256;
                    const tempCanvas = document.createElement("canvas");
                    let w = canvas.width, h = canvas.height;
                    if (w > maxDim || h > maxDim) {
                        if (w > h) { h = Math.round(h * (maxDim / w)); w = maxDim; }
                        else { w = Math.round(w * (maxDim / h)); h = maxDim; }
                    }
                    tempCanvas.width = w;
                    tempCanvas.height = h;
                    tempCanvas.getContext("2d").drawImage(canvas, 0, 0, w, h);
                    return tempCanvas.toDataURL("image/png");
                }

                async function runImgCaption() {
                    document.getElementById("cancelModelBtn").style.display = "inline-block";
                    showCancelBtn();
                    try {
                        setActionText("Generating image caption…");
                        imgCaptionBtn.classList.add("processing");
                        console.log("[Caption] — Button pressed.");

                        const dataUrl = getCaptionDataUrl();
                        console.log("[Caption] — DataURL length:", dataUrl.length);

                        // Start time for the request
                        const t0 = Date.now();

                        // 3. Call the backend caption API
                        const res = await fetchJsonSafe(`${API_BASE}/img-caption`, {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify({ image: dataUrl, gpu_mode: isGpuMode })
                        });
                        console.log("[Caption] — Fetch returned after", ((Date.now() - t0) / 1000).toFixed(2), "s:", res);

                        if (res.error) {
                            console.error("Full caption error:", res.error);
                            if (res.error.includes("canceled")) {
                                setActionText("Captioning was canceled by user.");
                            } else if (res.error.includes("timed out")) {
                                setActionText("Caption process timed out.");
                            } else if (res.error.includes("FAILED")) {
                                setActionText("Caption process failed. Please try again or check the logs.");
                            } else {
                                setActionText("Caption error: " + res.error.slice(0, 120)); // Short preview
                            }
                            setCaption(""); // Hide caption bar on error
                            imgCaptionBtn.classList.remove("processing");
                            return;
                        }

                        // 5. Set the caption bar with the returned caption
                        setCaption(res.caption || "(No caption found.)");
                        setActionText("Caption generated ✔");
                        imgCaptionBtn.classList.remove("processing");

                    } catch (err) {
                        setActionText("Caption ⇒ " + err.message);
                        setCaption("");
                        imgCaptionBtn.classList.remove("processing");
                        console.error("[Caption] — Exception:", err);
                    } finally {
                        hideCancelBtn();
                        //document.getElementById("cancelModelBtn").style.display = "none";
                    }
                }
                //async function runImgCaption() {
                //    if (!backgroundImage) { setActionText("No BG… cannot caption"); return; }

                //    [captionRunIcon, captionRunIconHud].forEach(btn => btn?.classList.add("seafoam30Active"));
                //    setActionText("Image2Caption processing...");

                //    const offC = await buildCompositeForBackend();
                //    const dataUrl = offC.toDataURL("image/png");

                //    try {
                //        const res = await fetchJsonSafe(`${API_BASE}/img-caption`, {
                //            method: "POST",
                //            headers: { "Content-Type": "application/json" },
                //            body: JSON.stringify({
                //                image: dataUrl,
                //                gpu_mode: isGpuMode
                //            })
                //        });
                //        if (!res.error) {
                //            setCaption(res.caption);
                //        }

                //        captionText.textContent = res.caption || "(empty)";
                //        copyCaptionBtn.style.display = "inline-block";
                //        setActionText("Caption ready ✔");
                //    } catch (err) {
                //        console.error("Caption ⇒", err);
                //        setActionText("Caption ⇒ check console");
                //    } finally {
                //        [imgCaptionBtn].forEach(btn => btn?.classList.remove("seafoam30Active"));
                //    }
                //}

                document.getElementById("captionText").innerText = captionText;
                document.getElementById("imgCaptionBtn").onclick = runImgCaption;

                //document.getElementById("captionRunIcon").addEventListener("click", runImgCaption);
                //document.getElementById("captionRunIconHud").addEventListener("click", runImgCaption);
                //document.getElementById("imgCaptionBtn").addEventListener("click", runImgCaption);




                /******************************************************
                 * MISC => e.g. img2Pose, img2Video
                 ******************************************************/
                img2PoseBtn.addEventListener("click", () => {
                    setActionText("Generating Pose...");
                    img2PoseBtn.classList.add("seafoam30Active");
                    setTimeout(() => img2PoseBtn.classList.remove("seafoam30Active"), 2000);
                });

                /******************************************************
                 * Download / toggle / copy caption
                 ******************************************************/
                downloadCanvasBtn.addEventListener("click", () => {
                    let link = document.createElement("a");
                    link.download = "canvas_output.png";
                    link.href = canvas.toDataURL("image/png");
                    link.click();
                    setActionText("Canvas downloaded");
                });

                beforeAfterBtn.addEventListener('click', () => {
                    beforeAfterFresh = false;
                    workflowsDrawer?.classList.remove('open');
                    if (isBeforeAfterPreview) {
                        if (beforeAfterState) {
                            backgroundImage = beforeAfterState.bg;
                            isOverlayVisible = beforeAfterState.overlay;
                            todBlendOriginal = beforeAfterState.blendOrig;
                            todBlendRatio = beforeAfterState.blendRatio;
                            const wasVisible = beforeAfterState.glbVisible;
                            const prevFgHidden = beforeAfterState.fgHidden;
                            beforeAfterState = null;
                            isBeforeAfterPreview = false;
                            if (typeof prevFgHidden === 'boolean') {
                                areFgStickersHidden = prevFgHidden;
                            }
                            computeBgLayout(backgroundImage);
                            updateFgStickerVisibility();
                            updateFgToggleBtnVisual();
                            drawCanvas();
                            if (wasVisible && window.isGlbReady) restore3DOverlay();
                        }
                    } else {
                        const beforeImg = getBeforeImage();
                        if (beforeImg) {
                            beforeAfterState = {
                                bg: backgroundImage,
                                overlay: isOverlayVisible,
                                blendOrig: todBlendOriginal,
                                blendRatio: todBlendRatio,
                                glbVisible: window.isGlbVisible,
                                fgHidden: areFgStickersHidden
                            };
                            backgroundImage = beforeImg;
                            isOverlayVisible = false;
                            todBlendOriginal = null;
                            todBlendRatio = 1;
                            isBeforeAfterPreview = true;
                            computeBgLayout(backgroundImage);
                            updateFgStickerVisibility();
                            drawCanvas();
                            if (window.isGlbReady) hide3DOverlay();
                        }
                    }
                    updateBeforeAfterButton();
                });

                if (canvasBeforeLock) {
                    canvasBeforeLock.addEventListener('click', () => {
                        const idxToLock = isBeforeAfterPreview
                            ? (beforeLockIndex === -1 ? currentOutIndex - 1 : beforeLockIndex)
                            : currentOutIndex;
                        beforeLockIndex = (beforeLockIndex === idxToLock ? -1 : idxToLock);
                        updateBeforeAfterButton();
                        updateHistoryThumbs();
                    });
                }
                //toggleOverlayBtn.addEventListener("click", () => {
                //    isOverlayVisible = !isOverlayVisible;
                //    if (isOverlayVisible) {
                //        toggleOverlayBtn.classList.add("overlayOn");
                //        toggleOverlayBtn.innerHTML = `<i class="fas fa-eye"></i>`;
                //        setActionText("Overlay => ON");
                //    } else {
                //        toggleOverlayBtn.classList.remove("overlayOn");
                //        toggleOverlayBtn.innerHTML = `<i class="fas fa-eye-slash"></i>`;
                //        setActionText("Overlay => OFF");
                //    }
                //    drawCanvas();
                //});
                //captionCopyBtn.addEventListener("click", () => {
                //    let text = captionText.textContent.trim();
                //    if (!text || text === "No caption yet.") return;
                //    navigator.clipboard.writeText(text).then(() => {
                //        setActionText("Caption copied to clipboard");
                //        copyCaptionBtn.classList.add("pulseCopy");
                //        setTimeout(() => copyCaptionBtn.classList.remove("pulseCopy"), 1200);
                //    });
                //});
                // Custom seed dropdown initialization
                let seedClipboardValue = null;
                let seedClipboardSource = null;

                function attachSeedDropdown(select) {
                    if (!select) return;
                    select.style.display = 'none';
                    const container = document.createElement('div');
                    container.className = 'seedDropdown';
                    select.parentNode.appendChild(container);
                    const display = document.createElement('div');
                    display.className = 'seedDisplay';
                    display.tabIndex = 0;
                    container.appendChild(display);
                    const list = document.createElement('ul');
                    list.className = 'seedList';
                    container.appendChild(list);
                    // prevent canvas zoom when scrolling seeds
                    container.addEventListener('wheel', e => e.stopPropagation());
                    const pinned = new Set();

                    function applySeed(seed) {
                        let opt = Array.from(select.options).find(o => o.value === seed);
                        if (!opt) {
                            opt = new Option(seed, seed);
                            select.add(opt);
                        }
                        select.value = seed;
                        display.textContent = seed;
                    }

                    function rebuild() {
                        list.innerHTML = '';
                        Array.from(select.options).forEach(opt => {
                            const li = document.createElement('li');
                            li.textContent = opt.textContent;
                            li.dataset.value = opt.value;
                            if (pinned.has(opt.value)) li.classList.add('pinned');
                            const btn = document.createElement('button');
                            btn.type = 'button';
                            btn.textContent = '✓';
                            btn.addEventListener('click', e => {
                                e.stopPropagation();
                                if (li.classList.toggle('pinned')) pinned.add(opt.value); else pinned.delete(opt.value);
                            });
                            li.appendChild(btn);
                            li.addEventListener('click', () => {
                                select.value = opt.value;
                                display.textContent = opt.textContent;
                                container.classList.remove('open');
                            });
                            list.appendChild(li);
                        });
                        const current = select.options[select.selectedIndex];
                        display.textContent = current ? current.textContent : '';
                    }

                    display.addEventListener('click', () => {
                        container.classList.toggle('open');
                    });

                    display.addEventListener('contextmenu', e => {
                        e.preventDefault();
                        const current = display.textContent.trim();
                        if (seedClipboardValue && seedClipboardSource !== display) {
                            applySeed(seedClipboardValue);
                        } else {
                            seedClipboardValue = current;
                            seedClipboardSource = display;
                            navigator.clipboard.writeText(current);
                        }
                    });

                    display.addEventListener('keydown', e => {
                        if (e.ctrlKey && e.key === 'c') {
                            e.preventDefault();
                            const current = display.textContent.trim();
                            seedClipboardValue = current;
                            seedClipboardSource = display;
                            navigator.clipboard.writeText(current);
                        }
                        if (e.ctrlKey && e.key === 'v') {
                            e.preventDefault();
                            navigator.clipboard.readText().then(text => {
                                const t = text.trim();
                                if (/^\d+$/.test(t)) {
                                    seedClipboardValue = t;
                                    seedClipboardSource = display;
                                    applySeed(t);
                                }
                            });
                        }
                    });

                    document.addEventListener('click', e => {
                        if (!container.contains(e.target)) container.classList.remove('open');
                    });
                    rebuild();
                    const observer = new MutationObserver(rebuild);
                    observer.observe(select, { childList: true });
                }

                document.querySelectorAll('select.seedSelect').forEach(attachSeedDropdown);
                document.addEventListener('DOMContentLoaded', () => {
                    document.querySelectorAll('.hudSection').forEach(section => {
                        const resetBtn = document.createElement('span');
                        resetBtn.className = 'sectionResetBtn';
                        resetBtn.innerHTML = '<i class="fas fa-undo"></i>';
                        section.prepend(resetBtn);
                        const inputs = section.querySelectorAll('input, select, textarea');
                        inputs.forEach(el => {
                            if (el.tagName === 'SELECT' && el.multiple) {
                                el.dataset.defaultSelected = Array.from(el.selectedOptions).map(o => o.value).join(',');
                            } else if (el.type === 'checkbox' || el.type === 'radio') {
                                el.dataset.defaultChecked = el.checked;
                            } else {
                                el.dataset.defaultValue = el.value;
                            }
                            const show = () => { resetBtn.style.display = 'block'; };
                            el.addEventListener('change', show);
                            el.addEventListener('input', show);
                        });
                        resetBtn.addEventListener('click', () => {
                            inputs.forEach(el => {
                                if (el.tagName === 'SELECT' && el.multiple) {
                                    const defaults = (el.dataset.defaultSelected || '').split(',');
                                    Array.from(el.options).forEach(opt => {
                                        opt.selected = defaults.includes(opt.value);
                                    });
                                    el.dispatchEvent(new Event('change'));
                                } else if (el.type === 'checkbox' || el.type === 'radio') {
                                    el.checked = el.dataset.defaultChecked === 'true';
                                    el.dispatchEvent(new Event('change'));
                                } else {
                                    el.value = el.dataset.defaultValue || '';
                                    el.dispatchEvent(new Event('input'));
                                    el.dispatchEvent(new Event('change'));
                                }
                            });
                            resetBtn.style.display = 'none';
                        });
                    });
                });
                // Re-align HUD elements if the viewport size changes
                window.addEventListener("resize", () => {
                    drawCanvas();
                    if (typeof __glbSyncHud === "function") __glbSyncHud();
                });
            </script>
            <div id="floatingCanvasTip" class="canvasTooltip">Add FG Image</div>

</body>
</html>
